[
["visu1.html", "Module 2 Visualisation I", " Module 2 Visualisation I Objectifs : Découvrir –et vous émerveiller de– ce que l’on peut faire avec le logiciel R (R Core Team 2018) Savoir réaliser différentes variantes d’un graphique en nuage de points dans R avec la fonction chart() Découvrir le format R Markdown (Allaire et al. 2018) et la recherche reproductible Intégrer ensuite des graphiques dans un rapport et y décrire ce que que vous observez Comparer de manière critique un workflow ‘classique’ en biologie utilisant Microsoft Excel et Word avec une approche utilisant R et R Markdown; prendre conscience de l’énorme potentiel de R Prérequis : Si ce n’est déjà fait, vous devez installer et vous familiariser avec la ‘SciViews Box’, RStudio et Markdown . Vous devez aussi maitriser les bases de git et de Github (avoir un compte Github, savoir clôner un dépôt localement, travailler avec Github Desktop pour faire ses commits, push et pull). L’ensemble de ces outils a été abordé lors de la création de votre site professionnel et personnel du module 1. Avant de poursuivre, vous allez devoir découvrir les premiers rudiments de R afin de pouvoir réaliser par la suite vos premiers graphiques. Pour cela, vous aurez à lire attentivement et effectuer tous les exercices de deux tutoriels1. Démarrez la SciViews Box et RStudio. Dans la fenêtre Console de RStudio, entrez l’instruction suivante suivie de la touche Entrée pour ouvrir le tutoriel concernant les bases de R : BioDataScience::run(&quot;02a_base&quot;) Ensuite, vous pouvez également parcourir le tutoriel qui vous permettra de découvrir R (cliquez dans la fenêtre Console de RStudio et appuyez sur la touche ESC pour reprendre la main dans R à la fin d’un tutoriel) : BioDataScience::run(&quot;02b_decouverte&quot;) (BioDataScience est un package R spécialement développé pour ce cours et que vous avez dû installer lors de la configuration de votre SciViews Box, voir Appendice A.3.3). Références "],
["nuage-de-points.html", "2.1 Nuage de points", " 2.1 Nuage de points Dès que vous vous sentez familiarisé avec les principes de base de R, vous allez pouvoir réaliser assez rapidement des beaux graphiques. Par exemple, si vous souhaitez représenter une variable numérique en fonction d’une autre variable numérique, vous pouvez exprimer cela sous la forme d’une formule2 \\[y \\sim x\\] que l’on peut lire “y en fonction de x”. Pour les deux variables numériques x et y, la représentation graphique la plus classique est le nuage de points (voir Fig. 2.1 pour un exemple). Figure 2.1: Exemple de graphique en nuage de points. Des éléments essentiels sont ici mis en évidence en couleurs. Les éléments indispensables à la compréhension d’un nuage de points sont mis en évidence à la Fig. 2.1 : Les axes avec les graduations (en rouge), les labels et les unités des axes (en bleu). Les instructions dans R pour produire un tel nuage de point sont : # Chargement de SciViews::R SciViews::R # Importation du jeu de données (urchin &lt;- read(&quot;urchin_bio&quot;, package = &quot;data.io&quot;, lang = &quot;fr&quot;)) # # A tibble: 421 x 19 # origin diameter1 diameter2 height buoyant_weight weight solid_parts # &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 Fishe… 9.9 10.2 5 NA 0.522 0.478 # 2 Fishe… 10.5 10.6 5.7 NA 0.642 0.589 # 3 Fishe… 10.8 10.8 5.2 NA 0.734 0.677 # 4 Fishe… 9.6 9.3 4.6 NA 0.370 0.344 # 5 Fishe… 10.4 10.7 4.8 NA 0.610 0.559 # 6 Fishe… 10.5 11.1 5 NA 0.610 0.551 # 7 Fishe… 11 11 5.2 NA 0.672 0.605 # 8 Fishe… 11.1 11.2 5.7 NA 0.703 0.628 # 9 Fishe… 9.4 9.2 4.6 NA 0.413 0.375 # 10 Fishe… 10.1 9.5 4.7 NA 0.449 0.398 # # ... with 411 more rows, and 12 more variables: integuments &lt;dbl&gt;, # # dry_integuments &lt;dbl&gt;, digestive_tract &lt;dbl&gt;, # # dry_digestive_tract &lt;dbl&gt;, gonads &lt;dbl&gt;, dry_gonads &lt;dbl&gt;, # # skeleton &lt;dbl&gt;, lantern &lt;dbl&gt;, test &lt;dbl&gt;, spines &lt;dbl&gt;, # # maturity &lt;int&gt;, sex &lt;fct&gt; # Réalisation du graphique chart(urchin, height ~ weight) + geom_point() La fonction chart() requiert comme argument le jeu de donnée (urchin, c’est un objet dataframe ou tibble dans le langage de R), ainsi que la formule à employer dans laquelle vous avez indiqué le nom des variables que vous voulez sur l’axe des ordonnées à gauche et des abscisses à droite de la formule. Vous voyez que le jeu de données contient beaucoup de variables (les titres des colonnes du tableau en sortie). Parmi toutes ces variables, nous avons choisi ici de représenter height en fonction de weight, la hauteur en fonction de la masse des oursins. Jusqu’ici, nous avons spécifié ce que nous voulons représenter, mais pas encore comment (sous quelle apparence), nous voulons les matérialiser sur le graphique. Pour un nuage de points, nous voulons les représenter sous forme de … points ! Donc, nous devons ajouter la fonction geom_point() pour indiquer cela. 2.1.1 Le nuage de points en vidéo Vous trouverez une vidéo ci-dessous vous expliquant la création du nuage de points dans R sur ce jeu de données mais analysant d’autres variables. Cette vidéo ne vous a montré que les principaux outils disponibles lors de la réalisation de graphiques. Soyez curieux et expérimentez par vous-même ! 2.1.2 A vous de jouer ! Dans la fenêtre Console de RStudio, entrez l’instruction suivante suivie de la touche Entrée pour ouvrir le tutoriel concernant le nuage de points : BioDataScience::run(&quot;02c_nuage_de_points&quot;) N’oubliez pas d’appuyer sur la touche ESC pour reprendre la main dans R à la fin d’un tutoriel) 2.1.3 Pièges et Astuces 2.1.3.1 Modifications des échelles d’un graphiques Vous devez être vigilant lors de la réalisation d’un nuage de point particulièrement sur l’étendue des valeurs présentées sur vos axes. Vous devez utilisez votre expertise de biologistes pour vous posez les deux questions suivantes : Est ce que l’axe représente des valeurs plausibles de hauteurs et de masses de ces oursins apparetenant à l’espèce Paracentrotus lividus ? Quels est la précision des mesures effectuées ? Dans certains cas, la forme du nuage de points peut être distendu par la présence de valeurs aberrantes. Ce n’est pas le cas ici, mais nous pouvons le simuler en distandant artificiellement soit l’axe X, soit l’axe Y, soit les deux : A &lt;- chart(urchin, height ~ weight) + geom_point() + theme(text = element_text(size = 10)) # Réduction des labels # Modification des échelles B &lt;- A + scale_x_continuous(limits = c(0, 500)) C &lt;- A + scale_x_continuous(limits = c(-100, 120)) D &lt;- A + scale_x_continuous(limits = c(-400, 400)) + scale_y_continuous(limits = c(-400, 400)) # Assemblage des graphiques combine_charts(list(A, B, C, D), font.label = list(size = 14, align = &quot;hv&quot;)) Figure 2.2: Piège du nuage de points. A) graphique initialemontrant la variation de la hauteur [mm] en fonction de la masse [g] B) graphique A avec la modification de l’échelle de l’axe X. C) Graphique A avec une seconde modification de l’axe X. D) Graphique A avec modification de l’échelle de l’axe X et de l’axe Y. 2.1.3.2 Transformations des données Vous avez la possibilité d’appliquer une transformation de vos données (il est même conseillé de le faire) afin qu’elles soient plus facilement analysables. Par exemple, il est possible d’utiliser des fonctions de puissance, racines, logarithmes, exponentielles3 pour modifier l’apparence du nuage de points dans le but de le rendre plus linéaire (car il est plus facile d’analyser statistiquement des données qui s’alignent le long d’une droite). # Réalisation du graphique de la hauteur en fonction de la masse A &lt;- chart(urchin, height ~ weight) + geom_point() # Application du logarithme sur les deux variables représentées B &lt;- chart(urchin, log(height) ~ log(weight)) + geom_point() # Assemblage des graphiques combine_charts(list(A, B), font.label = list(size = 14, align = &quot;hv&quot;)) Figure 2.3: A) Variation de la hauteur [mm] en fonction de la masse [g] d’oursins violets. B) Variation du logarithme népérien de la hauteur [mm] en fonction du logarithme népérien de la masse [g] de ces mêmes oursins 2.1.3.3 Utilisation des snippets RStudio permet de récupérer rapidement des instructions à partir d’une banque de solutions toutes prêtes. Cela s’appelle des snippets. Vous avez une série de snippets disponibles dans la SciViews Box. Cela qui vous permet de réaliser un graphique en nuage de poinsts s’appelle .cbxy. Entrez ce code et appuyez ensuite sur la tabulation dans un script R, et vous verrez le code remplacé par ceci : chart(data = DF, YNUM ~ XNUM) + geom_point() Vous avez à votre disposition un ensemble de snippet que vous pouvez retrouvez dans l’aide mémoire sur SciViews. Vous avez également à votre disposition l’aide-mémoire sur la visualisation des données (Data Visualization Cheat Sheet). 2.1.4 A vous de jouer ! Une nouvelle tâche va vous être demandée ci-dessous en utilisant GitHub Classroom 1.2.4.3. Cette tâche est un travail individuel. Une fois votre assignation réalisée, faite un clone de votre dépôt et placer le dans le dossier project. Cette nouvelle tâche qui vous est demandée vous propose d’employer un projet RStudio @ref(rs_projet) Les instructions que vous employez dans un learnR peuvent être employée dans un script d’analyse. Sur base du jeux de données urchin_bio, explorez différents graphiques en nuages de points. Utilisez l’URL suivant qui va vous donner accès à votre tâche. https://classroom.github.com/a/eYrXLy_u Inspirez vous de script présent dans le dépôt sdd1_iris. Vous devez commencer par faire un fork du dépôt puis de faire un clone du dépôt sur votre ordinateur en local. https://github.com/BioDataScience-Course/sdd1_iris Faites une attention toute particulière à l’écriture d’un script. Il contient un titre , une date de la dernière mise à jour, le nom de l’auteur, un ensemble de commentaires permettant l’organisation de ce script. Des explications détaillées se trouvent dans l’annexe B.1.2 dédiée aux R scripts. 2.1.5 Pour en savoir plus… Visualisation des données dans R for Data Science. Chapitre du livre portant sur la visualisation des données ggplot2 nuage de point. Tutorial en français portant sur l’utilisation d’un nuage de point avec le package ggplot2 et la fonction geom_point(). Fundamentals of Data Visualization. Un livre sur les fondamentaux de la visualisation graphique. R Graphics Cookbook - Chapter 5: Scatter Plots. Un chapitre d’un livre en anglais sur l’utilisation du nuage de point. geom_point(). La fiche technique de la fonction. 2.1.6 A vous de jouer ! Dans la fenêtre Console de RStudio, entrez l’instruction suivante suivie de la touche Entrée pour ouvrir le tutoriel concernant le nuage de points : BioDataScience::run(&quot;02d_np_challenge&quot;) N’oubliez pas d’appuyer sur la touche ESC pour reprendre la main dans R à la fin d’un tutoriel) Dans R, une formule permet de spécifier les variables avec lesquelles on souhaite travailler, et leur rôle. Par exemple ici, la variable x sur l’axe des abscisses et la variable y sur l’axe des ordonnées.↩ Pour les proportions (p) ou les pourcentages (%) (valeurs bornées entre 0 et 1 ou 0 et 100%, la transformation arcsin est souvent utilisée : \\(p′ = \\arcsin \\sqrt{p}\\).↩ "],
["integration-des-graphiques-dans-un-rapport-r-markdown.html", "2.2 Intégration des graphiques dans un rapport: R Markdown", " 2.2 Intégration des graphiques dans un rapport: R Markdown Un fichier R Markdown est un fichier terminant par l’extension .Rmd. Il provient de la combinaison du language markdown appris durant le premier module et le code appris durant la première partie de ce module 2. Des explications détaillées se trouvent dans l’annexe B.1.3 dédiée au R Markdown. L’écriture d’un rapport d’analyse scientifique doit respecter certaines conventions que vous pouvez retrouvez dans l’annexe @ref(redaction_scientifique). 2.2.1 Pour en savoir plus… What is R Markdown?. Video en anglais + site présentant les différentes possibilités, par les concepteurs de R Markdown (RStudio). Introduction to R Markdown. Tutorial en anglais, par RStudio, les concepteurs de R Markdown, Aide mémoire R Markdown: dans les menus RStudio Help -&gt; Cheatsheets -&gt; R Markdown Cheat Sheet Référence rapide à Markdown: dans les menus RStudio Help -&gt; Markdown Quick Reference Introduction à R Markdown. Présentation en français par Agrocampus Ouest - Rennes. Le langage R Markdown. Introduction en français concise, mais relativement complète. https://rworkshop.uni.lu/lectures/lecture04_rmarkdown.html#12 2.2.2 A vous de jouer ! Utilisation de R Notebook Employez le projet sdd1_urchin_bio que vous avez obtenu via le lien GitHub Classroom dans la première partie de ce module. Votre objectif est de comprendre les données proposées, en utilisant des visualisations graphiques appropriées et en documentant le fruit de votre étude dans un rapport R Notebook. Utilisez le graphique en nuage de points que vous venez d’étudier bien sûr, mais vous êtes aussi encouragés à expérimenter d’autres visualisations graphiques. Workflow “classique” en biologie (Microsoft Excel et Word) comparé à R et R Markdown Une nouvelle tâche va vous être demandée ci-dessous en utilisant GitHub Classroom 1.2.4.3. Cette tâche est un travail en équipe. Une fois votre assignation réalisée, faite un clone de votre dépôt et placer le dans le dossier project. Comparez le workflow classique en biologie et R - R Markdown en suivant les explications suivantes : Utilisez l’URL suivant qui va vous donner accès à votre tâche. https://classroom.github.com/g/2Cii2dws "],
["visu2.html", "Module 3 Visualisation II", " Module 3 Visualisation II Objectifs : Savoir réaliser différentes variantes de différents graphiques tel que les histogrammes, les graphes de densité ou encore les diagramme en violon dans R avec la fonction chart() Intégrer ensuite des graphiques dans un rapport et y décrire ce que que vous observez Gérer des conflits dans GitHub Prérequis : Si ce n’est déjà fait, vous devez avoir réaliser les modules précédents. "],
["histogramme.html", "3.1 Histogramme", " 3.1 Histogramme Lors d’une expérience vous souhaitez visualiser la façon dont vos données s’étale sur un axe (On parle de distribution4 en statistique) pour l’une des vairables étudiées. L’histogramme est l’un des outils pouvant vous apporter cette information. Ce graphique va découper en plusieurs classes5 la variable étudiée. Figure 3.1: Histogramme montrant la distribution de la taille d’un échantillon de zooplancton analysé par analyse d’image. Les éléments indispensables à la compréhension d’un histogramme sont (ici mis en évidence en couleur) Les axes avec les graduations (en rouge) les labels et unité des axes (en bleu) Les instructions de base afin de produire un histogramme : # Importation du jeu de données (zooplankton &lt;- read( file = &quot;zooplankton&quot;, package = &quot;data.io&quot;, lang = &quot;fr&quot;)) # # A tibble: 1,262 x 20 # ecd area perimeter feret major minor mean mode min max std_dev # &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 0.770 0.465 4.45 1.32 1.16 0.509 0.363 0.036 0.004 0.908 0.231 # 2 0.700 0.385 2.32 0.728 0.713 0.688 0.361 0.492 0.024 0.676 0.183 # 3 0.815 0.521 4.15 1.33 1.11 0.598 0.308 0.032 0.008 0.696 0.204 # 4 0.785 0.484 4.44 1.78 1.56 0.394 0.332 0.036 0.004 0.728 0.218 # 5 0.361 0.103 1.71 0.739 0.694 0.188 0.153 0.016 0.008 0.452 0.110 # 6 0.832 0.544 5.27 1.66 1.36 0.511 0.371 0.02 0.004 0.844 0.268 # 7 1.23 1.20 15.7 3.92 1.37 1.11 0.217 0.012 0.004 0.784 0.214 # 8 0.620 0.302 3.98 1.19 1.04 0.370 0.316 0.012 0.004 0.756 0.246 # 9 1.19 1.12 15.3 3.85 1.34 1.06 0.176 0.012 0.004 0.728 0.172 # 10 1.04 0.856 7.60 1.89 1.66 0.656 0.404 0.044 0.004 0.88 0.264 # # ... with 1,252 more rows, and 9 more variables: range &lt;dbl&gt;, size &lt;dbl&gt;, # # aspect &lt;dbl&gt;, elongation &lt;dbl&gt;, compactness &lt;dbl&gt;, transparency &lt;dbl&gt;, # # circularity &lt;dbl&gt;, density &lt;dbl&gt;, class &lt;fct&gt; # Réalisation du graphique chart(zooplankton, formula = ~ size) + geom_histogram(bins = 50) Figure 3.2: Instructions pour obtenir un histogramme. # bins permet de préciser le nombre de classes souhaitées La fonction chart() requiert comme argument le jeu de donnée (zooplankton, c’est un objet dataframe ou tibble dans le langage de R), ainsi que la formule à employer dans laquelle vous avez indiqué le nom de la variable que vous voulez sur l’axe des abscisses à droite de la formule. Vous voyez que le jeu de données contient beaucoup de variables (les titres des colonnes du tableau en sortie). Parmi toutes ces variables, nous avons choisi ici de représenter size, Jusqu’ici, nous avons spécifié ce que nous voulons représenter, mais pas encore comment (sous quelle apparence), nous voulons les matérialiser sur le graphique. Pour un histogramme, nous devons ajouter la fonction geom_histogram() pour indiquer cela. L’argument bins dans cette fonction permet de préciser le nombre de classes souhaitées. Vous pouvez décripter votre histogramme sur base des modes6 et de la symétrie7 de ces derniers. Les modes les plus fréquents sont unimodal, bimodal ou multimodal. Figure 3.3: Histogrammes montrant les modes et symétries : A. histogramme unimodal et symétrique, B. histogramme bimodal et asymétrique, C. histogramme unimodal et asymétrique, D. histogramme multimodal et symétrique. 3.1.1 Pièges et astuces 3.1.1.1 Nombres de classes d’un histogramme Vous devez être particulièrement vigilant lors de la réalisation d’un histogramme aux classes de ce dernier. # Réalisation du graphique précédent a &lt;- chart(zooplankton, formula = ~ size) + geom_histogram(bins = 50) # modification du nombre de classes b &lt;- chart(zooplankton, formula = ~ size) + geom_histogram(bins = 20) c &lt;- chart(zooplankton, formula = ~ size) + geom_histogram(bins = 10) d &lt;- chart(zooplankton, formula = ~ size) + geom_histogram(bins = 5) # Assemblage des graphiques ggpubr::ggarrange(a,b,c,d,labels = &quot;AUTO&quot;, font.label = list(size = 14, align = &quot;hv&quot;)) Figure 3.4: Piège de l’histogramme. A. histogramme initiale montrant la répartition des tailles au sein d’organismes planctoniques. B., C., D. Histogramme A en modifiant le nombres de classes Comme vous pouvez le voir ci-dessus, le changement du nombre de classes peut modifier complètement la perception des données. 3.1.1.2 Utilisation des snippets RStudio permet de récupérer rapidement des instructions à partir d’une banque de solutions toutes prêtes. Cela s’appelle des snippets. Vous avez une série de snippets disponibles dans la SciViews Box. Cela qui vous permet de réaliser un histogramme s’appelle .cuhist. Entrez ce code et appuyez ensuite sur la tabulation dans un script R, et vous verrez le code remplacé par ceci : chart(data = DF, ~VARNUM) + geom_histogram(binwidth = 30) L’argument binwidth permet de préciser la largeur des classes. Vous avez à votre disposition un ensemble de snippet que vous pouvez retrouvez dans l’aide mémoire sur SciViews. Vous avez également à votre disposition l’aide-mémoire sur la visualisation des données (Data Visualization Cheat Sheet). 3.1.1.3 Histogramme par facteur Lors de l’analyse de jeux de données , vous serez amené à réaliser un histogramme par facteur. # Importation du jeu de données (iris &lt;- read(file = &quot;iris&quot;, package = &quot;datasets&quot;, lang = &quot;fr&quot;)) # # A tibble: 150 x 5 # sepal_length sepal_width petal_length petal_width species # &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; # 1 5.1 3.5 1.4 0.2 setosa # 2 4.9 3 1.4 0.2 setosa # 3 4.7 3.2 1.3 0.2 setosa # 4 4.6 3.1 1.5 0.2 setosa # 5 5 3.6 1.4 0.2 setosa # 6 5.4 3.9 1.7 0.4 setosa # 7 4.6 3.4 1.4 0.3 setosa # 8 5 3.4 1.5 0.2 setosa # 9 4.4 2.9 1.4 0.2 setosa # 10 4.9 3.1 1.5 0.1 setosa # # ... with 140 more rows # Réalisation de l&#39;histogramme par facteur chart(iris, ~ sepal_length %fill=% species) + geom_histogram() + scale_fill_viridis_d() # palette de couleur harmonieuse # `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Figure 2.2: Histogramme de la longueur des sépales de 3 espèces d’iris. La fonction chart() requiert comme argument le jeu de donnée (iris, c’est un objet dataframe ou tibble dans le langage de R), ainsi que la formule à employer dans laquelle vous avez indiqué le nom de la variable que vous voulez sur l’axe des abscisses à droite de la formule. Parmi toutes ces variables, nous avons choisi ici de représenter sepal_length, et d’employer la couleur de l’intérieur des classes (%fill=%) pour différencier les 3 espèces de ce jeu de données avec la species . Jusqu’ici, nous avons spécifié ce que nous voulons représenter, mais pas encore comment (sous quelle apparence), nous voulons les matérialiser sur le graphique. Pour un histogramme, nous devons ajouter la fonction geom_histogram() pour indiquer cela. La fonction scale_fill_viridis_d() permet d’obtenir des couleurs harmonieuses. Cette opération peut avoir un rendu graphique plutôt décevant dont voici deux astuces pour l’éviter. La premières astuces est d’employer préférentiellement les facets au lieu de l’argument %fill=%. chart(iris, ~ sepal_length | species) + geom_histogram() # `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Figure 2.3: Histogramme de la longueur des sépales de 3 espèces d’iris en employant les facets comme argument pour discriminer les espèces. L’histogramme est maintenant séparé en trois en fonction des niveaux de la variable facteur species. Cette procèdure simplifie grandement la visualisation de la distribution de la variable sepal_length. Simon Jackson propose une seconde solution combinant les facets et l’argument fill. Il faut ensuite ajouter par derriere un histogramme ne tenant pas compte de la variable facteur comme proposé ci-dessous. chart(iris, formula = ~ sepal_width %fill=% species | species) + geom_histogram(data = iris[ , -c(5)] , fill = &quot;grey&quot;) + # histogramme ne tenant pas compte de la variable species geom_histogram(show.legend = FALSE) + # show.legend = FALSE permet de cacher la légende, si cette denrière n&#39;est pas informative. scale_fill_viridis_d() # `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. # `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Figure 3.5: Histogramme de la longeur des sépales de 3 espèces d’iris en employant la solution de Simon Jackson. 3.1.2 A vous de jouer ! Une nouvelle tâche va vous être demandée ci-dessous en utilisant GitHub Classroom 1.2.4.3. Cette tâche est un travail en équipe. Une fois votre assignation réalisée, faite un clone de votre dépôt et placer le dans le dossier project. Cette nouvelle tâche qui vous est demandée vous propose d’employer un projet RStudio @ref(rs_projet) Un projet sur la croissance des dents de cochon d’Inde est mis à votre disposition. Sur base du jeux de données ToothGrowth, explorez différents graphiques. Utilisez l’URL suivant qui va vous donner accès à votre tâche. TODO↩ TODO↩ todo↩ TODO↩ "],
["graphique-de-densite.html", "3.2 Graphique de densité", " 3.2 Graphique de densité L’histogramme n’est pas le seul outil à votre disposition. Vous pouvez également employer le graphique de densité qui se base sur l’histogramme. Il ne s’agit plus de représenter un dénombrement comme l’histogramme le fait mais une probabilité8 d’obtenir une valeur parmi un échantillon aléatoire. Le passage d’un histogramme vers un graphe de densité se base sur une estimation par noyaux gaussien9 Figure 3.6: A. Histogramme et B. graphique de densité montrant la distribution de la taille d’un échantillon de zooplancton analysé par analyse d’image. Les éléments indispensables à la compréhension d’un graphique de densité sont (ici mis en évidence en couleur) : Les axes avec les graduations (en rouge) les labels et unité des axes (en bleu) Les instructions de base afin de produire un histogramme sont : # Importation du jeu de données (zooplankton &lt;- read( file = &quot;zooplankton&quot;, package = &quot;data.io&quot;, lang = &quot;fr&quot;)) # # A tibble: 1,262 x 20 # ecd area perimeter feret major minor mean mode min max std_dev # &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 0.770 0.465 4.45 1.32 1.16 0.509 0.363 0.036 0.004 0.908 0.231 # 2 0.700 0.385 2.32 0.728 0.713 0.688 0.361 0.492 0.024 0.676 0.183 # 3 0.815 0.521 4.15 1.33 1.11 0.598 0.308 0.032 0.008 0.696 0.204 # 4 0.785 0.484 4.44 1.78 1.56 0.394 0.332 0.036 0.004 0.728 0.218 # 5 0.361 0.103 1.71 0.739 0.694 0.188 0.153 0.016 0.008 0.452 0.110 # 6 0.832 0.544 5.27 1.66 1.36 0.511 0.371 0.02 0.004 0.844 0.268 # 7 1.23 1.20 15.7 3.92 1.37 1.11 0.217 0.012 0.004 0.784 0.214 # 8 0.620 0.302 3.98 1.19 1.04 0.370 0.316 0.012 0.004 0.756 0.246 # 9 1.19 1.12 15.3 3.85 1.34 1.06 0.176 0.012 0.004 0.728 0.172 # 10 1.04 0.856 7.60 1.89 1.66 0.656 0.404 0.044 0.004 0.88 0.264 # # ... with 1,252 more rows, and 9 more variables: range &lt;dbl&gt;, size &lt;dbl&gt;, # # aspect &lt;dbl&gt;, elongation &lt;dbl&gt;, compactness &lt;dbl&gt;, transparency &lt;dbl&gt;, # # circularity &lt;dbl&gt;, density &lt;dbl&gt;, class &lt;fct&gt; # Réalisation du graphique chart(zooplankton, formula = ~ size) + geom_density() Figure 3.7: Instructions pour obtenir un graphique de densité. La fonction chart() requiert comme argument le jeu de donnée ( dataframe, zp), ainsi que la formule à employer ~ VAR (size). Pour réaliser un graphique de densité vous devez ajouter la seconde fonction geom_density(). TODO↩ TODO↩ "],
["diagramme-en-violon.html", "3.3 Diagramme en violon", " 3.3 Diagramme en violon Le graphique de densité peut être représenté via un autre graphique qui sera d’autant plus intéressant que la variable facteur étudiée peut être discriminée par un grand nombre de niveaux différents. Il s’agit également d’une estimation se basant sur un histogramme via la méthode l’estimation par noyau gaussien. Figure 3.8: Ponts essentiels d’un diagramme en violon portant sur la distribution de la taille d’un échantillon de zooplancton en fonction de leurs classes analysé par analyse d’image. Les instructions de base afin de produire un diagramme en violon sont : # Importation du jeu de données zooplankton &lt;- read( file = &quot;zooplankton&quot;, package = &quot;data.io&quot;, lang = &quot;fr&quot;) # Réduction du jeu de données zooplankton_sub &lt;- filter(zooplankton, class %in% c(&quot;Annelid&quot;, &quot;Calanoid&quot;, &quot;Cyclopoid&quot;, &quot;Decapod&quot;)) # Réalisation du graphique chart(zooplankton_sub, formula = size~ class) + geom_violin() Figure 3.9: Instructions pour obtenir un diagramme en violon. La fonction chart() requiert comme argument le jeu de donnée (dataframe, zp), ainsi que la formule à employer YVAR (size) ~ XVAR (class). Pour réaliser un graphique de densité vous devez ajouter la seconde fonction geom_density(). 3.3.1 Pièges et astuces Lors de l’analyse de jeux de données , vous serez amené a réalisé un diagramme en violon pour une variable comprennant un grand nombre de niveaux. Cette opération peut avoir un rendu graphique plutôt décevant dont voici deux astuces pour l’éviter. chart(zooplankton, formula = size~ class) + geom_violin() Figure 3.10: Diagramme en violon montrant la densité de tailles des 17 classes d’organismes planctonique. L’ensemble des niveaux de la variable class se chevauche. La fonction coord_flip() peut améliorer le rendu du graphique en le faisant basculer de 90°. chart(zooplankton, formula = size~ class) + geom_violin() + coord_flip() Figure 3.11: Diagramme en violon montrant la densité de tailles des 17 classes d’organismes planctonique avec l’ajout de la fonction coord_flip. Le package ggridges propose une seconde solution basée sur le principe de graphique de densité avec la fonction geom_density_ridges()`. # Importation du packages library(ggridges) # réalisation du graphiques chart(zooplankton, class ~ size) + geom_density_ridges() Figure 3.12: Diagramme en violon montrant la densité de tailles des 17 classes d’organismes planctonique avec la fonction geom_density_ridges. "],
["a-vous-de-jouer-6.html", "3.4 A vous de jouer !", " 3.4 A vous de jouer ! Ouvrez RStudio dans votre SciViews Box, puis exécutez l’instruction suivante dans la fenêtre console : BioDataScience::run(&quot;...&quot;) Un squelette de projet RStudio vous a été fournit via une tâche Github Classroom, y compris une organisation des fichiers et des jeux de données types. Votre objectif est de comprendre les données proposées en utilisant des visualisations graphiques appropriées et en documentant le fruit de votre étude dans un rapport R Notebook. Utilisez l’histogramme et le graphique de densité que vous venez d’étudier bien sûr, mais vous êtes aussi encouragés à expérimenter d’autres visualisations graphiques. "]
]
