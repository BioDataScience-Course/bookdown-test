[
["index.html", "Science des données biologiques, UMONS Préambule", " Science des données biologiques, UMONS Philippe Grosjean &amp; Guyliann Engels 2018-10-11 Préambule Cet ouvrage couvrira, à terme, la matière des cinq cours de science des données enseignés aux biologistes de la Faculté des Sciences de l’Université de Mons (Belgique). La matière sera complétée progressivement à partir du premier cours prévu pour l’année académique 2018-2019. Cet ouvrage est conçu pour être utilisé de manière interactive en ligne. En effet, nous prévoyons d’y adjoindre des capsules (unités d’enseignement ciblant un et un seul concept) sous forme de vidéos, des démonstrations interactives, et des exercices sous forme de questionnaires interactifs également. Ces différents éléments ne sont, bien évidemment, utilisables qu’en ligne. "],
["vue-generale-du-cours.html", "Vue générale du cours", " Vue générale du cours Le premier cours intitulé Science des données I: visualisation et inférence qui est dispensé aux biologistes de second Bachelier en Faculté des Sciences de l’Université de Mons à partir de l’année académique 2018-2019 contient 25h de cours et 50h d’exercices en presentiel. Il nécessitera environ un tiers de ce temps (voir plus, en fonction de votre rythme et de votre technique d’apprentissage) en travail à domicile. Cette matière est divisée en 12 modules de sessions de 6h chacune en présentiel. Une première séance de 2h précèdera ces 12 modules afin d’installer les logiciels (SciViews Box, R, RStudio, Github Desktop), et de se familiariser avec eux. "],
["materiel-pedagogique.html", "Matériel pédagogique", " Matériel pédagogique Le matériel pédagogique, rassemblé dans ce syllabus interactif est aussi varié que possible. Vous pourrez ainsi piocher dans l’offre en fonction de vos envies et de votre profil d’apprenant pour optimiser votre travail. Vous trouverez: le présent ouvrage en ligne, des capsules, essentiellement sous forme de vidéos &lt; 10 min qui ciblent chacune un concept particulier (en cours de développement), des tutoriaux interactifs (réalisés avec un logiciel appelé learnr). Vous pourrez exécuter ces tutoriaux directement sur votre ordinateur, et vous aurez alors accès à des pages Web réactives contenant des explications, des exercices et des quizzs en ligne, des slides de présentations, des dépôts Github Classroom dans la section BioDataScience-Course (vous apprendrez ce que c’est très rapidement dès le premier module) pour réaliser et documenter vos travaux personnels. des renvois vers des documents externes en ligne, types vidéos youtube ou vimeo, des ouvrages en ligne en anglais ou en français, des blogs, des tutoriaux, des parties gratuites de cours Datacamp ou équivalents, des questions sur des sites comme “Stackoverflow” ou issues des “mailing lists” R, … Tout ce matériel est accessible à partir du site Web du cours, du présent syllabus interactif (et de Moodle pour les étudiants de l’UMONS). Ces derniers ont aussi accès au dossier SDD sur StudentTemp en Intranet à l’UMONS. Les aspects pratiques seront à réaliser en utilisant la ‘SciViews Box’, une machine virtuelle préconfigurée que nous installerons ensemble lors du premier cours1. Il vous faudra donc avoir accès à un ordinateur (sous Windows, MacOS, ou Linux peu importe, suffisamment puissant et connecté à Internet ou à l’Intranet UMONS). Enfin, vous pourrez poser vos questions par mail à l’adresse sdd@sciviews.org. Il existe tout de même des outils plus pointus pour obtenir de l’aide sur le logiciel R comme rseek.org, rdocumentation.org ou rdrr.io. Rien ne sert de chercher ’R’ dans Goggle.↩ "],
["comment-apprendre.html", "Comment apprendre?", " Comment apprendre? fortunes::fortune(&quot;brain surgery&quot;) # # I wish to perform brain surgery this afternoon at 4pm and don&#39;t know where # to start. My background is the history of great statistician sports # legends but I am willing to learn. I know there are courses and numerous # books on brain surgery but I don&#39;t have the time for those. Please direct # me to the appropriate HowTos, and be on standby for solving any problem I # may encounter while in the operating room. Some of you might ask for # specifics of the case, but that would require my following the posting # guide and spending even more time than I am already taking to write this # note. # -- I. Ben Fooled (aka Frank Harrell) # R-help (April 1, 2005) Version courte: en pratiquant, en faisant des erreurs ! Version longue: aujourd’hui –et encore plus à l’avenir– les données sont complexes et ne se manipulent plus simplement avec un tableur comme Microsoft Excel. Vous allez apprendre à maitriser des outils professionnels, ce qui sous-entend qu’ils sont très puissants mais aussi relativement complexes. La méthode d’apprentissage que nous vous proposons a pour objectif prioritaire de vous faciliter la tâche, quelles que soient vos aptitudes au départ. Envisagez votre voyage en science des données comme l’apprentissage d’une nouvelle langue. C’est en pratiquant, et en pratiquant encore sur le long terme que vous allez progresser. La formation s’étale sur quatre années, et est répartie en cinq cours de difficulté croissante pour vous aider dans cet apprentissage progressif et sur la durée. N’hésitez pas à expérimenter, tester, essayer des nouvelles idées (même au delà de ce qui sera demandé dans les exercices) et n’ayez pas peur de faire des erreurs. Vous en ferez, … beaucoup … nous vous le souhaitons! En fait, la meilleure manière d’apprendre, c’est justement en faisant des erreurs, et puis en mettant tout en oeuvre pour les comprendre et les corriger. Donc, si un message d’erreur, ou un “warning” apparait, ne soyez pas intimidé. Prenez une bonne respiration, lisez-le attentivement, essayez de le comprendre, et au besoin faites-vous aider: la solution est sur le Net, ‘Google1 est votre ami’! Il existe tout de même des outils plus pointus pour obtenir de l’aide sur le logiciel R comme rseek.org, rdocumentation.org ou rdrr.io. Rien ne sert de chercher ’R’ dans Goggle.↩ "],
["evaluation.html", "Evaluation", " Evaluation L’évaluation sera basée sur une somme de petites contributions qui matérialiseront votre progression sur le long terme. Avec cette évaluation, nous souhaitons vous gratifier chaque fois que vous franchirez des étapes, plutôt que de vous sanctionner lorsque vous bloquez. Donc, pour une note finale sur 20: 3 points pour la restitution des capsules et votre participation en présentiel. Au début de chaque séance, nous discuterons des notions que vous aurez à préparer par avance, et votre participation sera évaluée. 6 points pour un quizz final. 11 points pour l’évaluation d’un des rapports d’analyse de données (choisi au hasard en fin de cours). Enfin, vous pourrez éventuellement encore gagner un point bonus pour une participation remarquable, ou tout autre élément à valoriser (site web personnel et/ou blog exceptionnel, aide des autres étudiants, etc.). Ceci étant à l’appréciation des enseignants. Le matériel dans cet ouvrage est distribué sous licence CC BY-NC-SA 4.0. "],
["intro.html", "Module 1 Introduction", " Module 1 Introduction Objectifs : Appréhender ce qu’est la science des données et les (bio)statistiques. S’initier à des outils de base (SciViews Box, RStudio, Markdown, git, Github). Se sensibiliser à l’importance d’une présence web au niveau professionnel. "],
["donnees.html", "1.1 Comment le monde était-il y a 25 ans ?", " 1.1 Comment le monde était-il y a 25 ans ? Il y a 25 ans, pas d’internet, pas de smartphone. Essayez d’imaginer ce que serait votre vie aujourd’hui si ces outils qui font partie de votre quatidien n’existaient pas. Les révolutions indistrielles: 1770 (1756) révolution 1: mécanisation 1870 révolution 2: maîtrise de l’énergie 1970 (1979) révolution 3: informatique 1990 révolution 4: internet (1990 Web, 1992 ISOC = Internet society, 1993 = premier navigateur web) 2000 révolution 5: numérique. GAFA = Google - Apple - Facebook - Amazon + Microsoft = GAFAM aux USA et BATX en Chine = Baidu - Alibaba - Tencent - Xiaomi. Aussi NATU = Netflix - Airbnb - Tesla - Uber. 2010 révolution 6: NBIC = nanotechnologies - biotechnologies - informatique - sciences cognitives. 2020 = date prévue pour que l’ordinateur ait la même puissance de traitement de l’information que le cerveau humain 2030 = transhumanisme: ordinateur plus puissant que l’homme et le remplacera probablement dans de nombreuses tâches. Valeur estimée des données et informations mises à disposition par les utilisateurs du net: 1000 milliards de dollar par an (écrivez ce nombre en chiffres pour vous donner une meilleure idée de ce que cela représente)! En 2020, quantité d’information ajoutée sur le net: 1000 milliards de milliards par semaine (écrivez ce nombre en chiffres également). Comparaison de puissance de traitement du cerveau humain versus un ordinateur: 89 milliards de neurones, mais travail en multitâche alors qu’un processeur est monotâche =&gt; difficile à comparer. Une étude a montré en 2017 que l’un des 5 ordinateurs les plus puissants a été capable de simuler le fonctionnement d’environ 1% du cerveau humain en 1 sec. Il lui a fallu 40 min de calcul pour y arriver. Intel estime que l’évolution permettra d’égaler le cerveau humain en terme de vitesse de traitement vers 2020. Consommation électrique du supercalculateur: se mesure en mégawatts, alors que le cerveau humain consomme 12-13W seulement! “Le transhumanisme est une approche interdisciplinaire qui nous amène à comprendre et à évaluer les avenues qui nous permettrons de surmonter nos limites biologiques par les progrès technologiques. Les transhumanistes cherchent à développer les possibilités techniques afin que les gens vivent plus longtemps et …” Vous pouvez maintenant avoir un aperçu de l’importance d’avoir des outils performants afin d’appréhender les données dont le nombre croit de manière exponentielle. Pour ce cours de sciences des données, plusieurs outils puissants sont mis à votre disposition (Vous trouverez sur l’hyperlien suivant, un poster présentant la philosophie du cours https://github.com/BioDataScience-Course/RencontresRRennes2018) "],
["decouverte-des-outils.html", "1.2 Découverte des outils", " 1.2 Découverte des outils La science des données est complexe et requiert d’employer des outils performants. Nous avons sélectionné ces outils pour vous. 1.2.1 Machine virtuelle La SciViews Box est une machine virtuelle (un ordinateur complet, mais totalement indépendant du matériel -le hardware- et qui peut être déployé sur pratiquement n’importe quel ordinateur physique). Cette SciViews Box est complètement configurée et dédiée à la sciences des données biologiques. Elle contient tout ce qu’il faut pour importer et analyser vos données, et ensuite écrire des rapports ou d’autres documents prêts à publication ou à présentation. Elle vous servira également à collaborer avec d’autres chercheurs qui peuvent facilement utiliser exactement la même machine virtuelle (aspect reproductible de vos analyses). Des explications détaillées se trouvent dans l’annexe A dédiée à l’installation et la configuration de la SciViews Box. Figure 1.1: Logo de la SciViews Box Une fois loggé dans la machine virtuelle, réalisez l’activité : Découverte de la machine virtuelle https://github.com/BioDataScience-Course/sdd_lesson/blob/master/sdd1_01/presentations/sdd1_01_svbox.pdf Après avoir réalisé l’activité, un document récapitulatif est mis à votre disposition : https://github.com/BioDataScience-Course/sdd_lesson/blob/master/sdd1_01/exercises/sdd1_01_svbox.Rmd Des explications détaillées se trouvent dans l’annexe @ref(svbox_use) dédiée à l’utilisation de la SciViews Box. 1.2.2 RStudio RStudio est l’outil au sein de la SciViews Box que vous allez utiliser le plus fréquemment durant ce cours. Il fournit un environnement complet et optimisé pour réaliser vos analyses, vos graphiques et vos rapports. RStudio travaille main dans la main avec le logiciel R qui effectue l’ensemble des traitements. Rstudio est divisé en 4 zones importantes (A-D) avec une barre d’outils général au dessus : A : Une zone d’édition B : Plusieurs onglets sont présents comme Environement, History ou encore Connections. Par exemple, les différents items (on parle d’objets) chargés en mémoire dans R se trouveront dans l’environnement (mais pour l’instant, il n’y a encore rien). C : La Console étant le zone d’instruction où vous pouvez entrer des instructions dans R pour manipuler vos données D : Plusieurs onglets sont présents comme Files, Help ou encore Viewer. Des explications détaillées se trouvent dans l’annexe B.1 dédiée à l’utilisation de R Studio. Vous avez à votre disposition un aide-mémoire afin d’appréhender cette interface RStudio IDE Cheat Sheet. 1.2.2.1 Pour en savoir plus … RStudio. Site de Rstudio comprennant un ensemble de ressource en anglais afin d’appréhender RStudio. RStudio, un environnement de développement pour R. Site proposant une brève explication de RStudio en français. RStudio : sa vie, son oeuvre, ses ressources. Site proposant une explication de RStudio en français. 1.2.3 Markdown Afin de réaliser vos analyses dans RStudio, nous employons le language Markdown dans la zone d’édition. Ce language a été mis au point afin de séparer la mise en forme et le fond. Ce language a la volontée de revenir au fondamental de l’écriture, le fond. Son avantage principal réside dans sa simplicité d’apprentissage. Quels sont les commandes et instructions indispensables lorsque l’on rédige un rapport ? Des titres et sous-titres, mise en évidence (mise en italiques ou mise en gras), des listes,… Il ne faut au final que très peu de commandes que pour réaliser un rapport de qualité avec une mise en page minimaliste et épurée. Vous avez à votre disposition deux aide-mémoires afin d’appréhender ce language avec l’aide mémoire R Markdown Cheat Sheet qui comprend une section relative au language markdown et la première page de l’aide mémoire R Markdown Reference Guide Après avoir rédiger votre document, vous devez cliquer sur Preview. Une fois loggé dans la machine virtuelle, réalisez l’activité : Découverte de rstudio et rmarkdown https://github.com/BioDataScience-Course/sdd_lesson/blob/master/sdd1_01/presentations/sdd1_01_markdown.pdf Après avoir réalisé l’activité, un document récapitulatif est mis à votre disposition : https://github.com/BioDataScience-Course/sdd_lesson/blob/master/sdd1_01/exercises/sdd1_01_markdown.Rmd 1.2.3.1 Pour en savoir plus… Markdown. Explication en anglais de l’intérêt d’employer markdown ainsi que la syntax à employer. Rédigez en Markdown ! Un guide pour bien commencer avec markdown. Explication détaillée en français sur le language markdown Le Markdown comme langage d’écriture universel ? Comment écrire confortablement et professionnellement ? Le markdown !. Utilisation de Markdown afin de revenir à l’essence de la rédaction. Écrire tout simplement – Introduction à Markdown. Explication en français des raisons de l’utilisation de markdown. 1.2.4 Gestionnaire de version Lors de la rédaction de travaux comme par exemple lors de l’écriture d’un travail de fin d’étude ou d’un rapport assez important. On se retrouve rapidement avec plusieurs fichiers correspondant à des états d’avancements de ce dernier : TFE_final TFE_final1 TFE_final2 TFE_final3 TFE_final… TFE_final99 Lors de différents essais, on va avoir tendance à tout garder dans différents fichiers afin de ne rien supprimer d’important. Cette pratique bien que très courante comporte le gros désavantage de prendre énormément de place sur le disque de votre ordinateur et de n’être pas pratique. Les questions suivantes peuvent se poser : Que se cache t’il dans la version TFE_final 2 ? Après 1 mois sans travailler sur ce projet, seriez vous capable de specifier la différence entre le fichier TFE_final 2 et le TFE_final3 ? Et cela peut encore se compliquer lorsque plusieurs personnes collaborent sur un même projet. Ils vont devoir s’envoyer par mail tous les fichiers, avec chacun y apportant ses idées. TFE_final TFE_final1 TFE_final1_jacques TFE_final1_pierre TFE_final2 TFE_final2_jules TFE_final… TFE_final99 Dans quel fichier se trouve la dernière version de chaque personne ayant collaboré sur le projet ? Une petit peu dans chaque fichier. Différentes avancées ont été réalisées pour améliorer le travail collaboratif comme : L’utilisation de partage de fichiers en ligne ( Dropbox, Google Drive, One Drive) Il en est fini le temps où l’on s’envoyait un dossier comprenend chacune des avancées par mails. Cette option ne règle toujours pas le problème de collaboration sur le même fichier. L’utilisation de programme d’édition collaboratif et en temps réel ( etherpad, Google Drive - Docs, Gobby ). Il est possible de travailler en même temps sur un même fichier d’édition. Cette option ne règle pas le problème du retour en arrière. Lorsqu’une modification a été réalisée l’ancienne version est tout simplement écrasée. Il est donc impossible de revenir dessus. La meilleur combinaison pour gérer ses versions et collaborer : Git et Git Hub Ces outils ont l’étiquette d’être des outils fait par et pour des geeks. Cependant, ils permettent de gérer et collaborer de manière efficace sur un même projet contenant du code ou non. 1.2.4.1 Git La gestion de versions est gérée par Git. Cet outil va remplacer les nombreuses copies d’un même fichier par une sorte d’arbre que l’on peut représenter schématiquement comme ci-dessous : Représentation de la gestion de fichiers via Git Comme vous pouvez le voir ci-dessus, on peut suivre la progression de notre projet via les boules bleues. Chaque boule représente l’état de notre projet lorsque l’on a décidé de l’enregistrer. Pour envoyer une nouvelle version de votre projet, vous réalisez un commit qui sera accompagné d’un message qui spécifie les modifications apportées. Il est possible de revenir en arrière avec un checkout. Git comprend de nombreux outils très intéressant pour la gestion de versions que vous utiliserez par la suite. 1.2.4.2 Git Hub Afin de sauvegarder vos projets en ligne, de les partager et de collaborer avec d’autres personnes, un réseau social a été conçu pour héberger vos projets qui se nomme Git Hub (tout comme Facebook ou LinkedIn). On retrouve deux mots dans Git Hub. Il y a tout d’abord Git qui exprime la gestion de version et ensuite hub qui exprime le reseau. Il s’agit donc d’un réseau social qui permet de collaborer sur des projets. Lorsque l’on travaille seul tout en utilisant le reseau social l’évolution de notre projet va ressembler à l’arbre ci-dessous: Représentation l’arbre de Git Hub On réalise un envoi push lorsque l’on souhaite envoyer sur le réseau social l’état dans lequel le projet se trouve. De ce fait plusieurs Comit peuvent être envoyé avec un seul push sur le réseau. L’avantage de Git Hub ne réside pas vraiment dans la posibilité de réaliser une sauvegarde en ligne mais réside dans la possibilité de collaborer avec d’autres personnes présent sur ce réseau comme l’illustre la figure ci-dessous. Deux scientifiques (les boules bleues et les boules vertes) collaborent sur un même projet que l’on appele dépot ( repository en anglais ) lorsqu’il est en ligne. Le premier chercheur (boule bleue) va initier le dépot et réaliser un push pour le placer sur le réseau. Son collaborateur (boule verte) va cloner (clone en anglais) le dépot sur son ordinateur afin d’y travailler également en local. Après avoir fait progresser le travail, il réalise également un push sur le réseau. Le premier scientifique avant de travailler à nouveau sur le projet va réaliser un pull afin d’obtenir en local l’ensemble des modifications fournie par ses collaborateurs. Représentation l’arbre de Git Hub Vous venez d’apprendre différents mots technique indispensable pour une bonne compréhension de git et github repository commit clone push pull Ceci n’est qu’une rapide explication de ces deux programmes, retrouve une explication détaillée à l’annexe… 1.2.4.2.1 Pour en savoir plus Gérez vos codes source avec Git. Explication en français sur l’utilisation de Git. Quel logiciel de gestion de versions devriez-vous utiliser ?. Explication en français sur l’utilisation des logiels de gestion de versions. Git: comprendre la gestion de versions. Explication en français sur l’utilisation de Git. Git. Site en anglais comprendant toute la document de Git. http://www.lsv.fr/~hirschi/pdfs/git.pdf https://www.christopheducamp.com/2013/12/15/github-pour-nuls-partie-1/ 1.2.4.3 Git Hub Classroom Git Hub Classroom est une extension de Git Hub qui s’emploie pour les utilisateurs comme Git Hub. Vous serez amené à cloner des dépots, modifier des dépots pour réaliser des commit,… Le tout va être suivi pour des administrateurs. Différents exercices vous seront proposés via ce programme. Par exemple, le projet initial pour réaliser votre site web se trouve sur ce programme. "],
["site.html", "1.3 Site web professionnel", " 1.3 Site web professionnel De nos jours, un nombre important de données sont collectées sur nous. A la fin de vos études, vous serez amenés à rechercher un travail (dans le milieu de la recherche universitaire, dans la recherche en entreprise, dans les métiers de l’éco-conseils, etc.). Cependant, tous les recruteurs utilisent actuellement les données que l’on a semé sur le net afin de réaliser un profil détaillé sur nous. Il est donc de votre intérêt d’avoir le meilleur profil possible sur Internet. Nous allons vous y aider ! Les réseaux sociaux sont une mine d’or sur nos habitudes de vie comme Facebook, Twitter ou encore Instagram. On peut parler de l’image numérique d’une personne. Afin de mettre l’accent sur les compétences professionnels, de plus en plus de personnes utilisent des réseaux plus profesionnels comme LinkedIn ou encore des sites webs personnels professionels (par exemple : http://phgrosjean.sciviews.org/, http://www.guyliann.be/). Dans le cadre de ce premier module, vous allez réaliser votre premier site professionnel (contenant également une section “blog” que vous pourrez alimenter, entre autres, avec vos considérations concernant vos cours, les analyse de données, et autres). Ce site sera immédiatement disponible sur le web et ce, de manière entièrement gratuite! Afin de mener à bien ce premier projet, divers outils vous seront nécessaires. Ces outils seront complétés plus trd par d’autres pour que vous ayez une boite à outils complète pour vos futures analyses de données professionnelles. 1.3.1 A vous de jouer Maintenant que vous avez appréhendé les différents outils, lancez vous dans la création de votre site web professionnel via l’addresse suivante : https://github.com/BioDataScience-Course/blogdown.source "],
["visu1.html", "Module 2 Visualisation I", " Module 2 Visualisation I Objectifs Découvrir –et vous émerveiller de– ce que l’on peut faire avec le logiciel R (R Core Team 2018) Savoir réaliser différentes variantes d’un graphique en nuage de points dans R avec la fonction chart() Découvrir le format R Markdown (Allaire et al. 2018) et la recherche reproductible Intégrer ensuite des graphiques dans un rapport et y décrire ce que que vous observez Comparer de manière critique un workflow ‘classique’ en biologie utilisant Microsoft Excel et Word avec une approche utilisant R et R Markdown; prendre conscience de l’énorme potentiel de R Prérequis Si ce n’est déjà fait, vous devez installer et vous familiariser avec la ‘SciViews Box’, RStudio et Markdown . Vous devez aussi maitriser les bases de git et de Github (avoir un compte Github, savoir clôner un dépôt localement, travailler avec Github Desktop pour faire ses commits, push et pull). L’ensemble de ces outils a été abordé lors de la création de votre site professionnel et personnel du module 1. Avant de poursuivre, vous allez devoir découvrir les premiers rudiments de R afin de pouvoir réaliser par la suite vos premiers graphiques. Pour cela, vous aurez à lire attentivement et effectuer tous les exercices de deux tutoriels2. Démarrez la SciViews Box et RStudio. Dans la fenêtre Console de RStudio, entrez l’instruction suivante suivie de la touche Entrée pour ouvrir le tutoriel concernant les bases de R : BioDataScience::run(&quot;02a_base&quot;) Ensuite, vous pouvez également parcourir le tutoriel qui vous permettra de découvrir R (cliquez dans la fenêtre Console de RStudio et appuyez sur la touche ESC pour reprendre la main dans R à la fin d’un tutoriel) : BioDataScience::run(&quot;02b_decouverte&quot;) (BioDataScience est un package R spécialement développé pour ce cours et que vous avez dû installer lors de la configuration de votre SciViews Box, voir Appendice A.3.3). Références "],
["nuage-de-points.html", "2.1 Nuage de points", " 2.1 Nuage de points Dès que vous vous sentez familiarisé avec les principes de base de R, vous allez pouvoir réaliser assez rapidement des beaux graphiques. Par exemple, si vous souhaitez représenter une variable numérique en fonction d’une autre variable numérique, vous pouvez exprimer cela sous la forme d’une formule3 \\[y \\sim x\\] que l’on peut lire “y en fonction de x”. Pour les deux variables numériques x et y, la représentation graphique la plus classique est le nuage de points (voir Fig. 2.1 pour un exemple). Figure 2.1: Exemple de graphique en nuage de points. Des éléments essentiels sont ici mis en évidence en couleurs. Les éléments indispensables à la compréhension d’un nuage de points sont mis en évidence à la Fig. 2.1 : Les axes avec les graduations (en rouge), les labels et les unités des axes (en bleu). Les instructions dans R pour produire un tel nuage de point sont : # Chargement de SciViews::R SciViews::R # Importation du jeu de données (urchin &lt;- read(&quot;urchin_bio&quot;, package = &quot;data.io&quot;, lang = &quot;fr&quot;)) # # A tibble: 421 x 19 # origin diameter1 diameter2 height buoyant_weight weight solid_parts # &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 Fishe… 9.9 10.2 5 NA 0.522 0.478 # 2 Fishe… 10.5 10.6 5.7 NA 0.642 0.589 # 3 Fishe… 10.8 10.8 5.2 NA 0.734 0.677 # 4 Fishe… 9.6 9.3 4.6 NA 0.370 0.344 # 5 Fishe… 10.4 10.7 4.8 NA 0.610 0.559 # 6 Fishe… 10.5 11.1 5 NA 0.610 0.551 # 7 Fishe… 11 11 5.2 NA 0.672 0.605 # 8 Fishe… 11.1 11.2 5.7 NA 0.703 0.628 # 9 Fishe… 9.4 9.2 4.6 NA 0.413 0.375 # 10 Fishe… 10.1 9.5 4.7 NA 0.449 0.398 # # ... with 411 more rows, and 12 more variables: integuments &lt;dbl&gt;, # # dry_integuments &lt;dbl&gt;, digestive_tract &lt;dbl&gt;, # # dry_digestive_tract &lt;dbl&gt;, gonads &lt;dbl&gt;, dry_gonads &lt;dbl&gt;, # # skeleton &lt;dbl&gt;, lantern &lt;dbl&gt;, test &lt;dbl&gt;, spines &lt;dbl&gt;, # # maturity &lt;int&gt;, sex &lt;fct&gt; # Réalisation du graphique chart(urchin, height ~ weight) + geom_point() La fonction chart() requiert comme argument le jeu de donnée (urchin, c’est un objet dataframe ou tibble dans le langage de R), ainsi que la formule à employer dans laquelle vous avez indiqué le nom des variables que vous voulez sur l’axe des ordonnées à gauche et des abscisses à droite de la formule. Vous voyez que le jeu de données contient beaucoup de variables (les titres des colonnes du tableau en sortie). Parmi toutes ces variables, nous avons choisi ici de représenter height en fonction de weight, la hauteur en fonction de la masse des oursins. Jusqu’ici, nous avons spécifié ce que nous voulons représenter, mais pas encore comment (sous quelle apparence), nous voulons les matérialiser sur le graphique. Pour un nuage de points, nous voulons les représenter sous forme de … points ! Donc, nous devons ajouter la fonction geom_point() pour indiquer cela. 2.1.1 Le nuage de points en vidéo Vous trouverez une vidéo ci-dessous vous expliquant la création du nuage de points dans R sur ce jeu de données mais analysant d’autres variables. Cette vidéo ne vous a montré que les principaux outils disponibles lors de la réalisation de graphiques. Soyez curieux et expérimentez par vous-même ! 2.1.2 A vous de jouer ! Dans la fenêtre Console de RStudio, entrez l’instruction suivante suivie de la touche Entrée pour ouvrir le tutoriel concernant le nuage de points : BioDataScience::run(&quot;02c_nuage_de_points&quot;) N’oubliez pas d’appuyer sur la touche ESC pour reprendre la main dans R à la fin d’un tutoriel) 2.1.3 Pièges et Astuces 2.1.3.1 Modifications des échelles d’un graphiques Vous devez être vigilant lors de la réalisation d’un nuage de point particulièrement sur l’étendue des valeurs présentées sur vos axes. Vous devez utilisez votre expertise de biologistes pour vous posez les deux questions suivantes : Est ce que l’axe représente des valeurs plausibles de hauteurs et de masses de ces oursins apparetenant à l’espèce Paracentrotus lividus ? Quels est la précision des mesures effectuées ? Dans certains cas, la forme du nuage de points peut être distendu par la présence de valeurs aberrantes. Ce n’est pas le cas ici, mais nous pouvons le simuler en distandant artificiellement soit l’axe X, soit l’axe Y, soit les deux : A &lt;- chart(urchin, height ~ weight) + geom_point() + theme(text = element_text(size = 10)) # Réduction des labels # Modification des échelles B &lt;- A + scale_x_continuous(limits = c(0, 500)) C &lt;- A + scale_x_continuous(limits = c(-100, 120)) D &lt;- A + scale_x_continuous(limits = c(-400, 400)) + scale_y_continuous(limits = c(-400, 400)) # Assemblage des graphiques combine_charts(list(A, B, C, D), font.label = list(size = 14, align = &quot;hv&quot;)) Figure 2.2: Piège du nuage de points. A) graphique initialemontrant la variation de la hauteur [mm] en fonction de la masse [g] B) graphique A avec la modification de l’échelle de l’axe X. C) Graphique A avec une seconde modification de l’axe X. D) Graphique A avec modification de l’échelle de l’axe X et de l’axe Y. 2.1.3.2 Transformation des données Vous avez la possibilité d’appliquer une transformation de vos données (il est même conseillé de le faire) afin qu’elles soient plus facilement analysables. Par exemple, il est possible d’utiliser des fonctions de puissance, racines, logarithmes, exponentielles4 pour modifier l’apparence du nuage de points dans le but de le rendre plus linéaire (car il est plus facile d’analyser statistiquement des données qui s’alignent le long d’une droite). # Réalisation du graphique de la hauteur en fonction de la masse A &lt;- chart(urchin, height ~ weight) + geom_point() # Application du logarithme sur les deux variables représentées B &lt;- chart(urchin, log(height) ~ log(weight)) + geom_point() # Assemblage des graphiques combine_charts(list(A, B), font.label = list(size = 14, align = &quot;hv&quot;)) Figure 2.3: A) Variation de la hauteur [mm] en fonction de la masse [g] d’oursins violets. B) Variation du logarithme népérien de la hauteur [mm] en fonction du logarithme népérien de la masse [g] de ces mêmes oursins 2.1.3.3 Utilisation des snippets RStudio permet de récupérer rapidement des instructions à partir d’une banque de solutions toutes prêtes. Cela s’appelle des snippets. Vous avez une série de snippets disponibles dans la SciViews Box. Celui qui vous permet de réaliser un graphique en nuage de points s’appelle .cbxy (pour chart -&gt; bivariate -&gt; *xy**-plot). Entrez ce code et appuyez ensuite sur la tabulation dans un script R, et vous verrez le code remplacé par ceci : chart(data = DF, YNUM ~ XNUM) + geom_point() Vous avez à votre disposition un ensemble de snippets que vous pouvez retrouver dans l’aide-mémoire sur SciViews. Vous avez également à votre disposition l’aide-mémoire sur la visualisation des données (Data Visualization Cheat Sheet). 2.1.4 A vous de jouer ! Une nouvelle tâche va vous être demandée ci-dessous en utilisant GitHub Classroom 1.2.4.3. Cette tâche est un travail individuel. Une fois votre assignation réalisée, faites un clone de votre dépôt et placez-le dans le dossier projects. Vous aurez alors un nouveau projet RStudio @ref(rs_projet) Les instructions que vous employez dans un learnR peuvent être employées également dans un script d’analyse. Sur base du jeu de données urchin_bio, explorez différents graphiques en nuages de points. Utilisez l’URL suivante pour accéder à votre tâche. https://classroom.github.com/a/eYrXLy_u Inspirez-vous du script dans le dépôt sdd1_iris. Vous devez commencer par faire un “fork” du dépôt, puis un clone sur votre ordinateur en local pour pouvoir l’utiliser. https://github.com/BioDataScience-Course/sdd1_iris Prêtez une attention toute particulière à l’organisation d’un script R. En plus des instructions R, il contient aussi sous forme de commentaires, un titre , la date de la dernière mise à jour, le nom de l’auteur, et des sections qui organisent de façon claire le contenu du script. A ce sujet, vous trouverez des explications détaillées se trouvent dans l’annexe B.1.2 dédiée aux scripts R. 2.1.5 Pour en savoir plus… Visualisation des données dans R for Data Science. Chapitre du livre portant sur la visualisation des données ggplot2 nuage de point. Tutoriel en français portant sur l’utilisation d’un nuage de points avec le package ggplot2 et la fonction geom_point(). Fundamentals of Data Visualization. Un livre sur les fondamentaux de la visualisation graphique. R Graphics Cookbook - Chapter 5: Scatter Plots. Un chapitre d’un livre en anglais sur l’utilisation du nuage de points. geom_point(). La fiche technique de la fonction. 2.1.6 A vous de jouer ! Dans la fenêtre Console de RStudio, entrez l’instruction suivante et puis appuyez sur la touche Entrée pour ouvrir le tutoriel concernant le nuage de points : BioDataScience::run(&quot;02d_np_challenge&quot;) N’oubliez pas d’appuyer sur la touche ESC pour reprendre la main dans R à la fin d’un tutoriel) Dans R, une formule permet de spécifier les variables avec lesquelles on souhaite travailler, et leur rôle. Par exemple ici, la variable x sur l’axe des abscisses et la variable y sur l’axe des ordonnées.↩ Pour les proportions (p) ou les pourcentages (%) (valeurs bornées entre 0 et 1 ou 0 et 100%, la transformation arcsin est souvent utilisée : \\(p′ = \\arcsin \\sqrt{p}\\).↩ "],
["integration-des-graphiques-dans-un-rapport-r-markdown.html", "2.2 Intégration des graphiques dans un rapport: R Markdown", " 2.2 Intégration des graphiques dans un rapport: R Markdown Un fichier R Markdown est un fichier avec une extension .Rmd. Il permet de combiner le langage Markdown que vous avez déjà abordé au premier module avec du code R, tel que celui utilisé dans la première partie de ce module 2. Des explications détaillées se trouvent dans l’annexe B.1.3 dédiée au R Markdown. De plus, l’écriture d’un rapport d’analyse scientifique doit respecter certaines conventions que vous pouvez retrouvez dans l’annexe @ref(redaction_scientifique). 2.2.1 Pour en savoir plus… What is R Markdown?. Vidéo en anglais + site présentant les différentes possibilités, par les concepteurs de R Markdown (RStudio). Introduction to R Markdown. Tutoriel en anglais, par RStudio, les concepteurs de R Markdown, Aide-mémoire R Markdown: dans les menus de RStudio : Help -&gt; Cheatsheets -&gt; R Markdown Cheat Sheet Référence rapide à Markdown : dans les menus RStudio Help -&gt; Markdown Quick Reference Introduction à R Markdown. Présentation en français par Agrocampus Ouest - Rennes. Le langage R Markdown. Introduction en français concise, mais relativement complète. https://rworkshop.uni.lu/lectures/lecture04_rmarkdown.html#12 2.2.2 A vous de jouer ! Utilisation de R Notebook, une forme flexible de R Markdown. Employez le projet sdd1_urchin_bio que vous avez obtenu via le lien GitHub Classroom dans la première partie de ce module. Votre objectif est de comprendre les données proposées, en utilisant des visualisations graphiques appropriées et en documentant le fruit de votre étude dans un rapport R Notebook. Utilisez le graphique en nuage de points que vous venez d’étudier bien sûr, mais vous êtes aussi encouragés à expérimenter d’autres formes de visualisations graphiques. Workflow “classique” en biologie (Microsoft Excel et Word) comparé à R et R Markdown Une nouvelle tâche va vous être demandée ci-dessous en utilisant GitHub Classroom 1.2.4.3. Cette tâche est un travail en équipe. Une fois votre assignation réalisée, faites un clone de votre dépôt et placez-le dans le dossier projects. Comparez le workflow classique en biologie via Microsoft Office avec l’utilisation de R - R Markdown en suivant les explications suivantes : L’URL suivant qui va vous donner accès à votre tâche. https://classroom.github.com/g/2Cii2dws "],
["visu2.html", "Module 3 Visualisation II", " Module 3 Visualisation II Objectifs Savoir réaliser différentes variantes de graphiques tel que les histogrammes, les graphes de densité ou encore les diagrammes en violon dans R avec la fonction chart() Intégrer ensuite des graphiques dans un rapport et y décrire ce que que vous observez Gérer des conflits dans GitHub Prérequis Si ce n’est déjà fait, vous devez avoir réaliser les modules précédents. "],
["histogramme.html", "3.1 Histogramme", " 3.1 Histogramme Lors d’une expérience vous souhaitez visualiser la façon dont vos données s’étalent sur un axe (on parle de distribution5 en statistique) pour l’une des variables étudiées. L’histogramme est l’un des outils pouvant vous apporter cette information. Ce graphique va découper en plusieurs classes6 une variable numérique. Figure 1.1: Histogramme montrant la distribution de la taille d’un échantillon de zooplancton étudié par analyse d’image. Les éléments indispensables à la compréhension d’un histogramme sont (ici mis en évidence en couleur) Les axes avec les graduations (en rouge) les labels et unité des axes (en bleu) Les instructions de base afin de produire un histogramme : # Importation du jeu de données (zooplankton &lt;- read( file = &quot;zooplankton&quot;, package = &quot;data.io&quot;, lang = &quot;fr&quot;)) # # A tibble: 1,262 x 20 # ecd area perimeter feret major minor mean mode min max std_dev # &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 0.770 0.465 4.45 1.32 1.16 0.509 0.363 0.036 0.004 0.908 0.231 # 2 0.700 0.385 2.32 0.728 0.713 0.688 0.361 0.492 0.024 0.676 0.183 # 3 0.815 0.521 4.15 1.33 1.11 0.598 0.308 0.032 0.008 0.696 0.204 # 4 0.785 0.484 4.44 1.78 1.56 0.394 0.332 0.036 0.004 0.728 0.218 # 5 0.361 0.103 1.71 0.739 0.694 0.188 0.153 0.016 0.008 0.452 0.110 # 6 0.832 0.544 5.27 1.66 1.36 0.511 0.371 0.02 0.004 0.844 0.268 # 7 1.23 1.20 15.7 3.92 1.37 1.11 0.217 0.012 0.004 0.784 0.214 # 8 0.620 0.302 3.98 1.19 1.04 0.370 0.316 0.012 0.004 0.756 0.246 # 9 1.19 1.12 15.3 3.85 1.34 1.06 0.176 0.012 0.004 0.728 0.172 # 10 1.04 0.856 7.60 1.89 1.66 0.656 0.404 0.044 0.004 0.88 0.264 # # ... with 1,252 more rows, and 9 more variables: range &lt;dbl&gt;, size &lt;dbl&gt;, # # aspect &lt;dbl&gt;, elongation &lt;dbl&gt;, compactness &lt;dbl&gt;, transparency &lt;dbl&gt;, # # circularity &lt;dbl&gt;, density &lt;dbl&gt;, class &lt;fct&gt; # Réalisation du graphique chart(zooplankton, formula = ~ size) + geom_histogram(bins = 50) Figure 3.1: Instructions pour obtenir un histogramme. # bins permet de préciser le nombre de classes souhaitées La fonction chart() requiert comme argument le jeu de donnée (zooplankton, c’est un objet dataframe ou tibble dans le langage de R), ainsi que la formule à employer dans laquelle vous avez indiqué le nom de la variable que vous voulez sur l’axe des abscisses à droite de la formule. Vous voyez que le jeu de données contient beaucoup de variables (les titres des colonnes du tableau en sortie). Parmi toutes ces variables, nous avons choisi ici de représenter size, Jusqu’ici, nous avons spécifié ce que nous voulons représenter, mais pas encore comment (sous quelle apparence), nous voulons matérialiser cela sur le graphique. Pour un histogramme, nous devons ajouter la fonction geom_histogram(). L’argument bins dans cette fonction permet de préciser le nombre de classes souhaitées. Vous pouvez décrypter votre histogramme sur base des modes7 et de la symétrie8 de ces derniers. Les modes les plus fréquents sont unimodal, bimodal ou multimodal. Figure 3.2: Histogrammes montrant les modes et symétries : A. histogramme unimodal et symétrique, B. histogramme bimodal et asymétrique, C. histogramme unimodal et asymétrique, D. histogramme multimodal et symétrique. 3.1.1 Pièges et astuces 3.1.1.1 Nombres de classes d’un histogramme Vous devez être particulièrement vigilant lors de la réalisation d’un histogramme aux classes de ce dernier. # Réalisation du graphique précédent a &lt;- chart(zooplankton, formula = ~ size) + geom_histogram(bins = 50) # Modification du nombre de classes b &lt;- chart(zooplankton, formula = ~ size) + geom_histogram(bins = 20) c &lt;- chart(zooplankton, formula = ~ size) + geom_histogram(bins = 10) d &lt;- chart(zooplankton, formula = ~ size) + geom_histogram(bins = 5) # Assemblage des graphiques ggarrange(a, b, c, d, labels = &quot;AUTO&quot;, font.label = list(size = 14, align = &quot;hv&quot;)) Figure 3.3: Piège de l’histogramme. A. histogramme initial montrant la répartition des tailles au sein d’organismes planctoniques. B., C., D. Histogramme A en modifiant le nombres de classes. Comme vous pouvez le voir ci-dessus, le changement du nombre de classes peut modifier complètement la perception des données via l’histogramme. 3.1.1.2 Utilisation des snippets RStudio permet de récupérer rapidement des instructions à partir d’une banque de solutions toutes prêtes. Cela s’appelle des snippets. Vous avez une série de snippets disponibles dans la SciViews Box. Celui qui vous permet de réaliser un histogramme s’appelle .cuhist (pour chart -&gt; univariate -&gt; histogram). Entrez ce label dans une zone d’édition de code R et appuyez ensuite sur la tabulation, et vous verrez le code remplacé par ceci : chart(data = DF, ~VARNUM) + geom_histogram(binwidth = 30) L’argument binwidth = permet de préciser la largeur des classes. Vous avez à votre disposition un ensemble de snippets que vous pouvez retrouver dans l’aide-mémoire sur SciViews. Vous avez également à votre disposition l’aide-mémoire sur la visualisation des données (Data Visualization Cheat Sheet). 3.1.1.3 Histogramme par facteur Lors de l’analyse de jeux de données, vous serez amené à réaliser un histogramme par facteur (c’est-à-dire, en fonction de différents niveau d’une variable représentant des groupes). # Importation du jeu de données (iris &lt;- read(file = &quot;iris&quot;, package = &quot;datasets&quot;, lang = &quot;fr&quot;)) # # A tibble: 150 x 5 # sepal_length sepal_width petal_length petal_width species # &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; # 1 5.1 3.5 1.4 0.2 setosa # 2 4.9 3 1.4 0.2 setosa # 3 4.7 3.2 1.3 0.2 setosa # 4 4.6 3.1 1.5 0.2 setosa # 5 5 3.6 1.4 0.2 setosa # 6 5.4 3.9 1.7 0.4 setosa # 7 4.6 3.4 1.4 0.3 setosa # 8 5 3.4 1.5 0.2 setosa # 9 4.4 2.9 1.4 0.2 setosa # 10 4.9 3.1 1.5 0.1 setosa # # ... with 140 more rows # Réalisation de l&#39;histogramme par facteur chart(iris, ~ sepal_length %fill=% species) + geom_histogram() + scale_fill_viridis_d() # palette de couleur harmonieuse # `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Figure 2.2: Histogramme de la longueur des sépales de 3 espèces d’iris. La fonction chart() requiert comme argument le jeu de donnée (iris, c’est un objet dataframe ou tibble dans le langage de R), ainsi que la formule à employer dans laquelle vous avez indiqué le nom de la variable que vous voulez sur l’axe des abscisses à droite de la formule. Parmi toutes ces variables, nous avons choisi ici de représenter sepal_length. L’intérieur des barres est colorée (%fill=%) pour différencier les 3 espèces de ce jeu de données sur base de la variable species. Jusqu’ici, nous avons spécifié ce que nous voulons représenter, mais pas encore comment (sous quelle apparence), nous voulons les matérialiser sur le graphique. Pour un histogramme, nous devons ajouter la fonction geom_histogram() pour indiquer cela. La fonction scale_fill_viridis_d() permet d’obtenir des couleurs harmonieuses. Le rendu du graphique n’est pas optimal. Voici deux astuces pour l’améliorer. La premières astuces est d’employer préférentiellement les facets au lieu de l’argument %fill=% an utilisant l’opérateur | dans la formule. chart(iris, ~ sepal_length | species) + geom_histogram() # `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Figure 2.3: Histogramme de la longueur des sépales de 3 espèces d’iris en employant les facets pour séparer les espèces. L’histogramme est maintenant séparé en trois en fonction des niveaux de la variable facteur species. Simon Jackson propose une seconde solution combinant les facets et l’argument fill =. Il faut ensuite ajouter par derriere un histogramme grisé ne tenant pas compte de la variable facteur. chart(iris, formula = ~ sepal_width %fill=% species | species) + geom_histogram(data = iris[ , -c(5)] , fill = &quot;grey&quot;) + # histogramme ne tenant pas compte de la variable species geom_histogram(show.legend = FALSE) + # show.legend = FALSE permet de cacher la légende, si cette denrière n&#39;est pas informative. scale_fill_viridis_d() # `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. # `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Figure 3.4: Histogramme de la longeur des sépales de 3 espèces d’iris en employant la solution de Simon Jackson. 3.1.2 A vous de jouer ! Une nouvelle tâche va vous être demandée ci-dessous en utilisant GitHub Classroom 1.2.4.3. Cette tâche est un travail en équipe. Une fois votre assignation réalisée, faite un clone de votre dépôt et placer le dans le dossier projects. Pour cette tâche, vous démarrerez d’un projet RStudio @ref(rs_projet) Un projet sur la croissance des dents de cochon d’Inde est mis à votre disposition. Sur base du jeux de données ToothGrowth, explorez différents graphiques. Utilisez l’URL suivant qui va vous donner accès à votre tâche. TODO↩ TODO↩ TODO↩ TODO↩ "],
["graphique-de-densite.html", "3.2 Graphique de densité", " 3.2 Graphique de densité L’histogramme n’est pas le seul outil à votre disposition. Vous pouvez également employer le graphique de densité qui se présente un peu comme un histogramme lissé. Le passage d’un histogramme vers un graphe de densité se base sur une estimation par noyaux gaussien9 Figure 3.5: A. Histogramme et B. graphique de densité montrant la distribution de la taille d’un échantillon de zooplancton étudié par analyse d’image. Les éléments indispensables à la compréhension d’un graphique de densité sont (ici mis en évidence en couleur) : Les axes avec les graduations (en rouge) les labels et unité des axes (en bleu) Les instructions de base afin de produire un graphique de densité sont : # Importation du jeu de données (zooplankton &lt;- read( file = &quot;zooplankton&quot;, package = &quot;data.io&quot;, lang = &quot;fr&quot;)) # # A tibble: 1,262 x 20 # ecd area perimeter feret major minor mean mode min max std_dev # &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 0.770 0.465 4.45 1.32 1.16 0.509 0.363 0.036 0.004 0.908 0.231 # 2 0.700 0.385 2.32 0.728 0.713 0.688 0.361 0.492 0.024 0.676 0.183 # 3 0.815 0.521 4.15 1.33 1.11 0.598 0.308 0.032 0.008 0.696 0.204 # 4 0.785 0.484 4.44 1.78 1.56 0.394 0.332 0.036 0.004 0.728 0.218 # 5 0.361 0.103 1.71 0.739 0.694 0.188 0.153 0.016 0.008 0.452 0.110 # 6 0.832 0.544 5.27 1.66 1.36 0.511 0.371 0.02 0.004 0.844 0.268 # 7 1.23 1.20 15.7 3.92 1.37 1.11 0.217 0.012 0.004 0.784 0.214 # 8 0.620 0.302 3.98 1.19 1.04 0.370 0.316 0.012 0.004 0.756 0.246 # 9 1.19 1.12 15.3 3.85 1.34 1.06 0.176 0.012 0.004 0.728 0.172 # 10 1.04 0.856 7.60 1.89 1.66 0.656 0.404 0.044 0.004 0.88 0.264 # # ... with 1,252 more rows, and 9 more variables: range &lt;dbl&gt;, size &lt;dbl&gt;, # # aspect &lt;dbl&gt;, elongation &lt;dbl&gt;, compactness &lt;dbl&gt;, transparency &lt;dbl&gt;, # # circularity &lt;dbl&gt;, density &lt;dbl&gt;, class &lt;fct&gt; # Réalisation du graphique chart(zooplankton, formula = ~ size) + geom_density() Figure 3.6: Instructions pour obtenir un graphique de densité. La fonction chart() requiert comme argument le jeu de donnée ( dataframe, zooplankton), ainsi que la formule à employer (~ size). Pour réaliser un graphique de densité vous devez ensuite ajouter la fonction geom_density(). TODO↩ "],
["diagramme-en-violon.html", "3.3 Diagramme en violon", " 3.3 Diagramme en violon Le graphique en violon est constitué de deux graphiques de densité en miroir. LE résultat fait penser à un violon pour une distribution bimodale. Cette représentation est visuellement très convainquante lorsque la variable étudiée contient suffisamment d’onservations pour permettre de déterminer précisément sa distribution (plusieurs dizaines ou centaines d’observations). Figure 3.7: Graphe en violon de la distribution de la taille d’un échantillon de zooplancton étudié par analyse d’image. Les instructions pour produire un diagramme en violon sont : # Importation du jeu de données zooplankton &lt;- read( file = &quot;zooplankton&quot;, package = &quot;data.io&quot;, lang = &quot;fr&quot;) # Réduction du jeu de données zooplankton_sub &lt;- filter(zooplankton, class %in% c(&quot;Annelid&quot;, &quot;Calanoid&quot;, &quot;Cyclopoid&quot;, &quot;Decapod&quot;)) # Réalisation du graphique chart(zooplankton_sub, formula = size ~ class) + geom_violin() Figure 3.8: Instructions pour obtenir un diagramme en violon. La fonction chart() requiert comme argument le jeu de donnée (dataframe, zooplankton), ainsi que la formule à employer YVAR (size) ~ XVAR (class). Pour réaliser un graphique de densité vous devez ajouter la fonction geom_density(). 3.3.1 Pièges et astuces Parfois, un diagramme en violon apparait trop encombré, comme ci-dessous. chart(zooplankton, formula = size~ class) + geom_violin() Figure 3.9: Diagramme en violon montrant la densité de tailles des 17 classes d’organismes planctonique. Les libellés des classes sur l’axe X se chevauchent. La fonction coord_flip() peut améliorer le rendu du graphique en le faisant basculer de 90°. chart(zooplankton, formula = size~ class) + geom_violin() + coord_flip() Figure 3.10: Diagramme en violon montrant la densité de tailles des 17 classes d’organismes planctonique avec l’ajout de la fonction coord_flip(). Le package ggridges propose une seconde solution basée sur le principe de graphique de densité avec la fonction geom_density_ridges(). # Importation du packages library(ggridges) # Réalisation du graphique chart(zooplankton, class ~ size) + geom_density_ridges() Figure 3.11: Diagramme en violon montrant la densité de tailles des 17 classes d’organismes planctonique avec la fonction geom_density_ridges. "],
["a-vous-de-jouer-6.html", "3.4 A vous de jouer !", " 3.4 A vous de jouer ! Ouvrez RStudio dans votre SciViews Box, puis exécutez l’instruction suivante dans la fenêtre console : BioDataScience::run(&quot;...&quot;) Un squelette de projet RStudio vous a été fournit via une tâche Github Classroom, y compris une organisation des fichiers et des jeux de données types. Votre objectif est de comprendre les données proposées en utilisant des visualisations graphiques appropriées et en documentant le fruit de votre étude dans un rapport R Notebook. Utilisez l’histogramme et le graphique de densité que vous venez d’étudier bien sûr, mais vous êtes aussi encouragés à expérimenter d’autres formes de visualisations graphiques. "],
["visu3.html", "Module 4 Visualisation III", " Module 4 Visualisation III Vos objectif dans ce module sont : Savoir réaliser différents graphiques comme le graphique en barre, le graphique en camembert ou encore la boite de dispersion, dans R avec la fonction chart() Arranger différents graphiques dans une figure unique. Découvrir différents systèmes graphiques (graphiques de base, lattice, ggplot2) et comparaison avec chart() Si ce n’est déjà fait, vous devez avoir réaliser les module 2 &amp; 3. "],
["visualisation-graphique-a-laide-dun-graphique-en-barre.html", "4.1 Visualisation graphique à l’aide d’un graphique en barre", " 4.1 Visualisation graphique à l’aide d’un graphique en barre 4.1.1 Représentation d’un dénombration d’observations par facteur Vous souhaitez représenter une dénombrement des différentes niveaux d’une variables facteur. On peux l’exprimer dans R sous la forme : \\[\\sim variable \\ facteur\\] que l’on peut lire : \\[\\ en \\ fonction \\ de \\ la \\ variable \\ facteur\\] Figure 1.1: Points essentiels d’un graphique en barre montrant le dénombrement des niveaux d’une variable facteur. Les éléments indispensables à la compréhension d’un graphique en barre sont (ici mis en évidence en couleur) : les axes avec les graduations (en rouge) le label en x (en bleu) les niveaux de la variable facteur Les instructions de base afin de produire un graphique en barre sont : chart(e_m, formula = ~ e_mathaei) + geom_bar() Figure 3.1: Instructions pour obtenir un graphique en barres. La fonction chart() requiert comme argument le jeu de données (dataframe, e_m), ainsi que la formule à employer ~factor(VAR). Pour réaliser un graphique en barre, vous devez utiliser ensuite la fonction geom_bar(). 4.1.1.1 Représentation d’un dénombrement d’observations par plusieurs facteurs Différentes représentations sont possibles pour observer des dénombrements tenant compte de plusieurs variables facteurs. Par défaut, l’argument position a pour valeur stack. chart(diamonds, formula = ~ cut %fill=% clarity) + geom_bar() Figure 3.2: Dénombrement de l’occurence en fonction de la variable facteur cut et de la variable clarity du jeu de données diamonds. Il existe d’autres solutions en utilisant la valeur dodge ou fill pour l’argument position. b &lt;- chart(diamonds, formula = ~ cut %fill=% clarity) + geom_bar( position = &quot;dodge&quot;) c &lt;- chart(diamonds, formula = ~ cut %fill=% clarity) + geom_bar( position = &quot;fill&quot;) ggarrange(b, c, common.legend = TRUE, labels = &quot;auto&quot;) Figure 3.3: A) Graphique en barres (variable facteur cut et variable clarity avec position = &quot;dodge&quot;. B) Idem avec position = &quot;fill&quot; 4.1.1.2 Pièges et Astuces L’oeil humain perçoit plus distinctement les différences de tailles horizontales que verticales. Avec la fonction coord_flip() ajouté à votre graphique, vous pouvez effectuer une rotation des axes. chart(e_m, formula = ~ e_mathaei ) + geom_bar() + coord_flip() Figure 2.2: Graphique en barre du dénombrement de quatre variétés d’oursins. 4.1.1.3 Pour en savoir plus http://www.sthda.com/french/wiki/ggplot2-barplots-guide-de-demarrage-rapide-logiciel-r-et-visualisation-de-donnees http://ggplot2.tidyverse.org/reference/geom_bar.html http://ggplot.yhathq.com/docs/geom_bar.html 4.1.2 Représentation d’une valeur moyenne à l’aide d’un graphe en barre Le graphique en barres peut être employé afin de résumer des données numériques via la moyenne. Il ne s’agit plus de dénombrer les occurences d’une variable facteur mais de résumer des données numériques en fonction d’une variable facteur. On peut exprimer cette relation dans R sous la forme de \\[y \\sim x\\] que l’on peut lire : \\[y \\ en \\ fonction \\ de \\ x\\] ou encore \\[Variable \\ numérique \\ en \\ fonction \\ de \\ Variable \\ facteur\\] Considérez l’échantillon suivant : 1, 71, 55, 68, 78, 60, 83, 120, 82 ,53, 26 Calculez la moyenne sur base de la formule de la moyenne \\[\\overline{y} = \\sum_{i = 1}^n \\frac{y_i}{n}\\] # Création du vecteur x &lt;- c(1, 71, 55, 68, 78, 60, 83, 120, 82, 53, 26) # Calcul de la moyenne mean(x) # [1] 63.36364 En partant d’un jeu de données, comme celui ci dessous : Tableau 4.1: Tableau de données relatif à la croissance de dents de cochons d’Inde len supp dose 4.2 VC 0.5 22.5 VC 1.0 29.5 VC 2.0 15.2 OJ 0.5 20.0 OJ 1.0 23.0 OJ 2.0 Vous pouvez observez que ce jeu de données comprend trois variables avec une première variable portant sur le longueur des dents de cochons d’Inde, une seconde variable portant sur la supplémentation administrée ( VC, vitamine Cou OJ, jus d’orange) à ces derniers et enfin une troisième variable portant sur la dose administrée (0.5, 1, 2). Figure 4.1: Points essentiels d’un graphique en barre résumant les données numériques d’une variable facteur. Les éléments indispensables à la compréhension d’un graphe en barre sont (ici mis en évidence en couleur) : les axes avec les graduations (en rouge) les labels et unités des axes (en bleu) Les instructions de base afin de produire ce graphe en barre sont : # Importation des données tg &lt;- read(&quot;ToothGrowth&quot;, package = &quot;datasets&quot;) # Réalisation du graphique chart(tg, formula = len ~ supp) + stat_summary(geom = &quot;bar&quot;, fun.y = &quot;mean&quot;) Figure 3.5: Instructions pour obtenir un graphique en barre indiquant les moyennes par groupe. 4.1.2.1 Pièges et astuces 4.1.2.1.1 Représentation de la moyenne et des barres d’erreurs chart(tg, formula = len ~ supp) + stat_summary(geom = &quot;bar&quot;, fun.y = &quot;mean&quot;) + stat_summary(geom = &quot;errorbar&quot;, fun.ymax = &quot;mean_sd&quot;) # Warning: Computation failed in `stat_summary()`: # could not find function &quot;mean_sd&quot; 4.1.2.1.2 Représentation de la moyenne Le graphe en barre est un graphique très répandu dans le domaine scientifique malgré le grand nombre d’arguments contre lui que vous pouvez lire dans la section Pour en savoir plus. L’un des arguments le plus important est la faible information qu’il apporte. a &lt;- chart(ToothGrowth, formula = len ~ supp) + stat_summary(geom = &quot;bar&quot;, fun.y = &quot;mean&quot;) b &lt;- chart(ToothGrowth, formula = len ~ supp) + stat_summary(geom = &quot;point&quot;, fun.y = &quot;mean&quot;) ggarrange(a,b, labels = &quot;AUTO&quot;) Figure 3.7: moyenne de la croissance des dents de cochons d’inde en fonction du supplément admnistré (jus d’orange ou vitamine C. 4.1.2.2 Pour en savoir plus https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3148365/ https://www.r-bloggers.com/dynamite-plots-in-r/ https://pablomarin-garcia.blogspot.com/2010/02/why-dynamite-plots-are-bad.html http://biostat.mc.vanderbilt.edu/wiki/pub/Main/TatsukiRcode/Poster3.pdf http://emdbolker.wikidot.com/blog%3Adynamite "],
["visualisation-graphique-a-laide-dun-graphique-en-camembert.html", "4.2 Visualisation graphique à l’aide d’un graphique en camembert", " 4.2 Visualisation graphique à l’aide d’un graphique en camembert Le graphique en camembert va vous permettre de visualiser un dénombrement d’observations par facteur, tout comme le graphique en barre. chart(e_m, formula = ~ factor(0) %fill=% e_mathaei) + geom_bar(width = 1) + coord_polar(&quot;y&quot;, start = 0) + theme_void() + scale_fill_viridis(discrete = TRUE) Figure 3.8: Points essentiels d’un graphique en camembert montrant le dénombrement des niveaux d’une variable facteur. Les éléments indispensables à la compréhension d’un graphe en camembert sont : les niveaux de la variable facteur Les instructions de base afin de produire ce graphe en camembert sont : chart(e_m, formula = ~ factor(0) %fill=% e_mathaei) + geom_bar(width = 1) + coord_polar(&quot;y&quot;, start = 0)+ labs( x = &quot;&quot;, y = &quot;&quot;) + theme_void() + scale_fill_viridis(discrete = TRUE) Figure 3.9: Instructions 4.2.1 Pièges et astuces Le graphique en camembert est un graphique également fortement répandu. Cependant, l’oeil humain perçoit avec plus de précision les différences de formes que les différences d’angles. Un grand nombre de niveaux dans une variable facteur va avoir pour effet de remplir. De ce fait, il est donc déconseillé d’employer le graphique en camembert Partons d’un exemple fictif, combien d’observations pour la lettre h comptez vous ? fact &lt;- c(rep(x = &quot;a&quot;, times = 10), rep(x = &quot;b&quot;, times = 1), rep(x = &quot;c&quot;, times = 1), rep(x = &quot;d&quot;, times = 50), rep(x = &quot;e&quot;, times = 2), rep(x = &quot;f&quot;, times = 78), rep(x = &quot;g&quot;, times = 101), rep(x = &quot;h&quot;, times = 25) , rep(x = &quot;i&quot;, times = 31), rep(x = &quot;j&quot;, times = 49)) error &lt;- data_frame(fact = fact) chart(error, formula = ~ factor(1) %fill=% fact) + geom_bar(width = 1) + coord_polar(&quot;y&quot;, start = 0) + labs( x = &quot;&quot;, y = &quot;&quot;) + scale_fill_viridis(discrete = TRUE) Figure 3.10: Piège d’un graphique en camembert montrant le dénombrement des niveaux d’une variable facteur. Sur base de ce graphique en barre, combien d’observations pour la lettre h comptez vous ? chart(error, formula = ~ factor(fact) %fill=% fact) + geom_bar(width = 1) + scale_fill_viridis(discrete = TRUE) Figure 3.11: Piège d’un graphique en barre montrant le dénombrement des niveaux d’une variable facteur. 4.2.2 Pour en savoir plus http://www.sthda.com/french/wiki/ggplot2-graphique-en-camembert-guide-de-demarrage-rapide-logiciel-r-et-visualisation-de-donnees https://dataparkblog.wordpress.com/2017/09/24/diagramme-en-camembert-avec-r-et-ggplot/ https://www.displayr.com/why-pie-charts-are-better-than-bar-charts/ http://www.perceptualedge.com/articles/08-21-07.pdf "],
["visualisation-graphique-a-laide-de-la-boite-de-dispersion.html", "4.3 Visualisation graphique à l’aide de la boite de dispersion", " 4.3 Visualisation graphique à l’aide de la boite de dispersion Vous souhaitez représenter graphiquement cette fois un résumé d’une variable numérique tout en gardant un maximum d’information. La boite de dispersion est l’un des outils pouvant vous apporter la solution. Cette dernière va représenter graphiquement 5 descripteurs appelés les 5 nombres. Prenez les chiffres suivants : 1, 71, 55, 68, 78, 60, 83, 120, 82 ,53, 26 ordonnez les de manière croissante # création du vecteur x &lt;- c(1, 71, 55, 68, 78, 60, 83, 120, 82, 53, 26) # ordonner le vecteur sort(x) # [1] 1 26 53 55 60 68 71 78 82 83 120 Le premier descripteur des 5 nombres est la médiane qui se situe à la moitié des observations. median(x) # [1] 68 Le premier quartile sera la valeur au milieu des 50% des données inférieurs à la médiane et le troisième quartile est la valeur centrale sur les 50% des données supérieurs à la médiane. La valeur manimale étant la valeur la plus petite et la valeurs maximale étant la valeur la plus élevée. fivenum(x) # [1] 1 54 68 80 120 Vous pouvez réprésenter ce vecteur via une boite de dispersion Figure 4.2: Nuage de points montrant la première étape de la construction d’une boite de dispersion. La boite de dispersion représente donc les 5 nombres. Vous observez cependant que certaine valeur ne se situe pas dans la boite de dispersion, il s’agit de valeurs extrêmes. Elles sont considérées comme extrêmes car elles sont éloignées de plus 1.5 fois l’espace inter-quartile (Q3- Q1). La boite de dispersion s’arrete donc aux dernières valeurs présente dans cet espace inter-quartile (IQR). Figure 4.3: A) Nuage de points montrant la construction d’une boite de dispersion avec les 5 nombres représentés par des lignes noires. B) Boite de dispersion obtenue par rapport à la partie A. La boite de dispersion ainsi que sa description sont proposée sur le graphique ci-dessous. Figure 4.4: Points essentiels d’une boite de dispersion et sa description. Les instructions de base afin de produire une boite de dispersion sont : # Importation des données tg &lt;- read(&quot;ToothGrowth&quot;, package = &quot;datasets&quot;) # Réalisation du graphique chart(tg, formula = len ~ supp) + geom_boxplot() Figure 4.5: Instructions pour obtenir une boite de dispersion. La fonction chart() requiert comme argument le jeu de donnée (dataframe, tg), ainsi que la formule à employer YNUM (len) ~ XFACTOR (supp). Pour réaliser une boite de dispersion vous devez ajouter la seconde fonction geom_boxplot(). 4.3.1 Pièges et Astuces 4.3.1.1 Nombre d’observations par boite de disperion Lors de la réalisation de boites de dispersion, vous devez être vigilant au nombre d’observation qui se cache sous chaque boite de dispersion. En effet, une boite de dispersion ne comportant que 5 valeurs ou moins n’a que peut d’intérêt d’être avec cet outils graphique. Figure 4.6: Piège des boites de dispersion. La boite de dispersion “a” ne contient que 4 observations ce qui peut être totalement masqué par l’utilisation de boite de dispersion. Une des solutions permettant de connaitre graphiquement la nombre d’observations par boite est de l’ajouter au dessus de chaque boite avec la fonction give_n() give_n &lt;- function(x){ return(c(y = max(x)*1.20, label = length(x))) } chart(formula = len ~ supp, data = tg) + geom_boxplot() + stat_summary(fun.data = give_n, geom = &quot;text&quot;, hjust = 0.5) Figure 4.7: Boite de dispersion portant sur la croissance de dents de cochon d’Inde en fonction de la supplémentation administrée. chart(formula = len ~ supp %fill=% as.ordered(dose), data = tg) + geom_boxplot() + stat_summary(fun.data = give_n, geom = &quot;text&quot;, hjust = 0.5, position = position_dodge(0.75)) Figure 4.8: Boite de dispersion portant sur la croissance de dents de cochon d’Inde en fonction de la supplémentation et la dose administrée. 4.3.2 Pour en savoir plus ! http://www.sthda.com/french/wiki/ggplot2-box-plot-guide-de-demarrage-rapide-logiciel-r-et-visualisation-de-donnees https://plot.ly/ggplot2/box-plots/ http://www.r-graph-gallery.com/265-grouped-boxplot-with-ggplot2/ https://chemicalstatistician.wordpress.com/2013/08/12/exploratory-data-analysis-the-5-number-summary-two-different-methods-in-r-2/ "],
["visualisation-de-multi-graphiques.html", "4.4 Visualisation de multi-graphiques", " 4.4 Visualisation de multi-graphiques Lorsque vous souhaitez représenter plusieurs graphiques sur une seule fenêtre graphique plusieurs fonctions sont à votre disposition. Il faut tout d’abord distinguer deux types de multi-graphiques. Soit il s’agit d’un seul graphique que vous souhaitez subdiviser par rapport à une ou deux variables facteurs. Soit il s’agit de graphiques indépendants que vous souhaitez représenter sur le même fenêtre graphique. Dans le premier cas, la fonction facet_grid() du package ggplot2 peut être employé. Dans le second cas, la fonction plot_grid() du package cowplot est l’une des alternatives possibles. 4.4.1 Facets L’une des règles les plus importantes que vous devez impérativement garder à l’eprit lors de la réalisation de vos graphiques est la simplicité. Plus votre graphique va contenir d’information au plus il sera compliqué à décoder par un collaborateur. # Importation des données ChickWeight &lt;- read(file = &quot;ChickWeight&quot;, package = &quot;datasets&quot;, lang = &quot;fr&quot;) # Réalisation du graphique chart(ChickWeight, formula = weight ~ Time) + geom_point(alpha = 0.3) Figure 4.9: Nuage de point montrant la variation de la masse de poulets au cours du temps. Le graphique ci-dessus peut par exemple être simplifié avec les facets. L’information que l’on souhaite partager est la même mais les choix graphiques rendent sa lecture plus aisée. De plus, la fentre graphique a la même taille par défault que pour un seul graphique. De ce fait, réaliser de multiples graphiques peut rendre sa lecture impossible par une taille trop faible. chart(ChickWeight, formula = weight ~ Time | Diet ) + geom_point(alpha = 0.3) Figure 4.10: Nuage de point montrant la variation de la masse de poulets au cours du temps en fonction de la supplémention (1-4). Vous observez que les échelles en abscisse et en ordonnée sont similaires. Cela permet une meilleure comparaison. 4.4.2 ggarrange() La fonctions ggarrange() du package ggpubr permet de combiner plusieurs graphiques. # Importation des données ub &lt;- read(&quot;urchin_bio&quot;, package = &quot;data.io&quot;) # Réalisation des graphiques a &lt;- chart(urchin, formula = weight ~ height %col=% origin) + geom_point() b &lt;- chart(urchin, formula = weight ~ solid_parts %col=% origin) + geom_point() # Combinaison des graphiques ggpubr::ggarrange(a, b, common.legend = TRUE, legend = &quot;bottom&quot;, align = &quot;v&quot;) Figure 4.11: A) Nuage de point montrant la variation de la masse d’oursins en fonction de la taille et de leur origine. B) Nuage de point montrant la variation de la masse d’oursins en fonction de la masse des parties solides et de leur origine. Il existe d’autres fonctions permettant de combiner plusieurs graphiquescomme plot_grid() du packagecowplot. 4.4.2.1 Pour en savoir plus ! http://www.sthda.com/french/wiki/ggplot2-facet-diviser-un-graphique-en-plusieurs-panneaux-logiciel-r-et-visualisation-de-donnees http://www.cookbook-r.com/Graphs/Multiple_graphs_on_one_page_(ggplot2)/ http://lightonphiri.org/blog/ggplot2-multiple-plots-in-one-graph-using-gridextra https://cran.r-project.org/web/packages/cowplot/vignettes/plot_grid.html http://www.sthda.com/english/rpkgs/ggpubr/reference/ggarrange.html "],
["apercu-des-differents-systemes-graphiques.html", "4.5 Aperçu des différents systèmes graphiques", " 4.5 Aperçu des différents systèmes graphiques Depuis le début, l’ensemble des graphiques que nous vous avons proposé utilise la fonction chart() du package chart. Cependant, il ne s’agit pas du seul outil permettant de réaliser des graphiques dans R. # Importation des données ub &lt;- read(&quot;urchin_bio&quot;, package = &quot;data.io&quot;) # Réalisation du graphique chart(ub,formula = height ~ weight %col=% origin) + geom_point() + labs( x = &quot;Poids [g]&quot;, y = &quot;Taille [mm]&quot;) Figure 4.12: Nuage de point montrant la variation de la taille en fonction du poids d’oursins et de leur origine avec le système graphique chart(). Voici d’autres alternatives que sont R de base plot(urchin$weight, urchin$height, col = urchin$origin, ylab = &quot;Taille [mm]&quot;, xlab = &quot;Poids immergé [g]&quot;) legend(x = 80, y = 10, legend = c(&quot;Farm&quot;, &quot;Fishery&quot;), col = c(&quot;Black&quot;, &quot;Red&quot;), pch = 1) Figure 4.13: Nuage de point montrant la variation de la taille en fonction du poids d’oursins et de leur origine avec le système graphique r de base. lattice theme_sciviews_lattice() xyplot( height ~ weight, data = urchin, groups = origin, ylab = &quot;Taille [mm]&quot;, xlab = &quot;Poids immergé [g]&quot;, auto.key = TRUE) Figure 4.14: Nuage de point montrant la variation de la taille en fonction du poids d’oursins et de leur origine avec le système graphique lattice. ggplot2 ggplot(data = urchin) + geom_point(mapping = aes(x = weight, y = height, color = origin)) + labs( x = &quot;Poids immergé [g]&quot;, y = &quot;Taille [mm]&quot;) Figure 4.15: Nuage de point montrant la variation de la taille en fonction du poids d’oursins et de leur origine avec le système graphique ggplot2. Vous observez rapidement certaines similitudes entre chart, ggplot2 et lattice. En effet, la package chart a pour but premier de combiner les meilleures outils présents dans chacun des modes graphiques présentés ci-dessus. 4.5.1 Pour en savoir plus http://r4ds.had.co.nz/data-visualisation.html https://flowingdata.com/2016/03/22/comparing-ggplot2-and-r-base-graphics/ https://learnr.wordpress.com/2009/08/26/ggplot2-version-of-figures-in-lattice-multivariate-data-visualization-with-r-final-part/ https://www.statmethods.net/advgraphs/trellis.html https://www.r-bloggers.com/conditioning-and-grouping-with-lattice-graphics/ http://bl.ocks.org/patilv/raw/7360425/ http://www.sthda.com/english/wiki/scatter-plots-r-base-graphs "],
["a-vous-de-jouer-7.html", "4.6 A vous de jouer !", " 4.6 A vous de jouer ! Etudiez le tutoriel suivant : BioDataScience::run(&quot;...&quot;) "],
["import.html", "Module 5 Importation/transformation des données", " Module 5 Importation/transformation des données Vos objectifs pour ce module sont : Savoir importer des données via la fonction read(), ainsi qu’appréhender ses arguments. Appréhender les types de variables et l’importance d’encoder convenablement les variables. Savoir remanier des données afin d’extraire l’information importante d’un jeu de données. Si ce n’est déjà fait, vous devez avoir réaliser le module 1 ainsi que les modules liés à la visualisation des données. "],
["importation-des-donnees.html", "5.1 Importation des données", " 5.1 Importation des données Afin de réaliser l’analyse de vos résultats vous devez commencer par importer correctement vos données. Pour ce faire, la fonction pouvant vous apporter la solution est la fonction read() du package data.io Vos données peuvent provenir de plusieurs endroits : un package un jeu de données encodé manuellement 5.1.1 Données provenant d’un package En effet, les packages que l’on peut assimiler à des boites à outils dans R sont pour certain composé de jeu de données. La fonction `read() permet de les importer. # Importation de données provenant d&#39;un package is &lt;- read(&quot;iris&quot;, package = &quot;datasets&quot;, lang = &quot;fr&quot;) ub &lt;- read(&quot;urchin_bio&quot;, package = &quot;data.io&quot;, lang = &quot;fr&quot;) La fonction read() requiert comme premier argument le nom du jeu de données (e.g. &quot;iris&quot; ou &quot;urchin_bio&quot;), suivi de l’argument package= (e.g. &quot;datasets&quot;, ou &quot;data.io&quot;), suivi de l’argument lang= (e.g. &quot;fr&quot;) qui définit la langue d’intérêt. L’instruction ci-dessous permet d’obtenir une liste de l’ensemble des jeux de données présent dans un package. #read(package = &quot;data.io&quot;) 5.1.2 Données encodées manuellement En effet, vous serez amené à encoder manuellement vos jeux de données dans un fichier au format &quot;xlsx&quot;, &quot;csv&quot; ou encore &quot;txt&quot;. La fonction read() permet de les importer. Vous devrez dans ce cas spécifier le chemin d’accès à votre fichier. Le chemin d’accès à votre fichier peut s’écrire de diffférentes manières absolue ou bien de manière relative. Vous devez tant que possible employer des chemins relatifs. Les projets dans RStudio définissent un environnement de travail comme vu dans le module 1. Afin que ce projet soit portable, il est indisensable d’employer des chemins relatifs. Votre projet s’organise comme ceci : /home /sv /Shared /Projects /Projet test # Le répertoire de base du projet Projet test.Rproj # Fichier de configuration du projet créé par RStudio /data # Le dossier avec les données de départ Oursins.csv # Un jeu de données au format CSV /R # Un dossier pour les scripts d&#39;analyse R première analyse.R # Un scirpt de découverte des données /reports # Un dossier pour les rapports d&#39;analyse Rapport de test.nb.html # Vue HTML du rapport générée automatiquement Rapport de test.Rmd # Un premier rapport au format R Notebook Afin de définir la position de votre fichiers Oursins.csv, vous aller simplement lister l’ensemble de dossier. Il s’agit du chemin absolu , de la position de votre fichier sur votre ordinateur. Ce format n’est pas du tout portable /home/sv/Shared/Projects/Projet test/data/Oursins.csv Ce chemin est plus portable que le précédent et le tild représente le dossier utilisateur. ~/Shared/Projects/Projet test/data/Oursins.csv Vous détemrinez le chemin relatif en fonction du répertoire actif dans un projet R studio, c’est le projet lui même qui est le répertoire actif. data/Oursins.csv Afin de passer d’un chemin absolu à un chemin relatif vous devez : connaitre le répertoire actif utiliser le / pour rentrer dans un dossier utiliser le ../ pour sortir d’un dossier Pour obtenir une explication complète et détaillée sur l’utilisation des chemins relatifs dans l’organisation d’un projet Rstudio, lisez le tutoriel : “Tutoriel SDD-UMONS : La gestion des fichiers dans un projet et les chemins relatifs” # cg &lt;- read(&quot;/Users/engels/Documents/projet/data/jeu_fictif.csv&quot;) # chemin absolu # ou encore # cg &lt;- read(data/jeu_fictif.csv) # Chemin relatif 5.1.2.1 Pièges et astuces L’utilisation des chemins relatifs est indispensable comme expliqués ci-dessus. Lors de vos travaux organisé en plusieurs projets cohérents vous serez amené à travailler principalement dans des fichiers de type Rscript ou des fichiers R notebook. Le Rscript utilise comme point de départ la position de projet R studio. Par contre, le R notebook utilise sa propre position comme point de départ. 5.1.3 Pièges et astuces La fonction read() est également capable d’importer les fichier comprimer “.zip” , “.tar” ou encore “.tar.gz”. iris &lt;- read(data_example(&quot;iris.csv.zip&quot;)) # Parsed with column specification: # cols( # Sepal.Length = col_double(), # Sepal.Width = col_double(), # Petal.Length = col_double(), # Petal.Width = col_double(), # Species = col_character() # ) La fonction read() est également capable d’importer des fichiers en lignes. #ble &lt;- read(&quot;http://tinyurl.com/Biostat-Ble&quot;, type = &quot;csv&quot;) # requiert une connexion internet "],
["type-de-variables.html", "5.2 Type de variables", " 5.2 Type de variables tg &lt;- read(&quot;ToothGrowth&quot;, package = &quot;datasets&quot;) Prenez l’exemple de jeu de donnée portant sur la croissance des dents de cochon d’Inde (ToothGrowth, du packagedatasets`). Il est composé de 60 observations et de trois variables portant sur la longueur des dents (mm), le supplément administré (OJ jus d’orange ou VC vitamine C) et la dose administrée ( 0.5, 1 et 2 en mm/j). Les jeux de données sont une suite de variables mises côte à côte. Vous avez à votre disposition plusieurs type de variables : nombre : numérique : numeric entiers : integer valeurs arrondies : double nombre complexe : complex Il s’agit des valeurs numériques qui vont composer vos jeux de données. Si une variable numérique ne l’est pas vous pouvez la tranformer avec l’instruction suivante : tg$len &lt;- as.numeric(tg$len) caractères : character Il s’agit de chaine de charactères qui vont composer vos jeux de données. Les chaines de caractères vont avoir 2 but. Soit il s’agit d’une information ayant pour objectif d’être employé comme variable facteur ou bien il s’agit d’une information complémentaire sur les observations qui ne sera pas employer dans l’analyse des données. Cependant, vous pouvez être amené à transformer une variable en caractère avec l’instruction suivante : tg$supp &lt;- as.character(tg$supp) facteur : factor Il s’agit d’une variable permettant de discriminer des observations avec un ensemble de niveau dans un jeu de données comme la variable portant sur le supplément administré ou en portant sur la dose administrée. Si une variable facteur ne l’est pas vous pouvez la tranformer avec l’instruction suivante : tg$supp &lt;- as.factor(tg$supp) Il est possible de ne pas simplement changer une variable en variable facteur. Il est possible de de préciser les niveaux levels, de l’ordonner avec l’argument ordered = TRUE. Prenez la variable dose du jeu de données ToothGrowth. Etant donné qu’il s’agit de doses croissantes administrées à des cochons d’Inde, cette variable doit donc être une variable ordonnée. tg$dose &lt;- factor(tg$dose, levels = c(0.5, 1, 2), ordered = TRUE) La variable facteur ordonnée est reconnue par une ensemble de fonction dans R. Elle ne sera de ce fait pas traitée de la même manière qu’une variable facteur simple. La fonction skim() du package skimr permet de visualiser le type de la variable et bien plus encore. Il fournit une visualisation différentes en fonction du type de la variable. Il propose par exemple un histogramme pour les variables numériques comme le montre le tableau ci-dessous #skimr::skim(tg) Avec une seule instruction, on obtient une quantité d’information sur notr jeu de données comme le nombre d’observation, le nombre de variables et un traitement spécifique pour chaque type de variable. Cet instruction permet de visualiser et d’appréhender le jeu de données mais ne doit pas figurer tel quel dans un rapport d’analyse. 5.2.1 Pièges et astuces Les variables d’un jeu de données doivent être correctement importées afin d’éviter toutes mauvaises interprétations comme le montre les deux graphiques ci-dessous. Dans les graphiques a), vous pouvez observer que la dose a été employé comme une variable numérique et dans le graphique b) la dose est employée comme variable facteur. Vous observez que le bon encodage de la variable dose permet d’obtenir le graphique pertinent et cohérent avec la signification des données. tg &lt;- read(&quot;ToothGrowth&quot;, package = &quot;datasets&quot;) a &lt;- chart(tg, len ~ dose) + geom_boxplot() + labs( x = &quot;Dose administrée [mg/j]&quot; , y = &quot; longueur des dents [mm]&quot;) b &lt;- chart(tg, len ~ as.factor(dose)) + geom_boxplot() + labs( x = &quot;Dose administrée [mg/j]&quot; , y = &quot; longueur des dents [mm]&quot;) ggarrange(a,b, labels = &quot;auto&quot;) # Warning: Continuous x aesthetic -- did you forget aes(group=...)? "],
["transformation-des-donnees-1.html", "5.3 Transformation des données", " 5.3 Transformation des données Lors du module IV, vous avez réalisé votre premier remaniement de données afin de réaliser un graphique en barre résumant une variable numérique en fonction d’une variable facteur. Le principale remaniement des données peut être réalisé en 4 grands piliers : sélectionner des colonnes au sein d’un jeu de données select() filtrer des lignes dans un jeu de données filter() calculer de nouvelles variables dans un jeu de donées mutate() Résumer de colonnes d’un jeu de données initiale summarise() 5.3.1 select() Lors de l’utilisation vos jeux de données, vous serez amené à réduire vos jeux de données en sous tableau. Partez du jeu de données portant sur la croissance des oursins, ce dernier contient pas moins de 19 variables étudiées sur 421 individus. ub &lt;- read(&quot;urchin_bio&quot;, package = &quot;data.io&quot;, lang = &quot;fr&quot;) Vous vous intéressez dans votre analyse uniquement à certaines variables. La fonction select() et les fonctions d’aide à la selection (?select_helpers) peut vous apporter la solution à votre demande. ub1 &lt;- select(ub, origin, solid_parts, test) ub2 &lt;- select(ub, c(1,4,14)) ub3 &lt;- select(ub, origin, contains(&quot;weight&quot;)) ub4 &lt;- select(ub, ends_with(&quot;ht&quot;)) u1 &lt;- ggtexttable(head(ub1, n = 4), theme = ttheme(&quot;lBlack&quot;)) u2 &lt;- ggtexttable(head(ub2, n = 4), theme = ttheme(&quot;classic&quot;)) u3 &lt;- ggtexttable(head(ub3, n = 4), theme = ttheme(&quot;lRed&quot;)) u4 &lt;- ggtexttable(head(ub4, n = 4), theme = ttheme(&quot;mGreen&quot;)) ggpubr::ggarrange(u1, u2, u3, u4, labels = &quot;auto&quot;) Figure 3.11: a) Résumé de la sélection effectué ub1, b) Résumé de la sélection effectué ub2, c) Résumé de la sélection effectué ub3, d) Résumé de la sélection effectué ub4 5.3.2 filter() Lors de l’analyse de vos jeux de données, vous serez amené à filtrer les lignes de vos tableaux de données. La fonction filter() est l’un des outils pouvant vous apporter la solution. Repartez du jeu de données portant sur la croissance des oursins simplifié à 3 variables (l’origine, la hauteur et la masse du squelette). a &lt;- chart(ub2, formula = height ~ skeleton %col=% origin) + geom_point(na.rm = TRUE) ggarrange(a,u2, labels = &quot;auto&quot;, widths = c(2, 1)) Figure 5.1: a) Nuage de points montrant la variation de la hauteur du test des oursins en fonction du poids du squelette. b) Tableau de données résumé de la croissance des oursins. Vous pouvez utiliser une variable facteur pour sélectionner uniquement un niveau. égal à : == tout sauf : != u &lt;- filter(ub2, origin != &quot;Fishery&quot;) # tous les origines sauf ceux provenant de Fishery u2 &lt;- ggtexttable(head(u, n = 4), theme = ttheme(&quot;classic&quot;)) a &lt;- chart(u, formula = height ~ skeleton %col=% origin ) + geom_point(na.rm = TRUE) ggarrange(a,u2,labels = &quot;auto&quot;, widths = c(2, 1)) Figure 5.2: a) Nuage de points montrant la variation de la hauteur du test des oursins en fonction du poids du squelette. b) Tableau de données résumé de la croissance des oursins suite à l’application d’un filtre sur l’orgine des oursins. Vous pouvez utiliser une variable numérique pour filtrer les données. supérieur à : &gt; inférieur à : &lt; supérieur ou égal à : &gt;= inférieur ou égal à : &lt;= u &lt;- filter(ub2, height &gt; 20) # hauteur supérieur à 20 u2 &lt;- ggtexttable(head(u, n = 4), theme = ttheme(&quot;classic&quot;)) a &lt;- chart(u, formula = height ~ skeleton %col=% origin) + geom_point(na.rm = TRUE) ggarrange(a,u2,labels = &quot;auto&quot;, widths = c(2, 1)) Figure 4.3: a) Nuage de points montrant la variation de la hauteur du test des oursins en fonction du poids du squelette. b) Tableau de données résumé de la croissance des oursins suite à l’application d’un filtre sur les tailles des individus. Vous pouvez combiner différents filtres : &amp; : et : ou u &lt;- filter(ub2, height &gt; 20 &amp; origin == &quot;Farm&quot;) # hauteur supérieur à 20 et origine contenant uniquement les oursins venant du niveau `Farm` u2 &lt;- ggtexttable(head(u, n = 4), theme = ttheme(&quot;classic&quot;)) a &lt;- chart(u, formula = height ~ skeleton %col=% origin) + geom_point(na.rm = TRUE) ggarrange(a, u2,labels = &quot;auto&quot;, widths = c(2, 1)) Figure 4.4: a) Nuage de points montrant la variation de la hauteur du test des oursins en fonction du poids du squelette. b) Tableau de données résumé de la croissance des oursins suite à l’application d’un filtre sur l’orgine des oursins et sur les tailles des individus. 5.3.2.1 Pièges et astuces Avec des variables facteurs composé des nombreux niveaux, on peut être amené à en sélectionné plusieurs is &lt;- filter(iris, Species == &quot;virginica&quot;| &quot;setosa&quot;) ## erreur is &lt;- filter(iris, Species %in% c(&quot;setosa&quot;, &quot;virginica&quot;)) 5.3.3 mutate() Lors de l’analyse de vos jeux de données, vous serez amené à calculer de nouvelles variables. La fonction mutate() est l’un des outils pouvant vous apporter la solution. Repartez du jeu de données portant sur la croisance des oursins. Vous pouvez tout d’abord employer les - les opérateurs arithmétiques + addition : + + soustraction : - + multiplication : * + division : / + exposant : ^ ou ** + modulo (reste lors d’une division) : %% + division entière : %/% ub &lt;- mutate(ub, v1 = lantern + spines + test, v2 = v1/skeleton, v3 = skeleton^2) les fonctions mathématiques log sqrt sin, cos, tan ub &lt;- mutate(ub, v1_log = log(skeleton), v2_sqrt = sqrt(skeleton), v3_sin = sin(skeleton)) 5.3.3.1 Pièges et astuces La fonction mutate() permet de calculer de nouvelles variables. Cependant, la fonction transmute() permet de retirer les anciennes variables employées dans le calcule de la nouvelle. 5.3.4 summarise() Lors de l’analyse de vos jeux de données, vous serez amené à résumer vos données. a &lt;- summarise(tg, &quot;moyenne&quot; = mean(len), &quot;minimum&quot; = min(len), &quot;médiane&quot; = median(len), &quot;maximum&quot; = max(len)) ggtexttable(a, theme = ttheme(&quot;lBlack&quot;)) Cette fonction n’a de véritable intêrét que couplée avec la fonction `group_by() qui va permettre de grouper un jeu de données en fonction d’une ou plusieurs variable de type facteur. tg &lt;- group_by(tg, supp) a &lt;- summarise(tg, &quot;moyenne&quot; = mean(len), &quot;minimum&quot; = min(len), &quot;médiane&quot; = median(len), &quot;maximum&quot; = max(len)) ggtexttable(a, theme = ttheme(&quot;lBlack&quot;)) tg &lt;- group_by(tg, supp, dose) a &lt;- summarise(tg, &quot;moyenne&quot; = mean(len), &quot;minimum&quot; = min(len), &quot;médiane&quot; = median(len), &quot;maximum&quot; = max(len)) ggtexttable(a, theme = ttheme(&quot;lBlack&quot;)) 5.3.4.1 Pièges et astuces Tout comme lors de réalisation d’une boite de dispersion, vous devez être particulièrement vigilant ou nombre d’observation par sous groupe. Ajoutez à chaque tableau résumé des données, le nombre d’observation par sous-groupe. a &lt;- summarise(tg, &quot;moyenne&quot; = mean(len), &quot;minimum&quot; = min(len), &quot;médiane&quot; = median(len), &quot;maximum&quot; = max(len), &quot;observation&quot; = n()) ggtexttable(a, theme = ttheme(&quot;lBlack&quot;)) 5.3.5 Pièges et astuces ub &lt;- read(&quot;urchin_bio&quot;, package = &quot;data.io&quot;, lang = &quot;fr&quot;) Lors de l’analyse de vos jeux de données, vous serez amené à réaliser plusieurs de ces étapes de remaniement des données. La solution est d’employer le pipe10 `%&gt;.% qui permet de réaliser une suite d’intructions. Vous pouvez calculer de nouvelles variables puis filtrer les lignes et enfin sélectionner des colonnes. Etape par étape, vous allez utiliser la fonction mutate(), puis filter() et enfin `select() ub &lt;- mutate(ub, v1 = lantern + spines + test, v2 = v1/skeleton, v3 = skeleton^2, v1_log = log(skeleton), v2_sqrt = sqrt(skeleton), v3_sin = sin(skeleton)) ub &lt;- filter(ub, height &gt; 20 &amp; origin == &quot;Farm&quot;) ub &lt;- select(ub, origin, solid_parts, test, v2_sqrt) ggtexttable(head(ub, n = 6), theme = ttheme(&quot;lBlack&quot;)) ub1 &lt;- read(&quot;urchin_bio&quot;, package = &quot;data.io&quot;, lang = &quot;fr&quot;) Le pipe permet d’éviter certaine répétion afin de réaliser en cascade la suite des opérations. Vous devez être vigilant à la structure du pipe qui comprend le pipe %&gt;.%et le point au début des fonctions .. Le pipe fait le lien entre les différentes fonctions et le point renvoit au jeu de données passant de fonction en fonction. ub1 %&gt;.% mutate(., v1 = lantern + spines + test, v2 = v1/skeleton, v3 = skeleton^2, v1_log = log(skeleton), v2_sqrt = sqrt(skeleton), v3_sin = sin(skeleton)) %&gt;.% filter(., height &gt; 20 &amp; origin == &quot;Farm&quot;) %&gt;.% select(., origin, solid_parts, test, v2_sqrt) -&gt; ub1 # fonction pour afficher ggtexttable(head(ub1, n = 6), theme = ttheme(&quot;lBlack&quot;)) Le pipe est un outil très intéressant lors du résumé de données par une ou plusieurs variables facteurs. tg &lt;- group_by(tg, supp, dose) a &lt;- summarise(tg, &quot;moyenne&quot; = mean(len), &quot;minimum&quot; = min(len), &quot;médiane&quot; = median(len), &quot;maximum&quot; = max(len)) ggtexttable(a, theme = ttheme(&quot;lBlack&quot;)) tg %&gt;.% group_by(., supp, dose) %&gt;.% summarise(., &quot;moyenne&quot; = mean(len), &quot;minimum&quot; = min(len), &quot;médiane&quot; = median(len), &quot;maximum&quot; = max(len)) %&gt;.% ggtexttable(., theme = ttheme( colnames.style = colnames_style(fill = &quot;white&quot;), tbody.style = tbody_style(fill = get_palette(&quot;RdBu&quot;, 6)) ), rows = NULL, cols = c(&quot;Supplément&quot;, &quot;Dose&quot;, &quot;Moyenne&quot;, &quot;Minimum&quot;, &quot;Médiane&quot;, &quot;Maximum&quot;)) 5.3.5.1 Pour en savoir plus Customisation de tableau TODO↩ "],
["a-vous-de-jouer-8.html", "5.4 A vous de jouer !", " 5.4 A vous de jouer ! Un squelette de projet RStudio vous a été fournit dans un dépôt Github Classroom, y compris organisation des fichiers et jeux de données types. Votre objectif est de : Importer les données provenant du ToothGrowth Comprendre les données proposées, en utilisant des visualisations graphiques appropriées Reproduire de plus le graphique ci-dessous tg &lt;- read(&quot;ToothGrowth&quot;, package = &quot;datasets&quot;) tg$dose &lt;- as.factor(tg$dose) chart(tg, formula = len ~ dose %fill=% dose) + geom_violin(alpha = 0.3, position = &quot;dodge&quot;, trim = FALSE) + geom_boxplot(position = &quot;dodge&quot;, width = 0.2) + labs( y = &quot;Longueur des dents \\n de cochone d&#39;Inde [mm/j]&quot;, x = &quot;Dose administrée&quot;) + theme( text = element_text(size = 14), axis.text = element_text(size = 14)) Documenter le fruit de votre étude dans un rapport R Notebook. "],
["qualit.html", "Module 6 Données qualitatives", " Module 6 Données qualitatives Variables de type factor/ordered, transformation, découpage en classes, tableau de contigence. Choix des variables à mesurer, biométrie humaine. Suite d’idée afin de rédiger le chapitre 6 Vos objectifs pour ce module sont : Appréhender le découpage en classe d’une variable numérique, afin de réaliser une variable facteur Appréhender la réalisation des tableaux de contingences. Acquérir des données et les encoder de manière reproductible "],
["decoupage-en-classe.html", "6.1 Découpage en classe", " 6.1 Découpage en classe "],
["tableaux-de-contingences.html", "6.2 Tableaux de contingences", " 6.2 Tableaux de contingences "],
["acquisition-de-donnees-scientifiques.html", "6.3 Acquisition de données scientifiques", " 6.3 Acquisition de données scientifiques Vous avez pour objectif de réaliser une recherche Thématique de la biométrie humaine Recherche bibliographique sur la thématique Profil de l’expérience Variables mesurées afin de répondre à la thématique Analyses souhiatées Acquisition des données Précision &amp; exactitude Systèmes de codifications : respect de la vie privée Encodage des données Importation des données Correction des erreurs (tidy) Traitement des données ( Transform, visualise, model ) Visualisation graphiques des données Analyse statistiques des données Réalisation d’un rapport structuré répondant à la question de départ "],
["a-vous-de-jouer-9.html", "6.4 A vous de jouer !", " 6.4 A vous de jouer ! "],
["proba.html", "Module 7 Probabilités &amp; distributions", " Module 7 Probabilités &amp; distributions On part du paradoxe bayésien (effet d’un test de dépistage en fonction de la prévalence d’une maladie) -&gt; probabilités et calculs de probabilités. Généralisation = lois de distributions. Distributions discrètes et continues. Principales lois de distributions et utilisation en pratique. Evaluation par les pairs d’un rapport réalisé jusqu’ici. "],
["chi2.html", "Module 8 Test Chi carré", " Module 8 Test Chi carré Restitution globale concernant l’évaluation de rapports par les pairs. Test de Chi2, et application sur base d’une courte manip réalisée par les étudiants (par exemple, sur des coraux). "],
["moyenne.html", "Module 9 Moyenne", " Module 9 Moyenne Moyenne, intervalle de confiance et t-test. Présentation graphique: dynamite plot + barres d’erreurs. Transformation des données pour linéariser et ou rendre symétrique autour de la moyenne. Comparaison moyenne/médiane =&gt; paramétrique versus non paramétrique. Exemple d’équation avec référence, voir éq. (9.1): \\[\\begin{equation} \\mu=\\sum_{i=1}^n{\\frac{x_i}{n}} \\tag{9.1} \\end{equation}\\] L’équation suivante n’est pas libellée: \\[\\begin{equation*} \\mu=\\frac{\\sum_{i=1}^nx_i}{n} \\end{equation*}\\] "],
["variance.html", "Module 10 Variance", " Module 10 Variance Comparaison de deux populations (suite): Wilcoxon-Mann-Withney + comparaison au t-test. Variance, ANOVAs, test de Bartlett. Graphiques associés. Petite recherche biblio concernant l’application en pratique de ces tests à faire par les étudiants. "],
["correlation.html", "Module 11 Corrélation", " Module 11 Corrélation Suite ANOVA (ANOVA à deux facteurs) + correlation + graphes et tests. Restitution participation à l’élaboration du bookdown commun. "],
["design.html", "Module 12 Design expérimental &amp; critique statistique", " Module 12 Design expérimental &amp; critique statistique Design de l’expérience, choix du nombre de réplicas et puissance d’un test. Critique stat + “bad graphs” + pseudo-réplication. “Challenges” sur base de la critique statistique. Débriefing général. "],
["svbox.html", "A Installation de la SciViews Box", " A Installation de la SciViews Box La SciViews Box est une machine virtuelle (c’est-à-dire, l’équivalent d’un ordinateur complet, mais “dématérialisé” et utilisable à l’intérieur de n’importe quel autre ordinateur physique). Elle est spécialement configurée pour analyser des données et rédiger des documents scientifiques de manière professionnelle. Dans notre cas, le logiciel de gestion de la machine virtuelle, l’hyperviseur, est VirtualBox. C’est un logiciel gratuit qui existe pour Windows, MacOS et la plupart des systèmes Linux. L’avantage d’utiliser une machine virtuelle dans le contexte qui nous concerne ici est double: Elle est complètement pré-configurée et pré-testée. Comme tout le monde utilise la même machine virtuelle, les résultats obtenus chez l’un sont parfaitement reproductibles chez d’autres. L’installation est simple, mais il y a quand même quelques pièges. Suivez le guide… "],
["prerequis-2.html", "A.1 Prérequis", " A.1 Prérequis Avant d’installer la SciViews Box 2018, vérifiez que votre ordinateur répond aux conditions requises et qu’il est correctement configuré. A.1.1 Ordinateur Il vous faut : Un ordinateur suffisamment puissant équipé d’un processeur Intel Core i5 ou i7, ou son équivalent AMD, récent si possible. Les tablettes et les machines basiques avec processeur Atom, par exemple, ne sont pas suffisantes. Idéalement, un processeur bi-coeur - bi-thread, ou quadri-coeur est souhaitable. Au moins 4Go de mémoire vive. Le double, voire plus, est nécessaire pour analyser des gros jeux de données mais 4Go devraient suffire pour les analyses de tableaux de tailles plus modestes (tout de même comptant des dizaines de colonnes versus des milliers de lignes). Un disque dur rapide (un disque SSD est un plus), avec environ 20Go libres que vous pourrez consacrer à la SciViews Box. Une carte graphique de bonne qualité, mais qui n’a pas besoin d’être une bête de course, et un écran confortable. Une résolution de 1024x768 est un strict minimum. Un système d’exploitation récent, et si possible, 64bit: Linux tel Debian 8 (Jessie) ou 9 (Stretch), Ubuntu 16.04 Xenial ou supérieur, …, Windows 7 ou plus, Mac OS X 10.10 Yosemite ou plus. Une connection Internet est souhaitable, voire indispensable, en fonction des fichiers d’installation que vous possédez déjà localement ou non pour l’installation. Elle se révèlera également nécessaire à l’utilisation. A.1.2 Activation de la virtualisation La virtualisation fait appel à un jeu d’instructions disponible sur pratiquement tous les processeurs modernes (Intel VT-x ou AMD-v). Malheureusement, elle est désactivée par défaut sur quasi tous les PC (mais les Macs sont, eux, configurés correctement en sortie d’usine). Tant que ces instructions de virtualisation ne seront pas activées, le programme d’installation de la SciViews Box va bloquer avec le message suivant: Même si vous arriviez à l’installer quand même, vous ne pourriez pas la démarrer, et verriez juste le message suivant (issu de la version précédente de la SciViews Box): Pour activer ce jeu d’instructions, il faut aller dans le BIOS, c’est-à-dire, le petit programme qui démarre votre ordinateur. Il n’y a malheureusement pas de recette unique car chaque constructeur a sa propre façon de faire. De plus, l’endroit où il faut aller dans les menus de configuration du BIOS diffère aussi d’un ordinateur à l’autre. Cependant, la procédure générale est la suivante: Redémarrer l’ordinateur, Au tout début du démarrage, il faut appuyer sur une touche ou une combinaison de touches (par exemple, DEL, F2, …). Restez à l’affût d’un message furtif qui l’indique à l’écran, Une fois entré dans le BIOS, repérez l’entrée correspondant au jeu d’instructions de virtualisation. Vous aurez plus de chances en regardant dans le menu relatif au processeur, ou dans les options avancées. Recherchez une entrée de type “Virtualisation”, “Intel Virtual Technology”, ou “Instructions AMD-v”. Activez cette option (cela n’aura aucun effet sur les logiciels que vous avez installés jusqu’ici et qui n’utilisent pas cette fonction), Sortez du BIOS en sauvegardant les modifications (suivez les instructions à l’écran), Redémarrez l’ordinateur. Si vous n’arrivez pas à entrer dans le BIOS, ou à trouver l’entrée correspondante dans celui-ci, rechercher “BIOS Virtualization” accompagné de la marque et du modèle de votre ordinateur dans votre moteur de recherche internet favori. Vous y trouverez certainement des instructions plus précises relatives à votre ordinateur. Ce site liste quelques uns de raccourcis claviers à utiliser en fonction de la marque des ordinateurs pour entrer dans le BIOS. Dans le cas où vous n’arrivez pas à activer la virtualisation sur votre PC, vous pouvez toujours installer une version 32-bit de la SciViews Box en mode d’émulation logicielle de VirtualBox. Dans ce cas, votre box tournera plus lentement et vous n’aurez pas la possibilité d’utiliser plus d’un seul coeur processeur, mais au moins, vous pourrez quand même l’utiliser. La version 64-bit “complète” se nomme svbox2018a. La version 32-bit est svbox2018b. Si vous optez pour cette dernière, adaptez l’intitulé de la machine ou des fichiers (a-&gt; b) dans la suite de ce tutoriel. Si votre ordinateur est conforme aux spécifications ci-dessus, et si la virtualisation est activée, vous êtes maintenant prêt à installer votre SciViews Box! "],
["installation.html", "A.2 Installation", " A.2 Installation Vous allez devoir d’abord installer VirtualBox, un logiciel gratuit et libre qui se chargera de gérer votre machine virtuelle. Ensuite, vous installerez la SciViews Box en elle-même. Pour finir, vous aurez aussi besoin de Github Desktop. A.2.1 VirtualBox Récupérez l’installateur correspondant à votre système ici. L’installation avec tous les paramètres par défaut convient. Il se peut que vous voyiez un message vous indiquant que VirtualBox doit réinitialiser le réseau ou une autre ressource. Vérifiez que tous les documents en cours éventuels sont sauvegardés, et ensuite, vous pourrez continuer l’installation sans risques. De même, sous Windows, l’installateur de VirtualBox vous préviendra peut-être qu’il doit installer l’un ou l’autre périphérique. Vous pouvez également continuer sans craintes (précaution prise par Microsoft, mais ces périphériques fonctionnent bien). A.2.2 SciViews Box La procédure d’installation de la SciViews Box diffère selon le système d’exploitation. Reportez-vous à la sous-section correspondante pour Windows, MacOS ou Linux. A.2.2.1 Installation sous Windows Chargez l’installateur ici ou, pour les étudiants de l’UMONS, récupérez-le depuis le disque StudentTemp de la salle informatique (sous-répertoire SDD\\Software\\SciViews Box 2018). Pensez aussi à placer le fichier svbox2018a.vdi.xz dans le même répertoire que l’installateur svbox2018a_win_setup.exe. Sinon vous devrez le télécharger lors de l’installation (il pèse tout de même 2,9Gb)! Lancez l’installation. Vous verrez l’écran suivant (probablement en version française sur votre ordinateur). Vous pouvez cliquer ‘Yes’/‘Oui’. Il s’agit seulement d’une précaution de Microsoft lorsqu’il ne connait pas l’éditeur du programme à installer, comme c’est le cas ici. Si le fichier svbox2018a.vdi.xz n’est pas présent dans le même répertoire que le programme d’installation, il est à présent téléchargé (cliquez sur “Details” pour suivre l’opération): Une fois le téléchargement terminé, l’installation se poursuit. Vous verrez ensuite qu’il y a encore une opération obligatoire à lancer: la décompression du disque virtuel de la SciViews Box (svbox2018a.vdi) via ‘7z’. En cliquant ‘Finish’, cette décompression démarre toute seule. N’interrompez surtout pas la décompression du disque virtuel! Sinon, votre SciViews Box ne pourra pas démarrer et vous devrez tout recommencer à zéro en désinstallant et réinstallant complètement l’application. Losque tout est installé, vous avez une nouvelle icône sur votre bureau. Poursuivez à la section suivante pour démarrer et paramétrer votre SciViews Box. En option, vous pouvez épingler le nouveau programme dans la barre des tâches. Il sera plus facilement accessible (voir ci-dessous). A.2.2.2 Installation sous MacOS Chargez l’installateur ici ou, pour les étudiants de l’UMONS, récupérez-le depuis le disque StudentTemp de la salle informatique (sous-répertoire SDD/Software/SciViews Box 2018). Si vous le pouvez, placez le fichier svbox2018a.vdi.xz dans le dossier de téléchargements (Téléchargements ou Downloads selon la version de votre MacOS), sinon, ce fichier sera téléchargé au même emplacement (il pèse 2,9Gb)! Double-cliquez sur svbox2018a_macos_setup.dmg. Suivez simplement les instructions. Déplacez à la souris ‘SciViews Box 2018a’ vers le dossier ‘Applications’ dans la fenêtre de l’installeur (cette partie de l’installation est très rapide, donc, vous n’aurez peut-être pas l’impression que quelque chose se passe), Ensuite, toujours dans cette fenêtre, double-cliquez sur le dossier ‘Applications’ et recherchez l’entrée ‘SciViews Box 2018a’. Double-cliquez dessus, Si vous avez chargé l’installateur depuis Internet, il se peut que votre Mac indique un message et vous empêche de l’ouvrir. Dans ce cas, il faut cliquer avec le bouton droit de la souris et selectionner “Ouvrir” dans le menu contextuel tout en maintenant la touche ALT enfoncée, et ensuite cliquer “Ouvrir” dans la boite qui s’affiche. Laissez l’installation se terminer. Cela peut prendre plusieurs minutes. En option, vous pouvez aussi accrocher le programme de manière permanente dans le “Dock” pour le lancer facilement depuis cet endroit. Cliquez bouton droit et dans le menu “Options”, sélectionnez l’entrée “Garder dans le Dock”. A.2.2.3 Installation sous Linux Il est parfaitement possible d’installer la SciViews Box sous Linux. Cependant, un programme d’installation simplifié n’a pas encore été développé pour ce système. Voyez au cas par cas avec vos enseignants pour qu’ils vous expliquent comment installer la SciViews Box manuellement sous Linux. A.2.3 Github Desktop Dans ce cours, nous utilisons Git et Github pour gérer les différentes versions de vos projets et les partager avec vos binômes et vos enseignants. Github Desktop facilite grandement la gestion de vos projets sous Git. Ce programme gratuit est très facile à installer: son téléchargement et le lancement de son installateur ne pose pas de problèmes particuliers. Notez toutefois que ce programme n’est pas encore disponible pour Linux. A présent, tous les ligiciels requis sont installés… Il ne reste plus que quelques petites opérations de configuration à réaliser. Voyez ceci à la section suivante. "],
["configuration.html", "A.3 Configuration", " A.3 Configuration Même si la SciViews Box est pré-configurée, vous allez avoir quelques manipulations simples à réaliser pour être complètement opérationnel. Ces étapes sont détaillées ci-dessous. Nous en profiterons par la même occasion par nous familiariser avec quelques uns des outils logiciels que vous utiliserez plus tard, à commencer par le lanceur rapide SciViews Box. A.3.1 Lanceur SciViews Box L’application que vous venez d’installer est un lanceur rapide qui facilite le démarrage, la fermeture et la gestion de votre machine virtuelle SciViews Box 2018a. Démarrez-là et vous verrez la fenêtre suivante: Le message en rouge n’apparait pas systématiquement. Il signale des éléments importants. Ici, il indique que la configuration de la SciViews Box doit encore être faite, et pour cela, vous devez (1) la démarrer à l’aide du gros bouton en haut à gauche, (2) vous logger (mot de passe = sv), et (3) répondre Yes lorsqu’une boite de dialogue vous propose d’installer ‘svbox2018a v1.0.0’. Cette dernière étape est importante! Ne cliquez pas No ici, sous peine de ne pas avoir une machine virtuelle configurée comme celle de vos collègues! Le mot de passe vous sera redemandé, et ensuite, l’installation se poursuivra. Elle pourra prendre plusieurs minutes. Soyez patient. Vous pourrez ouvrir la fenêtre du terminal où s’opère le travail pour en suivre la progression, si vous le souhaitez. A la fin vous verrez la fenêtre du configurateur de la SciViews Box apparaître. A.3.2 Configurateur de la Box Prenez le temps de parcourir les différents éléments dans cette fenêtre11. La partie à gauche en haut concerne la configuration du clavier. En effet, la machine virtuelle utilisera votre clavier physique, mais elle n’a aucun moyen de déterminer de quel modèle il est. Vous allez donc l’indiquer maintenant. Utilisez la zone de texte intitulée Test area (type here) pour vérifier que la machine virtuelle interprète correctement les touches de votre clavier. Pour le changer, cliquez sur le bouton Change keyboard layout. La boite de dialogue de sélection du clavier apparait. Elle propose des configurations différentes sous forme de représentations graphiques, avec les touches caractéristiques surlignées en jaune. Vous pouvez entrer les premières lettres du type de clavier pour aller directement à la configuration correspondante dans la liste (ex.: entrez be pour un clavier belge). Si votre clavier ne se trouve pas dans les templates les plus courants, configurez-le à l’aide du bouton Other keyboard.... Fermez cette fenêtre pour retourner au configurateur lorsque vous aurez fini. Enfin, toujours concernant le clavier, la case à cocher Exchange left CTRL / CMD (Mac shortcuts) permet d’utiliser les raccourcis Mac (comme Cmd-c pour copier et Cmd-v pour coller à la place de Ctrl-c ou Ctrl-v sur un PC. Cette option n’est utile qu’aux possesseurs d’un Mac qui veulent avoir des raccourcis plus homogènes entre leur système MacOS hôte et la machine virtuelle12. Juste en dessous, vous voyez la configuration du fuseau horaire. Ici aussi, votre machine virtuelle n’a pas l’information de votre système hôte, et peut donc ne pas afficher l’heure correctement. Vous avez la possibilité de corriger cela en cliquant sur le bouton Change time zone. Vous devez débloquer la boite de dialogue (bouton Unlock en bas, puis entrer le mot de passe pour pouvoir effectuer des changements). Les trois boutons à gauche en bas servent à choisir le stylage des fenêtres, le set d’icônes et l’image d’arrière plan de votre SciViews Box. C’est ici que vous pourrez la paramétrer au mieux pour qu’elle vous plaise visuellement. A noter que, si vous double-cliquez sur les entrées dans les boites de dialogue de configuration, vous allez pouvoir prévisualiser l’effet en live. Utile pour apprécier le rendu avant de faire son choix! La zone en bas à droite permet de modifier le mot de passe. Pour rappel, il s’agit d’un mot de passe simple et peu sécure par défaut: sv. En fait, vous n’avez pas réellement besoin d’un mot de passe à l’intérieur de votre SciViews Box telle qu’elle est configurée car vous ne pouvez y accéder qu’en local à partir de l’ordinateur hôte. Par contre, il est possible d’ouvrir l’accès. A ce moment-là, il serait utile, et même indispensable, de modifier le mot de passe. Dans le cadre de votre utilisation de la SciViews Box pour ce cours, que ce soit sur les machines de la salle de T.P., ou sur votre ordinateur personnel, ne changez pas le mot de passe! Votre machine virtuelle est déjà protégée par votre système hôte puisque seul un accès local est autorisé. La zone en haut à droite permet de configurer votre compte Git. Comme vous allez utiliser Git et Github de manière intensive tout au long de ce cours, veuillez configurer cette partie du système correctement d’amblée! Les trois boutons du bas proposent de s’enregistrer sur trois systèmes distants d’hébergement de dépôts Git (si vous ne savez pas ce que c’est, imaginez juste que c’est là que vous allez pouvoir entreposer de manière sûre tous vos projets!): Github, Gitlab ou Bitbucket. Tous trois ont des avantages et des inconvénients, et ils proposent tous des utilisations gratuites dans certains cas. Durant nos cours de Science des Données à l’UMONS, nous utiliserons Github. Cette utilisation sera gratuite pour vous, et vous allez pouvoir déjà commencer à construire votre identité professionnelle sur le Net par son intermédiaire. Donc, enregistrez-vous de manière sérieuse. Choisissez un login représentatif de vos nom et prénom, pas un truc louffoque ou rigolo sur le moment, mais que vous regretterez plus tard, sachant que votre login ne pourra pas être changé ensuite! Vous allez donc vous créer un compte sur Github en cliquant sur le bouton correspondant, et en indiquant un login et un mot de passe. Nous vous demandons également d’utiliser expressément et uniquement votre adresse email UMONS ici : prénom.nom@student.umons.ac.be. En effet, ce sera, pour nous, notre seul moyen de vous identifier sans erreur sur Github lorsque nous interviendrons pour vous conseiller et/ou pour corriger vos travaux. Une fois enregistré sur le site de Github, reportez votre login et votre adresse email dans le configurateur de la SciViews Box, pour que Git puisse vous identifier correctement en local13. Une fois tout ceci effectué vous pourrez cliquer sur le bouton OK de la fenêtre du configurateur SciViews Box. La machine virtuelle devra redémarrer pour appliquer toutes les modifications de manière durable. Cliquez également OK donc dans la boite de dialogue qui apparait ensuite (sinon, elle redémarrera toute seule après 30 sec) : A.3.3 Installation des tutoriels Nous allons maintenant installer les tutoriels liés à ces cours de science des données biologiques. Vous allez apprendre par la même occasion comment ajouter des applications dans votre SciViews Box. Cela se fait en trois étapes: Télécharger l’installeur de l’application. Vous le trouverez à l’adresse http://go.sciviews.org/BioDataScience1. Assurez-vous de bien le charger dans le répertoire Downloads ou Téléchargements par défaut sur votre ordinateur14, Rentrez dans le lanceur rapide de la SciViews Box. Il repère l’autoinstalleur et le déplace dans le dossier partagé pour le rendre utilisable par la SciViews Box. Vous devez voir un message indiquant la disponibilité d’autoinstalleur(s). Votre fichier a également disparu du répertoire de téléchargement à ce stade, Rentrez dans la SciViews Box depuis le lanceur. Si la Box était déjà active ou si elle est réveillée du mode veille, vous allez devoir vous délogger et relogger pour que l’installation démarre, … sinon, vous allez voir directement le message suivant qui propose d’installer l’app (cliquez sur Yes, bien sûr, pour l’installer). Si le message n’apparait pas, voici comment se délogger (log out). Ensuite, entrez votre mot de passe comme d’habitude pour vous relogger… A ce moment, le message doit apparaitre, et l’installation doit se faire après avoir cliqué le bouton Yes. Bravo! Vous avez terminé l’installation et la configuration de votre SciViews Box. Cependant, nous allons encore effectuer une petite opération qui vous facilitera la vie, et nous vous expliquerons par la même occasion comment accéder aux fichiers respectifs de la machine virtuelle et du système hôte dans la section suivante. A.3.4 Accès aux fichiers Le disque physique de votre ordinateur hôte, et le disque virtuel de la SciViews Box sont deux choses différentes. Cela signifie que vous avez, en réalité deux ordinateurs et deux disques indépendants. Donc, vous n’accédez pas aux fichiers d’une machine à partir de l’autre15. Ce n’est pas pratique, et ce n’est pas vrai pour un dossier particuler nommé shared. Ce dossier shared est synchronisé en temps réel entre les deux systèmes. C’est donc l’endroit idéal pour échanger des données et pour faire collaborer vos deux machines. Inutile de préciser, donc, que nous travaillerons essentiellement à l’intérieur de ce dossier. Un sous-dossier, nommé projects sera utilisé pour héberger toutes nos analyses. Il est donc primordial d’y accéder facilement à la fois depuis l’ordinateur hôte et depuis la SciViews Box. Vous allez donc apprendre à retrouver ce dossier projects facilement. Sur votre ordinateur hôte, ce dossier est un peu difficile à trouver en naviguant dans l’explorateur de fichiers (ou le Finder sur le Mac). Pour cette raison, le lanceur rapide propose un bouton pour y accéder plus facilement. Une fois dans le dossier shared, nous vous conseillons d’épingler le sous-dossier projects dans les raccourcis rapides de votre explorateur de fichiers. Voici comment faire sous Windows et sous MacOS. Sous Windows, cliquez bouton droit sur projects, et sélectionnez “épingler dans Accès rapide”. Sous MacOS, vous glissez-déposez projects dans la barre latérale du Finder. Dans la SciViews Box, ce dossier est accessible depuis deux endroits: /media/sf_shared et ~/shared (~ représente le répertoire de l’utilisateur, c’est-à-dire /home/sv). Ici aussi vous pouvez épingler votre dossier projects pour en facilter l’accès: Les deux moyens d’accéder au dossier projects dans la SciViews Box et comment l’épingler sur le côté. A retenir: le dossier shared et ses sous-dossiers comme projects sont considérés un peu comme des dossiers réseau par la SciViews Box. Cela implique que certaines fonctions du système de fichiers n’y sont pas accessibles. Parmi celles-ci, la poubelle. Donc, vous ne pourrez qu’effacer complètement des items en cliquant bouton droit et sélectionnant ‘Delete’ dans le menu contextuel dans le gestionnaire de fichiers. Si vous essayer de placer des fichiers ou dossiers depuis shared dans la poubelle de la SciViews Box, cela vous sera refusé (voir copie d’écran ci-dessous). Par contre, cela fonctionne très bien depuis l’ordinateur hôte. Un tout dernier point concernant les ordinateurs de la salle de T.P. de l’UMONS. Pour des questions de performance, la machine virtuelle SciViews Box, et le dossier shared ne sont pas sur votre compte, mais directement sur le disque de l’ordinateur. Cela signifie qu’ils ne sont pas transportables vers un autre ordinateur. Vous pouvez créer une copie de shared dans mes documents ou sur une clé USB pour les transporter vers un autre ordinateur… mais nous verrons que cela n’est pas nécessaire pour tout ce que vous stockerez sur Github. En effet, vous avez accès à ces contenus depuis n’importe où via n’importe quelle connexion internet. Si jamais vous voulez retourner plus tard au configurateur de la SciViews Box, vous n’aurez qu’à cliquer sur son icône tout en haut à droite dans la barre supérieure.↩ Le Mac définit ses raccourcis claviers différemment du PC. Outre l’inversion de l’utilisation des touches Ctrl et Cmd, le Mac possède deux touches Alt, une à gauche et une à droite. Le PC a, par contre, deux touches correspondantes, mais celle de droite est nommée Alt Gr. Ces touches jouent des rôles différents: raccourcis claviers pour Alt et accès aux touches de niveau 3 et 4 pour Alt Gr. Pour les utilisateurs Mac, notez que vos deux touches Alt ont des rôles différents dans la SciViews Box comme pour un clavier PC. Enfin, VirtualBox réserve une touche clavier à son propre usage. Par défaut, c’est la touche Cmd ou Win de droite. Il est déconseillé de modifier ce choix car toutes les autres touches sont indispensables dans la SciViews box!↩ A la première utilisation de Git à l’intérieur du logiciel RStudio, votre login et votre mot de passe vous seront également redemandés. De même, vous devrez également fournir ces informations dans Github Desktop et la première fois que vous naviguerez vers https://github.com depuis le navigateur Web de votre PC hôte. Mais ensuite, vous accèderez immédiatement au service.↩ Il pourra ainsi être replacé au bon endroit et exécuté dans la Box↩ Le presse-papier est synchronisé entre les deux machines pour le texte qui y est copié.↩ "],
["svbox-use.html", "A.4 Utilisation", " A.4 Utilisation Une fois votre machine virtuelle configurée, vous vous trouvez confronté à cet écran qui ressemble à votre bureau d’ordinateur hôte. Cette machine virtuelle utilise le système d’exploitation linux. Vous pouvez accèder au application présent sur cette machine dans l’onglet Application. Ce dernir offre un menu déroulant avec l’ensemble des applications disponibles. Ces applications sont rangé en dossier tel que Favorites, Recently Used , All, … Le “dock” en bas permet de lancer des applications rapidement (accès rapide) et d’accéder aux fenêtres des applications en cours d’exécution tel que RStudio, Jupyter, Spyder,… Pour accèder à vos dossiers, il suffit de cliquer sur l’onglet Home que l’on retrouve également dans le dock. "],
["prise.html", "B Prise en main", " B Prise en main Cette annexe comprend une description détaillée des différents outils utilisés dans la cadre de cette formation. Passez à la section suivante pour découvrir les outils. (ex: B.1 RStudio). "],
["rs.html", "B.1 RStudio", " B.1 RStudio Sélectionnez le raccourci RStudio dans le dock. Un login vers RStudio apparaît. Il faut y entrer les informations suivantes : Username : sv Password : sv Cochez éventuellement Stay signed in pour éviter de devoir réentrer ces informations continuellement : RStudio s’ouvre. C’est votre interface de travail à partir de laquelle vous allez piloter R. La fenêtre principale comporte différents éléments : Une barre de menu et une barre d’outils générale en haut Un panneau à gauche intitulée Console où vous pouvez entrer des instructions dans R pour manipuler vos données Un panneau à droite en haut qui comprend plusieurs onglets, dont Environnement qui vous indique les différents items (on parle d’objets) chargés en mémoire dans R (mais pour l’instant, il n’y a encore rien). Un panneau en bas à droite comportant lui aussi plusieurs onglets. Vous devriez voir le contenu de Files au démarrage, un explorateur de fichiers simplifié relatif au contexte de travail actuel dans RStudio. Pour l’instant, aucun document de travail n’est encore ouvert. Pour en créer un, ou ouvrir un document existant, vous utilisez le menu Files, ou encore, le premier bouton de la barre d’outils générale : Le menu Session permet d’interagir directement avec R qui est lancé automatiquement en arrière plan dès que RStudio est ouvert. Par exemple, il est possible de relancer R à partir d’une entrée dans ce menu : Le menu Help propose différentes possibilités pour accéder à la documentation de R ou de RStudio. Les aide-mémoires (“cheatsheets” en anglais) sont très pratiques lors de l’apprentissage. Nous conseillons de les imprimer et de les consulter régulièrement. Le dernier bouton de la barre d’outils générale, intitulé Project permet d’ouvrir, fermer, et gérer les projets RStudio. Vous avez maintenant repéré les éléments fondamentaux de l’interface de RStudio. A ce stade vous pouvez vous familiariser avec l’a cheatsheet’aide-mémoire relatif à l’IDE RStudio. Vous verrez qu’il y a beaucoup de fonctionnalités accessibles à partir de la fenêtre principale de RStudio. Ne vous laissez pas intimider : vous les apprendrez progressivement au fur et à mesure de l’utilisation du logiciel. B.1.1 Projet dans RStudio Un projet sert, dans RStudio, à organiser son travail. Un projet va regrouper l’ensemble des jeux de données, des rapports, des présentations, des scripts d’une analyse généralement en raltion avec une ou plusieurs expériences ou observations réalisés sur le terrain ou en laboratoire. Notez en que le nom du projet est mentionné en haut à droite. Notez également, que le répertoire de base de votre projet est le répertoire actif dans l’onglet Console (~/shared/projects/mon_premier_projet/), et que l’onglet Files affiche son contenu. Un fichier mon_premier_projet.Rproj y est placé automatiquement par RStudio. Ce fichier contient les paramètres de configuration propres à ce projet16. C’est aussi une excellente façon de repérer qu’un répertoire est la base d’un projet RStudio, en repérant ce fameux fichier .Rproj. B.1.1.1 Création d’un projet Créez votre premier projet en suivant les 4 étapes suivantes : Étape 1. Dans RStudio, Sélectionnez le bouton tout à droite dans la barre d’outils générale de RStudio qui ouvre un menu contextuel relatif aux projets. Sélectionnez y l’entrée New Project.... Étape 2. Une boite de dialogue s’ouvre. Sélectionnez New Directory pour créer votre projet dans un nouveau dossier. Il est également possible d’employer un dossier existant comme point de départ Existing Directory). Étape 3. Sélectionnez New Project tout en haut dans l’écran suivant qui vous propose également des projets particuliers (que nous n’utiliserons pas pour l’instant). Étape 4. Ensuite, RStudio vous demander quelques informations pour préconfigurer votre projet. Nommez le projet : Directory name. Indiquez ici project_test Indiquez où vous voulez le placer : Create project as subdirectory of. Sélectionnez le sous-dossier projects dans le dossier shared partagé entre la SciViews Box et la machine hôte. Sélectionnez Create a git repository Désélectionnez Use packrat with this project(il est important de ne pas sélectionner packrat, sous peine de dupliquer de nombreux packages R dans votre projet) Vous utilisez aussi le menu spécial projet pour créer un nouveau projet (New Project...), ouvrir un projet existant (Open Project...) ou encore fermer un projet (Close Project). Vous remarquez également que les derniers projets employés sont placés sous les trois options citées ci-dessus afin d’y accéder plus rapidement. B.1.1.2 Organisation d’un projet Le répertoire projects contient maintenant un projet RStudio intitulé project_test. Depuis la SciViews Box, il se situe dans : /home /sv /shared /projects /project_test # Le répertoire de base du projet project_test.Rproj # Fichier de configuration du projet créé par RStudio .gitignore # Fichier relatif à la gestion de version Vous devez maintenant structurer votre projet afin d’avoir différents sous-répertoires pour organiser au mieux le travail. Ceci concerne à la fois les données et les rapports d’analyse en lien avec ce projet. Cliquez sur le bouton New Folder dans la barre d’outils de l’onglet Files et appelez ce nouveau dossier data. Ajoutez égalemnt le dossier analysis et R. Vous pouvez faire cela depuis RStudio, mais aussi depuis le système hôte si c’est plus confortable pour vous. /home /sv /Shared /Projects /project_test # Le répertoire de base du projet analysis # Le dossier qui comprend toutes les analyses (rapport, présentation,...) data # Le dossier qui comprend toutes les données project_test.Rproj # Fichier de configuration du projet créé par RStudio .gitignore # Fichier relatif à la gestion de version R # Le dossier qui comprend tous les scripts d&#39;analyse Vous obtenez donc un projet configuré de la manière suivante : L’organisation cohérente d’un projet est indispensable pour le bon fonctionnement et la clarté d’un projet. B.1.1.3 Chemins relatifs dans un projet L’utilisation d’un projet permet de structurer de manière cohérente son travail. Vous allez maintenant devoir rendre votre projet portable. Un projet RStudio pourra être qualifié de portable s’il est possible de déplacer son répertoire de base et tout ce qu’il contient (ou le renommer) sans que les analyses qu’il contient n’en soient affectées. Ceci est utile pour copier, par exemple, le projet d’un PC à un autre, ou si vous décidez de restructurer vos fichiers sur le disque dur. La première règle est de placer tous les fichiers nécessaires dans le répertoire du projet ou dans un sous-dossier. C’est ce que nous venons de faire plus haut. La seconde règle est de référencer les différents fichiers au sein du projet avec des chemins relatifs. Nous allons maintenant apprendre à faire cela. /home /sv /Shared /projects /project_test # Le répertoire de base du projet analysis # Le dossier qui comprend toutes les analyses (rapport, présentation,...) rapport_test.rmd # Rapport d&#39;analyse data # Le dossier qui comprend toutes les données dataset.csv # jeu de données exemple project_test.Rproj # Fichier de configuration du projet créé par RStudio .gitignore # Fichier relatif à la gestion de version R # Le dossier qui comprend tous les scripts d&#39;analyse Les différents systèmes d’exploitations (Windows, MacOS, Linux) utilisent des conventions différentes pour les chemins d’accès aux fichiers. Dans notre cas, la machine virtuelle utilise un système d’exploitation Linux. La barre oblique (/ dite “slash” en anglais) sépare les différents dossiers imbriqués sous Linux et sous MacOS. Le système d’exploitation Windows utilise pour sa part, la barre oblique inversée (\\, dite “backslash” en anglais, mais dans R et RStudio, vous pourrez également utiliser le slash /, ce que nous vous conseillons de faire toujours pour un maximum de compatibilité entre systèmes). Par exemple, votre fichier dataset.csv se référence comme suit dans la SciViews Box, donc sous Linux : /home/sv/shared/projects/project_test/data/dataset.csv Ce chemin d’accès est le plus détaillé. Il est dit chemin d’accès absolu au fichier. Vous noterez qu’il est totalement dépendant de la structure actuelle des dossiers sur le disque. Si vous renommez project_test ou si vous le déplacez ailleurs, la référence au fichier sera cassée ! Ainsi, si vous partagez votre projet avec un collaborateur qui le place ailleurs sur son disque dur, le chemin d’accès devra être adapté sans quoi l’analyse ne pourra plus s’exécuter correctement. Décodons ce chemin d’accès : /, racine du système /home/sv/, notre dossier personnel comme utilisateur sv /home/sv/shared/, le dossier partagé entre la SciViews Box et notre PC hôte /home/sv/shared/projects/project_test/, le dossier de base de notre projet /home/sv/shared/projects/project_test/data/, le répertoire qui contient le fichier dataset.csv. Le répertoire utilisateur /home/&lt;user&gt; est différent sous MacOS (il s’appelle /Users/&lt;user&gt;) et sous Windows (il se nomme généralement C:\\Users\\&lt;user&gt;). Comme c’est un répertoire clé, et qu’il est impossible d’écrire un chemin absolu qui soit le même partout, il existe un raccourcis : le “tilde” (~) qui signifie “mon répertoire utilisateur”. Ainsi, vous pouvez aussi accéder à votre jeu de données dataset.csv comme ceci : ~/shared/projects/project_test/data/datasets.csv Ce chemin d’accès est déjà plus “portable” d’un système à l’autre et d’un utilisateur à l’autre. Il est donc à préférer. Notez que sous R, vous devez doubler les backslashs sous Windows (~\\\\Documents\\\\...). Ce n’est ni très esthétique, ni compatible avec les deux autres systèmes. Heureusement, R comprend aussi le slash comme séparateur sous Windows, de sorte que la même syntaxe peut être utilisée partout ! Nous vous conseillons donc d’utiliser aussi systématiquement les slashs sous Windows dans R ou RStudio. Si cette façon d’écrire le chemin d’accès est compatible entre les trois systèmes d’exploitation, elle ne permet toujours pas de déplacer ou de renommer notre projet. L’utilisation d’un chemin relatif permet de définir la position d’un fichier par rapport à un autre dossier qui est dit le répertoire actif. A titre d’exemple, nous voulons faire référence au jeu de données dataset.csv depuis notre rapport rapport_test.Rmd. Demandez-vous d’abord quel est le répertoire actif. Pour un fichier R Markdown ou R Notebook, c’est facile, c’est le dossier qui contient ce fichier. Dans la console R, cela peut varier selon le contexte. Si vous avez ouvert un projet, c’est le répertoire de base du projet par défaut, mais cela peut être modifié. Le répertoire actif pour R est toujours indiqué en gris à côté de l’onglet Console dans RStudio. Vous pouvez aussi interroger R à l’aide de l’instruction getwd(): getwd() Vous pouvez réaliser cela dans un chunk R dans votre document R Notebook par exemple : Une fois que vous connaissez le répertoire actif, vous naviguez à partir de celui-ci. Il existe une convention pour reculer d’un dossier dans la hiérarchie : pour cela vous indiquez .. à la place d’un nom de dossier. Voici ce que cela donne : ../data/dataset.csv Comment lit-on ceci? Tout d’abord, notez (c’est très important) que le chemin d’accès ne commence pas par / (Linux ou MacOS), ou C:/ (ou toute autre lettre, sous Windows). C’est le signe que l’on ne part pas de la racine du système de fichier, mais du répertoire actif. Ensuite, les différents éléments se décryptent comme suit : ~/shared/projects/project_test/analysis, répertoire actif au départ pour le document R Notebook .., retour en arrière d’un niveau. On est donc dans ~/shared/projects/project_test /data, naviguer dans le sous-dossier data. On est donc maintenant dans ~/shared/projects/project_test/data. C’est le répertoire qui contient le fichier qui nous intéresse /datasets.csv, le nom du fichier référencé. A noter que si le fichier se trouve déjà dans le répertoire actif, le chemin relatif se résume au nom du fichier directement ! Nulle part dans ce chemin relatif n’apparaît le nom du répertoire de projet, ni d’aucun autre répertoire parent. Ainsi, il est possible de renommer ou déplacer le projet sans casser la référence relative à n’importe quel fichier à l’intérieur de ce projet. Donc, en utilisant uniquement des références relatives, le projet reste parfaitement portable. B.1.2 Rscripts dans RStudio Le script R est un fichier dont l’extension est .R. Il permet d’écrire dans un document structuré une suite d’instruction exécutable par le programme R. Un script R s’ouvrent dans la fenêtre d’édition de RStudio. Les parties de texte précédées d’un dièse (#) sont des commentaires. Ils ne sont jamais exécutés, mais ils permettent de structurer et d’expliquer le contenu de ce document (ou bien d’empêcher l’exécution d’instructions). Afin d’organiser au mieux un script, il est indispensable de commencer par l’ajout du titre, de l’auteur, de la date, … L’utilisation de sections comme à la ligne 6 est vivement conseillé. Ces sections sont créée à l’aide de l’entrée de menu Code -&gt; Insert Section.... Elles sont reprises dans le bas de la fenêtre édition pour une navigation rapide dans le script. B.1.2.1 Création d’un Rscript Vous avez à votre disposition plusieurs méthodes pour ouvrir un nouveau script R dans RStudio, dont deux vous sont montrés dans l’animation ci-dessous. B.1.2.2 Utilisation d’un script R Un script R est un document natif de R. Ce dernier va interpreter les intructions qui compose le script et qui ne sont pas précédé d’un dièse lorsqu’on les exécutent (par exemple en cliquant sur Run dans la barre d’outils de la fenêtre d’édition, ou via le raccourci clavier Ctrl+Enter ou Cmd+Enter sur MacOS). Un script R doit être organisé de manière cohérente afin d’être exécutable de haut en bas. Dans l’exemple ci-dessus, on commence par : Étape 1. Importer les principaux outils avec l’instruction SciViews::R. Étape 2. Utiliser l’instruction urchin &lt;- read(&quot;urchin_bio&quot;, package = &quot;data.io&quot;) pour importer le jeu de données urchin_bio provenant du package data.io et l’assigner à urchin. On retrouve à présent urchin dans l’environnement global (Global environment dans l’onglet Environnement dans le fenêtre en haut à droite) de RStudio. Étape 3. .?urchin et View(urchin) donnent des renseignements sur le jeu de données en renvoyant vers la page d’aide du jeu de données et en ouvrant ce jeu de données dans une fenêtre de visualisation. Étape 4. Réaliser des graphiques avec la fonction chart(). Notez que les instructions exécutées dans le script sont envoyées dans la fenêtre Consoleen bas à gauche. B.1.3 R Markdown/R Notebook dans RStudio Un document R Markdown est un fichier dont l’extension est .Rmd. Il combine à la fois des instructions R (pour les analyses) et le langage Markdown (pour le texte). le R Markdown ne vous permet pas de visualiser directement le résultat final d’un rapport d’analyse17 Tout comme les intructions dans un script R doivent être également exécutées lors de la réalisation du rapport. Une forme spéciale de document R Markdown est le R Notebook. Ce dernier est un peu un intermédiaire entre un script R et un R Markdown. Il se présente comme ce dernier, mais vous pouvez également exécuter le code qu’il contient ligne par ligne comme dans un script. Un document R Markdown / R Notebook se structure de la manière suivante : un préambule Des zones d’édition Le language employé est le Markdown Des zones de code R Ces zones de codes sont appelée des chunks Le préambule est nécessairement situé au tout début du document et est balisé à l’aide de trois tirets --- sans rien d’autre sur une ligne au début et à la fin. Le préambule comporte un ensemble d’entrées de type nom: valeur qui configuerent le document ou la façon dont il sera compilé en rapport final. Nous pouvons y indiquer le titre principal, le ou les auteurs, la date, … Le reste du document R Markdown est subdivisé en zones successives de texte et de code R (les fameux “chunks”) contrastés sur des fond de couleurs différentes dans RStudio. Les zones de texte des parties Markdown où vous pouvez écrire votre prose. Les chunks contiennent des instructions qui vont être interprétées pour réaliser un calcul, un graphique, un tableau, etc. Le résultat de ce traitement sera placé à cet endroit dans le rapport final. Ces chunks sont balisés en entrée par trois apostrophes inverses suivies d’accolades contenant des instructions relatives au programme à utiliser, par exemple, ```{r} pour des chunks faisant appel au logiciel R, et sont terminées par trois apostrophes inverses (```). Dans les zones Markdown, vous pouvez ajouter des balises qui permettront de formater votre texte dans la version finale de votre rapport. Par exemple, un ou plusieurs dièses (plus communément connu par sont appellation en anglais : “hastag”) en début de ligne suivi d’un espace indique que la suite correspond à un titre. Titre de niveau 1 avec un seul dièse, de niveau 2 avec deux dièses, et ainsi de suite jusqu’à 6 niveaux possibles. Dans la capture d’écran ci-dessous, nous avons remplacé tout le contenu par défaut d’un R Notebook (à part le préambule) par une série de titres de niveau 1 correspondant à la structure générale d’un rapport scientifique : Introduction Objectif Matériels et méthodes Résultats Discussion Conclusions B.1.3.1 Création d’un R Markdown/Notebook Vous avez à votre disposition deux méthodes pour ouvrir un nouveau R Notebook dans RStudio. Voyez l’animation ci-dessous. B.1.3.2 Utilisation d’un R Markdown/Notebook Afin de visualiser les résultats des chunks dans votre rapport final, Vous devez veiller à exécuter chaque chunks dans l’ordre dans un R Notebook. Ceci n’est pas nécessaire dans un R Markdown, mais dans ce cas, tous les chunks sont systématiquement recompilés à chaque génération de rapport, ce ui peut être pénible si les calculs sont longs. Pour exécuter un chunk, vous pouvez : cliquer sur le bouton “play”, sous forme d’une flèche verte pointant vers la droite, situé en hut à droite du chunk cliquer sur Run et sélectionner Run Current Chunk dans le menu qui apparait Employer le raccourci clavier Ctrl+Shift+Enter Le bouton Run propose plusieurs actions intéressantes : Exécuter la/les ligne(s) d’instruction sélectionnée(s) : Run Selected Line(s) Exécuter le chunk : Run Current Chunk Exécuter tous les chunk précédents : Run All Chunk Above Redémarer la console R et exécuter tous les chunks: Restart R and Run All Chunks. Cette action est particulière intéressante pour s’assurer que le document est réellement reproductible ! … Aprés la phase d’édition du texte (et des intructions dans les chunks pour un document R Notebook), vous pouvez visualiser votre rapport final en cliquant sur le bouton Preview (Notebook) ou Knit (Markdown). Le rapport est rapidement généré avec un rendu simple et professionnel. Par défaut, ce rapport présente le texte que vous avez écrit, avec les résultats que vous choisi de générer via R, mais également les instructions que vous avez employée pour obtenir ces résultats. Ceci permet de mieux comprendre, directement dans le rapport, comment tout cela a été calculé. Il est possible de cacher le code (dans un docuent généré depuis un Notebook R), ou d’indiquer une directive de compilation dans les chunks pour éviter que le code ne s’imprime dans le rapport final. Voyez les options en cliquant sur le petit engrenage à côté de la flèche verte en haut à droite du chunk. Consultez l’aide-mémoire de R Markdown accessible à partir du menu RStudio Help -&gt; Cheatsheets -&gt; R Markdown Reference Guide, voir chunk options p.2-3. Par exemple, en ajoutant la directive echo=FALSE dans la balise d’entrée d’un chunk (```{r, echo=FALSE}), on empèche d’imprimer le code de ce chunk dans le rapport. Notez que sur la droite du bouton Preview ou Knit, vous avez un autre bouton représenté par un petit engrenage. Il donne accès à un menu déroulant qui vous donne la possibilité de modifier la façon de générer vos rapports. L’entrée tout en bas Output Options... permet de paramétrer la présentation du rapport. Si vous cliquez sur la petite flèche noire pointant vrs le bas juste après Preview ou Knit, vous avez un autre menu déroulant qui donne accès aux différents formats possibles : HTML? PDF, Word, etc. Essayez les différentes options pour visualier comment votre rapport se présente dans les différents cas. N’éditer jamais à la main un fichier .Rproj. Laisser RStudio s’en occuper tout seul.↩ Les systèmes d’édition professionnels dissocient en effet le fond de la forme : vous rédiger d’abord le contenu, et ensuite, vous indiquer le style à lui appliquer.↩ "],
["github.html", "B.2 Github", " B.2 Github TODO "],
["github-classroom.html", "B.3 Github Classroom", " B.3 Github Classroom TODO "],
["learnr.html", "C Tutoriels “learnr”", " C Tutoriels “learnr” En complément de ce syllabus, vous allez utiliser également des tutoriels interactifs construits avec learnr. Si ce n’est déjà fait, commencez par installer ces tutoriels dans votre SciViews Box (voir A.3.3). Lors de l’écriture de l’instruction ci-dessous dans la console de RStudio BioDataScience::run() La liste des tutoriels vous est proposée (ces tutoriels comme tous les autres outils pédagogiques sont en cours de développement): 1: 02a_base 2: 02b_decouverte 3: 02c_nuage_de_points 4: 02d_test … Vous êtes redirigé vers le tutoriel interactif que vous sélectionnez. En sélectionnant le numéro 1, vous êtes redirigé vers le tutoriel concernant les base de R intitulé 02a_base. La première chose à vérifier à l’ouverture du tutoriel interactif est le nom d’utilisateur (username dans github) et votre adresse email (adresse email de github). Le learnr est un outil pédagogique mis au point afin de proposer des tutoriaux interactifs comprennant, des illustrations, des questions à choix multiples, des exercices R,… Les learnr qui vont seront proposé tout au long de votre formation seront composé de la manière suivante : Objectif introduction Une série d’exercice Conclusion Vous retrouvez d’ailleurs cette structure en haut à gauche de ce dernier. Chaque page du tutoriel est importante et implique vitre attention. Objectifs Cette section va détailler l’ensemble des notions que vous allez devoir maitriser durant ce tutoriel. Dans le cadre de ce premier tutoriel, l’unique objectif de ce tutoriel est donc de découvrir les bases du language R. Introduction Cette section va vous replacer dans le contexte du tutoriel interactif avec un rappel succinct des notions théoriques indispensables afin de répondre à la série d’exercices. Une serie d’exercices Cette section peut être de longueurs très variables en fonction de la difficulté des notions à appréhender. Il est possible d’obtenir des zones de codes R afin de rentrer ces instructions pour répondre à la question. Pour exécuter ces instructions, il faut cliquer sur Run Code et pour soumettre sa réponse Submit Answer. Conclusion Cette section termine ce tutoriel et propose de laisser des commentaires avec l’utilisation de dièse #. Fermez la page. En retournant dans RStudio, vous devez terminer le tutoriel en utilisant esc ou ctrl-c. "],
["redaction-scientifique.html", "D Rédaction scientifique", " D Rédaction scientifique La rédaction scientifique respecte un certain caneva expliqué dans cette annexe. D.0.0.0.0.1 Pour en savoir plus… Recherche documentaire et aide à la création (ReDAC). L’Université de Mons met à disposition de ses étudiants un cours en ligne afin de trouver un maximum de renseignements sur la rédaction de rapports scientifiques. "],
["organisation.html", "D.1 Organisation", " D.1 Organisation Un rapport scientifique respecte généralement le schéma suivant : Tables des matières Introduction Matériels et méthodes Résultat Discussion Conclusion Bibliographie Annexe (si nécessaire) Pour des travaux de plus grandes ampleurs comme les travaux de fin d’études, le schéma ci-dessus est adapté en y ajoutant généralement une partie remerciement en début de manuscrit. "],
["contenu.html", "D.2 Contenu", " D.2 Contenu Le rapport sert à restituer de façon synthétique une expérience, ses résultats et les interprétations pouvant être faites. Il faut garder à l’esprit qu’un lecteur n’ayant jamais entendu parler de cette expérience doit comprendre l’intégralité du rapport. D.2.1 Tables des matières La table des matières est d’une importance capitale afin de présenter la structure de votre rapport aux lecteurs. Heureusement, il n’est pas nécessaire de l’écrire manuellement. La table des matières est générée automatiquement dans un rapport R Markdown. L’instruction à ajouter dans le préambule du document R Notebook afin d’obtenir une table des matières est toc: yes . L’instruction à ajouter en plus de toc: yes dans le préambule du document R Notebook afin d’obtenir une table des matières numéri est number_sections: yes . Il est également possible de modifier ces paramètres dans les paramètres de sortie du document comme le montre l’image ci-dessous. D.2.2 Introduction L’introduction d’un rapport d’analyse (ou d’un mémoire) a pour principal objectif de replacer l’expérience réalisée dans son contexte. La règle la plus importante est qu’un lecteur n’ayant jamais entendu parler de cette expérience doit comprendre l’intégralité du rapport. L’introduction doit donc permettre de : Remettre l’expérience dans son contexte, Décrire l’organisme étudié description de l’organisme, distribution géographique, biotope,… Notez que l’ajout d’images ou d’une carte de distribution est un plus dans la lecture d’une introduction. D.2.3 But Le but permet de synthétiser la question posée durant cette expérience en fonction du contexte de l’expérience expliqué dans l’introduction. D.2.4 Matériel &amp; méthodes Le matériel &amp; méthodes permettent de décrire les aspects techniques de l’expérience comme le matériel employé et les méthodes employées afin d’acquérir les données. Cette section est également le lieu des descriptions des méthodes d’analyse employées, des programmes utilisés,… D.2.5 Résultats Les résultats vont généralement contenir 2 parties : Description des données : exploration des données récoltées (avec graphiques et/ou estimateurs statistiques) Application des outils statistiques pertinents pour répondre à la question posée D.2.6 Discussion Cette section comprend l’interprétation biologique des résultats. En effet, il est d’une importance capitale d’avoir un regard critique sur les résultats obtenus. Exemple : Variation du pH de l’eau de mer de 8 à 6 Lors de la mesure des paramètres physicochimiques de l’eau de mer, une étude monitore le pH avec différents instruments et propose le graphique suivant : Vous observez que deux unités différentes sont étudiées (A0 et B0) et que 5 instruments différents sont employés. Ce graphique vous semble pertinent ? Aucune information qui y figure ne vous choque ? Si ce n’est pas le cas, il faut encore exercer votre oeil de biologiste. La sonde pH sur le graphique propose une valeur de pH proche de 6.5 alors que les autres instruments sont entre 7.2 et 8. Nous sommes donc passé d’un pH légérement basique à un pH acide. Les organismes présents dans les aquariums serait mort à cette valeur de pH. Elle est également le lieu de comparaison avec d’autres études dans le domaine, de la critique du design expérimental,… D.2.7 Conclusion &amp; perspective Cette section va tenir une sorte de résumé de notre expérience par rapport à au but de cette dernière et proposer des perspectives afin de continuer la recherche sur cette thématique. D.2.8 Bibliographie La rédaction de travaux s’appuye toujours sur une recherche bibliographique au préalable. Cependant, il est capital d’insérer convenablement les sources du travail au sein de la section bibliographie afin d’éviter le plagiat volontaire ou involontaire. Il existe une multitude de programme permettant la gestion d’une bibliographie comme Mendeley, Zotero ou encore Endnote. Citer ses sources dans un rapport R Notebook : page en anglais présentant la manière d’introduire une bibliographie dans un rapport R Notebook. "],
["nom-des-especes.html", "D.3 Nom des espèces", " D.3 Nom des espèces Le nom complet d’une espèce en biologie suit une convention particulière que vous devez appliquer dans toutes vos productions écrites : Partons de l’exemple de l’oursin violet, une espèce est classée de la manière suivante (Les niveaux de classification les plus importants sont mis en gras) : Règne : Animalia Sous-Embranchement : Echinozoa Embranchement : Echinodermata Classe : Echinoidea Super ordre : Echinacea Ordre : Camarodonta Infra-ordre : Echinidae Famille : Parachinidae Genre : Paracentrotus Espèce : lividus Afin de former le nom binomial de l’oursin violet, on utilise le genre et l’espèce de la classification proprosée ci-dessus : Paracentrotus lividus Le nom binomial n’est pas suffisant afin de nommer correctement une espèce. Il faut également ajouter le nom du naturaliste qui a nommé et décrit l’espèce et l’année de la publication de la discription (on parle de diagnose en biologie). Paracentrotus lividus Lamarck 1816 Lors de la première citation de l’espèce étudiée dans un rapport, il est indispensable de spécifier le nom complet de l’espèce qui sera abbrégé par la suite en P. lividus "],
["references.html", "Références", " Références "]
]
