[
["index.html", "Science des données biologiques, UMONS Préambule", " Science des données biologiques, UMONS Philippe Grosjean &amp; Guyliann Engels 2018-10-24 Préambule Cet ouvrage couvrira, à terme, la matière des cinq cours de science des données enseignés aux biologistes de la Faculté des Sciences de l’Université de Mons (Belgique). La matière sera complétée progressivement à partir du premier cours prévu pour l’année académique 2018-2019. Cet ouvrage est conçu pour être utilisé de manière interactive en ligne. En effet, nous prévoyons d’y adjoindre des capsules (unités d’enseignement ciblant un et un seul concept) sous forme de vidéos, des démonstrations interactives, et des exercices sous forme de questionnaires interactifs également. Ces différents éléments ne sont, bien évidemment, utilisables qu’en ligne. "],
["vue-generale-du-cours.html", "Vue générale du cours", " Vue générale du cours Le premier cours intitulé Science des données I: visualisation et inférence qui est dispensé aux biologistes de second Bachelier en Faculté des Sciences de l’Université de Mons à partir de l’année académique 2018-2019 contient 25h de cours et 50h d’exercices en presentiel. Il nécessitera environ un tiers de ce temps (voir plus, en fonction de votre rythme et de votre technique d’apprentissage) en travail à domicile. Cette matière est divisée en 12 modules de sessions de 6h chacune en présentiel. Une première séance de 2h précèdera ces 12 modules afin d’installer les logiciels (SciViews Box, R, RStudio, Github Desktop), et de se familiariser avec eux. "],
["materiel-pedagogique.html", "Matériel pédagogique", " Matériel pédagogique Le matériel pédagogique, rassemblé dans ce syllabus interactif est aussi varié que possible. Vous pourrez ainsi piocher dans l’offre en fonction de vos envies et de votre profil d’apprenant pour optimiser votre travail. Vous trouverez: le présent ouvrage en ligne, des capsules, essentiellement sous forme de vidéos &lt; 10 min qui ciblent chacune un concept particulier (en cours de développement), des tutoriaux interactifs (réalisés avec un logiciel appelé learnr). Vous pourrez exécuter ces tutoriaux directement sur votre ordinateur, et vous aurez alors accès à des pages Web réactives contenant des explications, des exercices et des quizzs en ligne, des slides de présentations, des dépôts Github Classroom dans la section BioDataScience-Course (vous apprendrez ce que c’est très rapidement dès le premier module) pour réaliser et documenter vos travaux personnels. des renvois vers des documents externes en ligne, types vidéos youtube ou vimeo, des ouvrages en ligne en anglais ou en français, des blogs, des tutoriaux, des parties gratuites de cours Datacamp ou équivalents, des questions sur des sites comme “Stackoverflow” ou issues des “mailing lists” R, … Tout ce matériel est accessible à partir du site Web du cours, du présent syllabus interactif (et de Moodle pour les étudiants de l’UMONS). Ces derniers ont aussi accès au dossier SDD sur StudentTemp en Intranet à l’UMONS. Les aspects pratiques seront à réaliser en utilisant la ‘SciViews Box’, une machine virtuelle préconfigurée que nous installerons ensemble lors du premier cours1. Il vous faudra donc avoir accès à un ordinateur (sous Windows, MacOS, ou Linux peu importe, suffisamment puissant et connecté à Internet ou à l’Intranet UMONS). Enfin, vous pourrez poser vos questions par mail à l’adresse sdd@sciviews.org. Il existe tout de même des outils plus pointus pour obtenir de l’aide sur le logiciel R comme rseek.org, rdocumentation.org ou rdrr.io. Rien ne sert de chercher ’R’ dans Goggle.↩ "],
["comment-apprendre.html", "Comment apprendre?", " Comment apprendre? fortunes::fortune(&quot;brain surgery&quot;) # # I wish to perform brain surgery this afternoon at 4pm and don&#39;t know where # to start. My background is the history of great statistician sports # legends but I am willing to learn. I know there are courses and numerous # books on brain surgery but I don&#39;t have the time for those. Please direct # me to the appropriate HowTos, and be on standby for solving any problem I # may encounter while in the operating room. Some of you might ask for # specifics of the case, but that would require my following the posting # guide and spending even more time than I am already taking to write this # note. # -- I. Ben Fooled (aka Frank Harrell) # R-help (April 1, 2005) Version courte: en pratiquant, en faisant des erreurs ! Version longue: aujourd’hui –et encore plus à l’avenir– les données sont complexes et ne se manipulent plus simplement avec un tableur comme Microsoft Excel. Vous allez apprendre à maitriser des outils professionnels, ce qui sous-entend qu’ils sont très puissants mais aussi relativement complexes. La méthode d’apprentissage que nous vous proposons a pour objectif prioritaire de vous faciliter la tâche, quelles que soient vos aptitudes au départ. Envisagez votre voyage en science des données comme l’apprentissage d’une nouvelle langue. C’est en pratiquant, et en pratiquant encore sur le long terme que vous allez progresser. La formation s’étale sur quatre années, et est répartie en cinq cours de difficulté croissante pour vous aider dans cet apprentissage progressif et sur la durée. N’hésitez pas à expérimenter, tester, essayer des nouvelles idées (même au delà de ce qui sera demandé dans les exercices) et n’ayez pas peur de faire des erreurs. Vous en ferez, … beaucoup … nous vous le souhaitons! En fait, la meilleure manière d’apprendre, c’est justement en faisant des erreurs, et puis en mettant tout en oeuvre pour les comprendre et les corriger. Donc, si un message d’erreur, ou un “warning” apparait, ne soyez pas intimidé. Prenez une bonne respiration, lisez-le attentivement, essayez de le comprendre, et au besoin faites-vous aider: la solution est sur le Net, ‘Google1 est votre ami’! Il existe tout de même des outils plus pointus pour obtenir de l’aide sur le logiciel R comme rseek.org, rdocumentation.org ou rdrr.io. Rien ne sert de chercher ’R’ dans Goggle.↩ "],
["evaluation.html", "Evaluation", " Evaluation L’évaluation sera basée sur une somme de petites contributions qui matérialiseront votre progression sur le long terme. Avec cette évaluation, nous souhaitons vous gratifier chaque fois que vous franchirez des étapes, plutôt que de vous sanctionner lorsque vous bloquez. Donc, pour une note finale sur 20: 3 points pour la restitution des capsules et votre participation en présentiel. Au début de chaque séance, nous discuterons des notions que vous aurez à préparer par avance, et votre participation sera évaluée. 6 points pour un quizz final. 11 points pour l’évaluation d’un des rapports d’analyse de données (choisi au hasard en fin de cours). Enfin, vous pourrez éventuellement encore gagner un point bonus pour une participation remarquable, ou tout autre élément à valoriser (site web personnel et/ou blog exceptionnel, aide des autres étudiants, etc.). Ceci étant à l’appréciation des enseignants. Le matériel dans cet ouvrage est distribué sous licence CC BY-NC-SA 4.0. "],
["intro.html", "Module 1 Introduction", " Module 1 Introduction Objectifs : Appréhender ce qu’est la science des données et les (bio)statistiques. S’initier à des outils de base (SciViews Box, RStudio, Markdown, git, Github). Se sensibiliser à l’importance d’une présence web au niveau professionnel. "],
["donnees.html", "1.1 Le monde il y a 25 ans", " 1.1 Le monde il y a 25 ans Il y a 25 ans, pas d’internet, pas de smartphone. Essayez d’imaginer ce que serait votre vie aujourd’hui si ces outils qui font partie de votre quotidien n’existaient pas. Les révolutions indistrielles: 1770 (1756) révolution 1: mécanisation 1870 révolution 2: maîtrise de l’énergie 1970 (1979) révolution 3: informatique 1990 révolution 4: internet (1990 Web, 1992 ISOC = Internet society, 1993 = premier navigateur web) 2000 révolution 5: numérique. GAFA = Google - Apple - Facebook - Amazon + Microsoft = GAFAM aux USA et BATX en Chine = Baidu - Alibaba - Tencent - Xiaomi. Aussi NATU = Netflix - Airbnb - Tesla - Uber. 2010 révolution 6: NBIC = nanotechnologies - biotechnologies - informatique - sciences cognitives. 2020 = date prévue pour que l’ordinateur ait la même puissance de traitement de l’information que le cerveau humain 2030 = transhumanisme: ordinateur plus puissant que l’homme et le remplacera probablement dans de nombreuses tâches. Valeur estimée des données et informations mises à disposition par les utilisateurs du net: 1000 milliards de dollar par an (écrivez ce nombre en chiffres pour vous donner une meilleure idée de ce que cela représente) ! En 2020, quantité d’information ajoutée sur le net: 1000 milliards de milliards par semaine (écrivez ce nombre en chiffres également). Comparaison de puissance de traitement du cerveau humain versus un ordinateur: 89 milliards de neurones, mais travail en multitâche alors qu’un processeur est monotâche =&gt; difficile à comparer. Une étude a montré en 2017 que l’un des 5 ordinateurs les plus puissants a été capable de simuler le fonctionnement d’environ 1% du cerveau humain en 1 sec. Il lui a fallu 40 min de calcul pour y arriver. Intel estime que l’évolution permettra d’égaler le cerveau humain en terme de vitesse de traitement vers 2020. Consommation électrique du supercalculateur: se mesure en mégawatts, alors que le cerveau humain consomme 12-13W seulement! “Le transhumanisme est une approche interdisciplinaire qui nous amène à comprendre et à évaluer les avenues qui nous permettrons de surmonter nos limites biologiques par les progrès technologiques. Les transhumanistes cherchent à développer les possibilités techniques afin que les gens vivent plus longtemps et …” Vous pouvez maintenant avoir un aperçu de l’importance d’avoir des outils performants afin d’appréhender les données dont le nombre croit de manière exponentielle. Pour ce cours de sciences des données, plusieurs outils puissants sont mis à votre disposition (Vous trouverez sur l’hyperlien suivant, un poster présentant la philosophie du cours https://github.com/BioDataScience-Course/RencontresRRennes2018) "],
["decouverte-des-outils.html", "1.2 Découverte des outils", " 1.2 Découverte des outils La science des données est complexe et requiert d’employer des outils performants. Nous avons sélectionné ces outils pour vous. 1.2.1 Machine virtuelle La SciViews Box est une machine virtuelle (un ordinateur complet, mais totalement indépendant du matériel -le hardware- et qui peut être déployé sur pratiquement n’importe quel ordinateur physique). Cette SciViews Box est complètement configurée et dédiée à la sciences des données biologiques. Elle contient tout ce qu’il faut pour importer et analyser vos données, et ensuite écrire des rapports ou d’autres documents prêts à publication ou à présentation. Elle vous servira également à collaborer avec d’autres chercheurs qui peuvent facilement utiliser exactement la même machine virtuelle (aspect reproductible de vos analyses). Des explications détaillées se trouvent dans l’annexe A dédiée à l’installation et la configuration de la SciViews Box. Figure 1.1: Logo de la SciViews Box Une fois loggé dans la machine virtuelle, réalisez l’activité : Découverte de la machine virtuelle https://github.com/BioDataScience-Course/sdd_lesson/blob/master/sdd1_01/presentations/sdd1_01_svbox.pdf Après avoir réalisé l’activité, un document récapitulatif est mis à votre disposition : https://github.com/BioDataScience-Course/sdd_lesson/blob/master/sdd1_01/exercises/sdd1_01_svbox.Rmd Des explications détaillées se trouvent dans l’annexe @ref(svbox_use) dédiée à l’utilisation de la SciViews Box. 1.2.2 RStudio RStudio est l’outil au sein de la SciViews Box que vous allez utiliser le plus fréquemment durant ce cours. Il fournit un environnement complet et optimisé pour réaliser vos analyses, vos graphiques et vos rapports. RStudio travaille main dans la main avec le logiciel R qui effectue l’ensemble des traitements. L’interface utilisateur de RStudio est divisée en quatre zones importantes (A-D) avec une barre d’outils générale par dessus : A. Une zone d’édition B. Plusieurs onglets sont présents comme Environnement, History ou encore Connections. Par exemple, les différents items (on parle d’objets) chargés en mémoire dans R sont visibles dans l’onglet Environnement (mais pour l’instant, il n’y a encore rien). C. La Console est l’endroit où vous pouvez entrer des instructions dans R pour manipuler vos données D. Une zone multiusage où vous pouvez manipuler vos fichiers (Files), vos graphiques (Plots), les différents “addins” de R (on parle de Packages), accéder aux pages d’aide (Help) ou encore, visualiser le rendu final de vos rapports (Viewer). Des explications détaillées se trouvent dans l’annexe B.1 qui présente les bases de l’utilisation de RStudio. Vous avez également à votre disposition un aide-mémoire afin d’appréhender cette interface RStudio IDE Cheat Sheet. 1.2.2.1 Pour en savoir plus … RStudio. Site Web de RStudio comprennant un ensemble de ressources en anglais RStudio, un environnement de développement pour R. Brève explication de RStudio en français. RStudio : sa vie, son oeuvre, ses ressources. Un autre site Web consacré à RStudio en français. 1.2.3 Markdown Dans RStudio, les rapports sont rédigés en utilisant le language Markdown dans la zone d’édition. Il permet de baliser le texte pour indiquer le sens des différentes parties (par exemple, pour indiquer les différents niveaux de titres). Il permet de se concentrer sur l’écriture dans un premier temps en dissociant le fond de la mise en forme. En effet, vous vous préoccupez de l’aspect final du document dans un second temps, et même, vous pouvez changer radicalement d’avis pratiquement sans rien changer dans le texte (par exemple, il est possible de passer d’une page Web à un document PDF ou Word, ou même encore à une présentation). Markdown est relativement simple et intuitif à l’usage, même si un petit effort est nécessaire, naturellement, au début. Quels sont les commandes et instructions indispensables lorsque l’on rédige un rapport ? Des titres et sous-titres, une mise en évidence (texte en italique ou en gras), des listes,… Il ne faut au final que très peu de commandes pour réaliser un rapport de qualité avec une mise en page sobre et épurée qui caractérise les travaux professionnels. Vous avez à votre disposition deux aide-mémoires pour apprendre Markdown : R Markdown Cheat Sheet et R Markdown Reference Guide plus détaillé. Après avoir rédiger votre document, vous devez cliquer sur le bouton Preview ou Knit (selon le type de document édité) dans la barre d’outils de la zone d’édition pour obtenir la version finale formattée. Une fois loggé dans la machine virtuelle, réalisez l’activité : Découverte de RStudio et R Markdown https://github.com/BioDataScience-Course/sdd_lesson/blob/master/sdd1_01/presentations/sdd1_01_markdown.pdf Après avoir réalisé l’activité, un document récapitulatif est mis à votre disposition : https://github.com/BioDataScience-Course/sdd_lesson/blob/master/sdd1_01/exercises/sdd1_01_markdown.Rmd 1.2.3.1 Pour en savoir plus… Markdown. Explication en anglais de l’intérêt d’employer Markdown ainsi que la syntax à employer. Rédigez en Markdown ! Un guide pour bien commencer avec Markdown Le Markdown comme langage d’écriture universel ? Comment écrire confortablement et professionnellement ? Le Markdown !. Utilisation de Markdown afin de revenir à l’essence de la rédaction. Écrire tout simplement – Introduction à Markdown. Pourquoi utiliser Markdown ? 1.2.4 Gestionnaire de version Lors de la rédaction de travaux un petit peu conséquents, comme un travail de fin d’étude, une publication scientifique ou un rapport volumineux, on se retrouve rapidement avec plusieurs fichiers correspondant à des états d’avancements du travail : TFE_final TFE_final1 TFE_final2 TFE_final3 TFE_final… TFE_final99 Lors de différents essais, on va avoir tendance à tout garder dans différents fichiers afin de ne rien supprimer d’important. Cette pratique bien que très courante comporte le gros désavantage de prendre énormément de place sur le disque de votre ordinateur et de n’être pas pratique. Les questions suivantes peuvent se poser : Que se cache t’il dans la version TFE_finalX ? Après 1 mois sans travailler sur le projet, seriez-vous encore capable de faire facilement la différence entre TFE_final2 et le TFE_final3 ? Cela se complique encore plus lorsque plusieurs personnes collaborent sur un même projet. Ils vont, par exemple, s’échanger par mail différentes versions du travail avec chacun qui y place ses commentaires et modifie différentes parties du texte. Cela peut donner quelque chose comme ceci : TFE_final TFE_final1 TFE_final1_jacques TFE_final1_pierre TFE_final2 TFE_final2_jules TFE_final… TFE_final99 Dans quel fichier se trouve la dernière version de chaque personne ayant collaboré sur le projet ? Une petit peu dans différents fichiers, sans doute. Différents outils informatiques existent pour faciliter le travail collaboratif comme : Le partage de fichiers en ligne (Dropbox, Google Drive, One Drive). Ces espaces de stockage sur le cloud ne règlent toujours pas le problème de collaboration sur le même fichier. L’utilisation d’un programme d’édition collaboratif en temps réel (Etherpad, Google Drive - Docs, Gobby). Il est possible de travailler en même temps sur un même fichier. Cette option ne règle pas le problème du retour vers une ancienne version. Lorsqu’une modification a été réalisée l’ancienne version est tout simplement écrasée. La meilleure combinaison pour gérer ses versions et collaborer : Git et GitHub. Ces outils sont plutôt considérés comme écrits par et pour des geeks. Cependant, ils permettent de gérer et collaborer de manière efficace sur un même projet contenant du code ou non, et des interfaces facilitant leur utilisation apparaissent comme GitHub Desktop, ou même, les outils Git intégrés dans RStudio. 1.2.4.1 Git La gestion de versions est gérée par Git. Cet outil va remplacer les nombreuses copies d’un même fichier par une sorte d’arbre que l’on peut représenter schématiquement comme ci-dessous : Représentation de la gestion de fichiers via Git Comme vous pouvez le voir ci-dessus, on peut suivre la progression de notre projet via un nombre d’étapes successives représentées sur le schéma par des boules bleues. Chaque étape capture l’état de notre projet au moment où nous avons décidé de l’enregistrer. Pour enregistrer une nouvelle version de votre projet, vous réalisez un commit qui sera accompagné d’un message spécifiant les modifications apportées. Git comprend de nombreux outils très intéressant pour la gestion de versions que vous utiliserez par la suite. 1.2.4.2 GitHub Un réseau social a été conçu autour de Git pour sauvegarder vos projets sur le cloud, les partager et collaborer avec d’autres personnes. Ce système se nomme GitHub (tout comme Facebook ou LinkedIn). GitHub rassemble donc “Git”, la gestion de version et “Hub” relatif au réseau. D’autres réseaux équivalents existent comme Gitlab ou Bitbucket, mais dans ce cours, nous utiliserons GitHub ensemble, sachant que les notions apprises ici seront réutilisables ailleurs. Lorsque l’on travaille seul tout en utilisant GitHub, l’évolution de notre projet va ressembler à l’arbre ci-dessous : Représentation des versions successives d’un projet avec GitHub. On réalise un envoi (push) lorsque l’on souhaite synchroniser nos changements locaux avec la version sur le cloud. Plusieurs commits peuvent être envoyés avec un seul push sur le réseau, et c’est d’ailleurs généralement comme cela que l’on procède. L’inverse (rappatrier localement les changements que d’autres collaborateurs ont envoyé sur la version réseau de notre projet) s’appelle faire un “pull”. L’avantage principal de GitHub ne réside pas vraiment dans la posibilité de réaliser une sauvegarde en ligne mais plutôt dans la possibilité de collaborer avec d’autres personnes présentes sur ce réseau comme l’illustre la figure ci-dessous. Deux scientifiques (les versions représentées par des boules bleues et des boules vertes) collaborent sur un même projet que l’on appele un dépôt (repository en anglais) lorsqu’il est en ligne. Le premier chercheur (boules bleues) va initier le dépôt et réaliser un “push”&quot; pour rendre son travail accessible sur le réseau (boules oranges). Son collaborateur (boules vertes) va clôner (clone en anglais) le dépôt sur son ordinateur afin d’y travailler également en local sur son PC. Après avoir fait des changements, il réalise également un push sur le réseau. Le premier scientifique, avant de travailler à nouveau sur le projet, va donc réaliser un pull afin d’obtenir en local l’ensemble des modifications fournies par son ou ses collaborateurs, et ensuite après modifications en local il effectuera à nouveau un “push”. Différentes versions d’un projet sur GitHub lorsque deux personnes différentes collaborent sur le même dépôt. Vous venez d’apprendre le B-A-BA de la terminologie nécessaire à la bonne compréhension de Git et GitBub : repository : espace de stockage sous gestion de version Git. commit : enregistrer une version du projet. clone : créer un double local d’un dépôt GitHub. push : envoyer ses modifications locales vers le dépôt GitHub. pull : rapatrier les modifications que les autres utilisateurs ont appliqué dans le dépôt GitHub vers sa propre version locale. Ceci n’est qu’une explication très succincte. Vous trouverez plus de détails dans les liens ci-dessous et dans les Appendices. Il est, par exemple, possible de travailler sur une version en parallèle d’un dépôt original pour lequel on n’a pas de droits en écriture. Dans ce cas, il faudra faire une copie dans notre propre compte GitHub du dépôt. Cela s’appelle faire un fork. Il n’est pas possible de faire un push vers le dépôt d’origine puisqu’on n’a pas les droits en écriture. Dans ce cas, on fera un pull request, suggérant ainsi à l’auteur d’origine que nous avons fait des modifications qui pourraient l’intéresser. Si c’est effectivement le cas, il pourra accepter notre “pull request” et intégrer nos suggestions dans le dépôt d’origine. Vous serez amenés à “forker” des dépôts GitHub pour vos exercices, et vous effectuerez également un “pull request” lorsque vous serez suffisamment aguéris avec les autres techniques de gestion de vos projets sous Git et GitHub. 1.2.4.2.1 Pour en savoir plus Gérez vos codes sources avec Git. Explication en français sur l’utilisation de Git. Quel logiciel de gestion de versions devriez-vous utiliser ?. Explication en français sur l’utilisation des logiciels de gestion de versions. Git : comprendre la gestion de versions. Explication en français sur ce qu’est Git et comment cela s’utilise en pratique. Introduction en anglais de GitHub dans RStudio à l’aide d’une vidéo. Happy Git and GitHub for the useR. Complet, mais un peu technique et en anglais. Installation et première utilisation de Git et GitHub dans R. En anglais. Git. Site en anglais comprendant toute la documentation de Git. GitHub pour les nuls : pas de panique, lancez-vous !. 1.2.4.3 GitHub Classroom GitHub Classroom est une extension de GitHub qui facilite le travail avec GitHub dans le contexte d’exercices à réaliser dans le cadre d’un cours. Vous serez amené à clôner et modifier des dépots issus de GitHub ClassRoom pour réaliser vos exercices. Ces dépôts seront privés. Cela signifique que, seuls vous-mêmes et vos enseignants auront accès à ces dépôts. A la fin de la formation, tous ces dépôts seront détruits. Donc, si vous voulez les conserver, il faudra les “forker” sur votre propre compte. Rassurez-vous : nous vous préviendrons avant de faire le ménage ! Maintenant que vous comprenez mieux avec quels outils informatiques nous allons travaillez, vous pouvez passer à votre premier exercice pour découvrir la SciViews Box, RStudio, Markdown, Git et GitHub : vous allez réaliser un site web professionnel en ligne… "],
["site.html", "1.3 Site web professionnel", " 1.3 Site web professionnel De nos jours, un nombre important de données sont collectées via notre activité sur le web. A la fin de vos études, vous serez amenés à rechercher un travail (dans le milieu de la recherche universitaire, dans la recherche en entreprise, dans les métiers de l’éco-conseils, dans l’industrie, etc.). Tous les recruteurs utilisent actuellement les données que l’on a semé sur le net afin de réaliser un profil détaillé sur nous. Il est donc de votre intérêt d’avoir le meilleur profil possible sur Internet… et qu’il apparaisse comme à la fois sérieux, dynamique et professionnel. Nous allons vous y aider ! Les réseaux sociaux sont une mine d’or sur nos habitudes de vie comme Facebook, Twitter ou encore Instagram. On peut parler de l’image numérique d’une personne. Afin de mettre l’accent sur les compétences professionnelles, de plus en plus de personnes utilisent des réseaux dédiés comme LinkedIn ou encore, ont recours à un site web personnel professionel (par exemple : http://phgrosjean.sciviews.org/, http://www.guyliann.be/). Dans le cadre de ce premier module, vous allez réaliser votre premier site web professionnel (contenant également une section “blog” que vous pourrez alimenter, entre autres, avec vos considérations concernant vos cours, les analyse de données, et autres, …). Ce site sera immédiatement disponible sur le web et ce, de manière entièrement gratuite ! Afin de mener à bien ce premier projet, divers outils vous seront nécessaires. Ces outils seront complétés plus tard par d’autres pour que vous ayez une boite à outils complète pour vos futures analyses de données dans un contexte professionnel. 1.3.1 A vous de jouer Maintenant que vous avez appréhendé les différents outils, lancez vous dans la création de votre site web professionnel via l’addresse suivante : https://github.com/BioDataScience-Course/blogdown.source. Les instructions détaillées sont dans le fichier README.md sur ce dépôt. "],
["visu1.html", "Module 2 Visualisation I", " Module 2 Visualisation I Objectifs Découvrir –et vous émerveiller de– ce que l’on peut faire avec le logiciel R (R Core Team 2018) Savoir réaliser différentes variantes d’un graphique en nuage de points dans R avec la fonction chart() Découvrir le format R Markdown (Allaire et al. 2018) et la recherche reproductible Intégrer ensuite des graphiques dans un rapport et y décrire ce que que vous observez Comparer de manière critique un workflow ‘classique’ en biologie utilisant Microsoft Excel et Word avec une approche utilisant R et R Markdown ; Prendre conscience de l’énorme potentiel de R Prérequis Si ce n’est déjà fait, vous devez installer et vous familiariser avec la ‘SciViews Box’, RStudio, Markdown. Vous devez aussi maîtriser les bases de Git et de GitHub (avoir un compte GitHub, savoir clôner un dépôt localement, travailler avec GitHub Desktop pour faire ses “commits”, “push” et “pull”). L’ensemble de ces outils a été abordé lors de la création de votre site personnel professionnel du module 1. Avant de poursuivre, vous allez devoir découvrir les premiers rudiments de R afin de pouvoir réaliser par la suite vos premiers graphiques. Pour cela, vous aurez à lire attentivement et effectuer tous les exercices de deux tutoriels2. Démarrez la SciViews Box et RStudio. Dans la fenêtre Console de RStudio, entrez l’instruction suivante suivie de la touche Entrée pour ouvrir le tutoriel concernant les bases de R : BioDataScience::run(&quot;02a_base&quot;) Ensuite, vous pouvez également parcourir le tutoriel qui vous permettra de découvrir R sur base d’une analyse concrète (cliquez dans la fenêtre Console de RStudio et appuyez sur la touche ESC pour reprendre la main dans R à la fin d’un tutoriel) : BioDataScience::run(&quot;02b_decouverte&quot;) (BioDataScience est un package R spécialement développé pour ce cours et que vous avez dû installer lors de la configuration de votre SciViews Box, voir Appendice A.3.3). Références "],
["nuage-de-points.html", "2.1 Nuage de points", " 2.1 Nuage de points Dès que vous vous sentez familiarisé avec les principes de base de R, vous allez pouvoir réaliser assez rapidement des beaux graphiques. Par exemple, si vous souhaitez représenter une variable numérique en fonction d’une autre variable numérique, vous pouvez exprimer cela sous la forme d’une formule3 \\[y \\sim x\\] que l’on peut lire “y en fonction de x”. Pour les deux variables numériques x et y, la représentation graphique la plus classique est le nuage de points (voir Fig. 2.1 pour un exemple). Figure 2.1: Exemple de graphique en nuage de points. Des éléments essentiels sont ici mis en évidence en couleurs (voir texte). Les éléments indispensables à la compréhension d’un graphique en nuage de points sont mis en évidence à la Fig. 2.1 : Les axes avec les graduations (en rouge), les labels et les unités des axes (en bleu). Les instructions dans R pour produire un tel nuage de point sont : # Chargement de SciViews::R SciViews::R # Importation du jeu de données (urchin &lt;- read(&quot;urchin_bio&quot;, package = &quot;data.io&quot;, lang = &quot;fr&quot;)) # # A tibble: 421 x 19 # origin diameter1 diameter2 height buoyant_weight weight solid_parts # &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 Fishe… 9.9 10.2 5 NA 0.522 0.478 # 2 Fishe… 10.5 10.6 5.7 NA 0.642 0.589 # 3 Fishe… 10.8 10.8 5.2 NA 0.734 0.677 # 4 Fishe… 9.6 9.3 4.6 NA 0.370 0.344 # 5 Fishe… 10.4 10.7 4.8 NA 0.610 0.559 # 6 Fishe… 10.5 11.1 5 NA 0.610 0.551 # 7 Fishe… 11 11 5.2 NA 0.672 0.605 # 8 Fishe… 11.1 11.2 5.7 NA 0.703 0.628 # 9 Fishe… 9.4 9.2 4.6 NA 0.413 0.375 # 10 Fishe… 10.1 9.5 4.7 NA 0.449 0.398 # # ... with 411 more rows, and 12 more variables: integuments &lt;dbl&gt;, # # dry_integuments &lt;dbl&gt;, digestive_tract &lt;dbl&gt;, # # dry_digestive_tract &lt;dbl&gt;, gonads &lt;dbl&gt;, dry_gonads &lt;dbl&gt;, # # skeleton &lt;dbl&gt;, lantern &lt;dbl&gt;, test &lt;dbl&gt;, spines &lt;dbl&gt;, # # maturity &lt;int&gt;, sex &lt;fct&gt; # Réalisation du graphique chart(data = urchin, height ~ weight) + geom_point() Figure 2.2: Taille (hauteur du test) d’oursins en fonction de leur masse. La fonction chart() n’est pas accessible dans R de base, mais l’extension chargée via l’instruction SciViews::R rend cette fonction disponible. Elle requiert comme argument le jeu de donnée (data = urchin, c’est un objet dataframe ou tibble dans le langage de R), ainsi que la formule à employer dans laquelle vous avez indiqué le nom des variables que vous voulez sur l’axe des ordonnées à gauche et des abscisses à droite de la formule, les deux membres étant séparés par un “tilde” (~). Vous voyez que le jeu de données contient beaucoup de variables (les titres des colonnes du tableau en sortie). Parmi toutes ces variables, nous avons choisi ici de représenter height en fonction de weight, la hauteur en fonction de la masse des oursins. Jusqu’ici, nous avons spécifié ce que nous voulons représenter, mais pas encore comment (sous quelle apparence), nous voulons les matérialiser sur le graphique. Pour un nuage de points, nous voulons les représenter sous forme de … points ! Donc, nous devons ajouter la fonction geom_point() pour indiquer cela. 2.1.1 Le nuage de points en vidéo Vous trouverez une vidéo ci-dessous vous expliquant la création du nuage de points dans R sur ce jeu de données, en analysant d’autres variables. Cette vidéo ne vous a montré que les principaux outils disponibles lors de la réalisation de graphiques. Soyez curieux et expérimentez par vous-même ! 2.1.2 A vous de jouer ! Dans la fenêtre Console de RStudio, entrez l’instruction suivante suivie de la touche Entrée pour ouvrir le tutoriel concernant le nuage de points : BioDataScience::run(&quot;02c_nuage_de_points&quot;) N’oubliez pas d’appuyer sur la touche ESC pour reprendre la main dans R à la fin d’un tutoriel) 2.1.3 Pièges et Astuces 2.1.3.1 Modifications des échelles d’un graphiques Vous devez être vigilant lors de la réalisation d’un nuage de point particulièrement sur l’étendue des valeurs présentées sur vos axes. Vous devez utilisez votre expertise de biologiste pour vous posez les deux questions suivantes : Est ce que l’axe représente des valeurs plausibles de hauteurs et de masses de ces oursins appartenant à l’espèce Paracentrotus lividus ? Quels est la précision des mesures effectuées ? Dans certains cas, la forme du nuage de points peut être distendu par la présence de valeurs aberrantes. Ce n’est pas le cas ici, mais nous pouvons le simuler en distandant artificiellement soit l’axe X, soit l’axe Y, soit les deux : Figure 2.3: Piège du nuage de points. A) graphique initial montrant la variation de la hauteur [mm] en fonction de la masse [g]. B) graphique A avec la modification de l’échelle de l’axe X. C) Graphique A avec une seconde modification de l’axe X. D) Graphique A avec modification simultanée des deux axes. 2.1.3.2 Transformation des données Vous avez la possibilité d’appliquer une transformation de vos données (il est même conseillé de le faire) afin qu’elles soient plus facilement analysables. Par exemple, il est possible d’utiliser des fonctions de puissance, racines, logarithmes, exponentielles4 pour modifier l’apparence du nuage de points dans le but de le rendre plus linéaire (car il est plus facile d’analyser statistiquement des données qui s’alignent le long d’une droite). Par exemple, sur nos données de hauteurs et masses d’oursins, la transformation double-log (log(x) et log(Y)) fonctionne très bien pour rendre le nuage de points plus linéaire : # Réalisation du graphique de la hauteur en fonction de la masse a &lt;- chart(urchin, height ~ weight) + geom_point() # Application du logarithme sur les deux variables représentées b &lt;- chart(urchin, log10(height) ~ log10(weight)) + geom_point() + labs(x = &quot;log(Masse totale [g])&quot;, y = &quot;log(Hauteur du test [mm])&quot;) # Assemblage des graphiques combine_charts(list(a, b)) Figure 2.4: A) Hauteur [mm] en fonction de la masse [g] d’oursins violets. B) Logarithme en base 10 de la hauteur [mm] en fonction du logarithme en base 10 de la masse [g] de ces mêmes oursins. 2.1.3.3 Utilisation des snippets RStudio permet de récupérer rapidement des instructions à partir d’une banque de solutions toutes prêtes. Cela s’appelle des snippets. Vous avez une série de snippets disponibles dans la SciViews Box. Celui qui vous permet de réaliser un graphique en nuage de points s’appelle .cbxy (pour chart -&gt; bivariate -&gt; xy-plot). Entrez ce code et appuyez ensuite sur la tabulation dans un script R, et vous verrez le code remplacé par ceci dans la fenêtre d’édition : chart(data = DF, YNUM ~ XNUM) + geom_point() Vous avez à votre disposition un ensemble de snippets que vous pouvez retrouver dans l’aide-mémoire consacré à SciViews. Vous avez également à votre disposition l’aide-mémoire sur la visualisation des données (Data Visualization Cheat Sheet) qui utilise la fonction ggplot() plutôt que chart() et une interface légèrement différente pour spécifier les variables à utiliser pour réaliser le graphique (`aes(x = …, y = …)). 2.1.4 A vous de jouer ! Une nouvelle tâche va vous être demandée ci-dessous en utilisant GitHub Classroom 1.2.4.3. Cette tâche est un travail individuel. Une fois votre assignation réalisée, faites un clône local de votre dépôt et placez-le dans le sous-dossier projects de votre dossier partagé avec la SciViews Box shared. Vous aurez alors un nouveau projet RStudio B.1.1 Les instructions R que vous expérimentées dans un learnR peuvent être employées également dans un script d’analyse. Sur base du jeu de données urchin_bio, explorez différents graphiques en nuages de points. Utilisez l’URL suivante pour accéder à votre tâche : https://classroom.github.com/a/eYrXLy_u Inspirez-vous du script dans le dépôt sdd1_iris. Vous devez commencer par faire un “fork” du dépôt, puis un clône sur votre ordinateur en local pour pouvoir l’utiliser. https://github.com/BioDataScience-Course/sdd1_iris Prêtez une attention toute particulière à l’organisation d’un script R. En plus des instructions R, il contient aussi sous forme de commentaires, un titre , la date de la dernière mise à jour, le nom de l’auteur, et des sections qui organisent de façon claire le contenu du script. A ce sujet, vous trouverez des explications détaillées concernant l’utilisation des scripts R dans l’annexe B.1.2. 2.1.5 Pour en savoir plus… Visualisation des données dans R for Data Science. Chapitre du livre portant sur la visualisation des données, en anglais. ggplot2 nuage de point. Tutoriel en français portant sur l’utilisation d’un nuage de points avec le package ggplot2 et la fonction geom_point(). Fundamentals of Data Visualization. Un livre en anglais sur les fondamentaux de la visualisation graphique. R Graphics Cookbook - Chapter 5: Scatter Plots. Un chapitre d’un livre en anglais sur l’utilisation du nuage de points. geom_point(). La fiche technique de la fonction (en anglais). 2.1.6 Testez vos acquis ! Dans la fenêtre Console de RStudio, entrez l’instruction suivante et puis appuyez sur la touche Entrée pour ouvrir le tutoriel de challenge concernant le nuage de points : BioDataScience::run(&quot;02d_np_challenge&quot;) N’oubliez pas de vous enregistrer (login GitHub et email UMONS) au début, et d’appuyer sur la touche ESC pour reprendre la main dans R à la fin d’un tutoriel. Dans R, une formule permet de spécifier les variables avec lesquelles on souhaite travailler, et leur rôle. Par exemple ici, la variable x sur l’axe des abscisses et la variable y sur l’axe des ordonnées.↩ Pour les proportions (prop) ou les pourcentages (perc) (valeurs bornées entre 0 et 1 ou 0 et 100%) la transformation arcsin est souvent utilisée : \\(prop′ = \\arcsin \\sqrt{prop}\\) ou \\(perc′ = \\arcsin \\sqrt{perc / 100}\\).↩ "],
["graphiques-dans-r-markdown.html", "2.2 Graphiques dans R Markdown", " 2.2 Graphiques dans R Markdown Un fichier R Markdown est un fichier avec une extension .Rmd. Il permet de combiner le langage Markdown que vous avez déjà abordé au premier module avec du code R, tel que celui utilisé dans la première partie de ce module 2. Des explications détaillées se trouvent dans l’annexe B.1.3 dédiée au R Markdown. De plus, l’écriture d’un rapport d’analyse scientifique doit respecter certaines conventions. Vous trouverez des explications à ce sujet dans l’annexe D. 2.2.1 Pour en savoir plus… What is R Markdown?. Vidéo en anglais + site présentant les différentes possibilités, par les concepteurs de R Markdown (RStudio). Introduction to R Markdown. Tutoriel en anglais, par RStudio. Aide-mémoire R Markdown: dans les menus de RStudio : Help -&gt; Cheatsheets -&gt; R Markdown Cheat Sheet Référence rapide à Markdown : dans les menus RStudio Help -&gt; Markdown Quick Reference Introduction à R Markdown. Présentation en français par Agrocampus Ouest - Rennes. Le langage R Markdown. Introduction en français concise, mais relativement complète. Reproducible reports with R Markdown. Une explication en anglais de la raison d’être de R Markdown. 2.2.2 A vous de jouer ! Utilisation de R Notebook, un type de document R Markdown flexible et particulièrement bien adapté pour construire de manière interactive son analyse en même temps que le rapport associé. Employez le projet sdd1_urchin_bio que vous avez obtenu via le lien GitHub Classroom dans la première partie de ce module. Votre objectif est de comprendre les données proposées, en utilisant des visualisations graphiques appropriées et en documentant le fruit de votre étude dans un rapport R Notebook. Utilisez le graphique en nuage de points que vous venez d’étudier, bien sûr, mais vous êtes aussi encouragés à expérimenter d’autres formes de visualisations graphiques. Workflow “classique” en biologie (Microsoft Excel et Word) comparé à R et R Markdown. Une nouvelle tâche va vous être demandée ci-dessous en utilisant GitHub Classroom 1.2.4.3. Cette tâche est un travail en équipe. Une fois votre assignation réalisée, faites un clône de votre dépôt et placez-le dans le dossier shared/projects. Comparez le workflow classique en biologie via Microsoft Office avec l’utilisation de R - R Markdown en suivant les explications dans le fichier README.mddu dépôt accessible depuis : https://classroom.github.com/g/2Cii2dws "],
["visu2.html", "Module 3 Visualisation II", " Module 3 Visualisation II Objectifs Savoir réaliser différentes variantes de graphiques visant à montrer comment les données se distribuent tel que les histogrammes, les graphes de densité ou encore les diagrammes en violon dans R avec la fonction chart() Intégrer ensuite des graphiques dans un rapport et y décrire ce que vous observez Gérer des conflits dans GitHub Préparatifs Une nouvelle tâche va vous être demandée ci-dessous en utilisant GitHub Classroom 1.2.4.3. Une fois votre assignation réalisée, faites un clône de votre dépôt et placez-le dans le dossier shared/projects. Pour cette tâche, vous démarrerez d’un projet RStudio B.1.1 qui se trouve dans le dépôt. Un projet sur le zooplancton provenant de Madagascar est mis à votre disposition. Utilisez l’URL suivante qui va vous donner accès à votre tâche. Cette tache est un travail en binome https://classroom.github.com/g/7Ji4Aj9G Vous utiliserez à la fois votre projet sur la biométrie des oursins (du module précédent) et ce nouveau projet sur le zooplancton5 pour découvrir les nouveaux outils graphiques décrits dans ce module. Prérequis Pour réaliser les exercices dans ce module, vous devez être capables de travailler dans la SciViews Box et dans RStudio. Vous devez également maîtriser les bases de Git et GitHub. Tout ceci est enseigné dans le module 1. Vous devez également être familiés avec les graphiques dans R et R Markdown, une matière qui fait l’objet du module 2. Le mot zooplancton ne se décline jamais au pluriel. On parle du zooplancton pour désigner une large communauté d’organismes zooplanctoniques, et non pas des zooplanctons.↩ "],
["histogramme.html", "3.1 Histogramme", " 3.1 Histogramme Lors d’une expérience vous souhaitez visualiser la façon dont vos données s’étalent sur un axe (on parle de distribution6 en statistique) pour l’une des variables étudiées. L’histogramme est l’un des outils pouvant vous apporter cette information. Ce graphique va découper en plusieurs classes7 une variable numérique. Figure 2.2: Exemple d’histogramme montrant la distribution de la taille d’un échantillon de zooplancton. Outre l’histogramme lui-même, représenté par des barres de hauteur équivalentes au nombre de fois que les observations ont été réalisées dans les différentes classes, les éléments suivants sont également indispensables à la compréhension du graphique (ici mis en évidence en couleur) Les axes avec les graduations (en rouge). Su l’axe des abscisses, les classes de tailles, et sur l’axe des ordonnées, le nombre d’occurence les labels des axes et l’unité (pour l’axe des abscisses uniquement ici) (en bleu) Les instructions dans R afin de produire un histogramme à l’aide de la fonction chart() sont : # Importation du jeu de données (zooplankton &lt;- read(&quot;zooplankton&quot;, package = &quot;data.io&quot;, lang = &quot;fr&quot;)) # # A tibble: 1,262 x 20 # ecd area perimeter feret major minor mean mode min max std_dev # &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 0.770 0.465 4.45 1.32 1.16 0.509 0.363 0.036 0.004 0.908 0.231 # 2 0.700 0.385 2.32 0.728 0.713 0.688 0.361 0.492 0.024 0.676 0.183 # 3 0.815 0.521 4.15 1.33 1.11 0.598 0.308 0.032 0.008 0.696 0.204 # 4 0.785 0.484 4.44 1.78 1.56 0.394 0.332 0.036 0.004 0.728 0.218 # 5 0.361 0.103 1.71 0.739 0.694 0.188 0.153 0.016 0.008 0.452 0.110 # 6 0.832 0.544 5.27 1.66 1.36 0.511 0.371 0.02 0.004 0.844 0.268 # 7 1.23 1.20 15.7 3.92 1.37 1.11 0.217 0.012 0.004 0.784 0.214 # 8 0.620 0.302 3.98 1.19 1.04 0.370 0.316 0.012 0.004 0.756 0.246 # 9 1.19 1.12 15.3 3.85 1.34 1.06 0.176 0.012 0.004 0.728 0.172 # 10 1.04 0.856 7.60 1.89 1.66 0.656 0.404 0.044 0.004 0.88 0.264 # # ... with 1,252 more rows, and 9 more variables: range &lt;dbl&gt;, size &lt;dbl&gt;, # # aspect &lt;dbl&gt;, elongation &lt;dbl&gt;, compactness &lt;dbl&gt;, transparency &lt;dbl&gt;, # # circularity &lt;dbl&gt;, density &lt;dbl&gt;, class &lt;fct&gt; # Réalisation du graphique chart(data = zooplankton, ~ size) + geom_histogram(bins = 50) Figure 3.1: Distribution des tailles au sein d’un échantillon de zooplancton # bins permet de préciser le nombre de classes souhaitées La fonction chart() requiert comme argument le jeu de donnée (zooplankton), ainsi que la formule à employer dans laquelle vous avez indiqué le nom de la variable que vous voulez sur l’axe des abscisses à droite de la formule, après le tilde ~. Vous voyez que le jeu de données contient beaucoup de variables (les titres des colonnes du tableau en sortie). Parmi toutes ces variables, nous avons choisi ici de représenter size, Jusqu’ici, nous avons spécifié ce que nous voulons représenter, mais pas encore comment (sous quelle apparence), nous voulons matérialiser cela sur le graphique. Pour un histogramme, nous devons ajouter la fonction geom_histogram(). L’argument bins dans cette fonction permet de préciser le nombre de classes souhaitées. Le découpage en classe se fait automatiquement dans R à partir de la variable size d’origine. Vous pouvez décrypter votre histogramme sur base des modes8 et de la symétrie9 de ces derniers. Un histogramme peut être unimodal (un seul mode), bimodal (deux modes) ou multimodal (plus de deux modes). En général, s’il y a plus d’un mode, nous pouvons suspecter que des sous-populations existent au sein de notre échantillon. Figure 3.2: Histogrammes montrant les modes et symétries : A. histogramme unimodal et symétrique, B. histogramme bimodal et asymétrique, C. histogramme unimodal et asymétrique, D. histogramme multimodal et symétrique. 3.1.1 Pièges et astuces 3.1.1.1 Nombres de classes d’un histogramme Vous devez être particulièrement vigilant lors de la réalisation d’un histogramme aux classes de ce dernier. # Réalisation du graphique précédent a &lt;- chart(data = zooplankton, ~ size) + geom_histogram(bins = 50) # Modification du nombre de classes b &lt;- chart(data = zooplankton, ~ size) + geom_histogram(bins = 20) c &lt;- chart(data = zooplankton, ~ size) + geom_histogram(bins = 10) d &lt;- chart(data = zooplankton, ~ size) + geom_histogram(bins = 5) # Assemblage des graphiques combine_charts(list(a, b, c, d)) Figure 3.3: Piège de l’histogramme. A. histogramme initial montrant la répartition des tailles au sein d’organismes planctoniques. B., C., D. Même histogramme que A, mais en modifiant le nombres de classes. Comme vous pouvez le voir à la Fig. 3.3, le changement du nombre de classes peut modifier complètement la perception des données via l’histogramme. Le choix idéal est un compromis entre plus de classes (donc plus de détails), et un d“coupage raisonnable en fonction de la quantité de données disponibles. Si l’intervalle des classes est trop petit, l’histogramme sera illisible. Si l’intervalle des classes est trop grand, il sera impossible de visualiser correctement les différents modes. Dans la figure en exemple, les variantes A et B sont acceptables, mais les C et D manquent de détails. 3.1.1.2 Utilisation des snippets La SciViews Box propose un snippet RStudio pour réaliser un histogramme. Il s’appelle .cuhist (pour chart -&gt; univariate -&gt; histogram). Entrez ce code dans une zone d’édition R et appuyez ensuite sur la tabulation, et vous verrez le code remplacé par ceci : chart(data = DF, ~VARNUM) + geom_histogram(binwidth = 30) L’argument binwidth = permet de préciser la largeur des classes. C’est une autre façon de spécifier le découpage en classes, mais vous pouvez naturellement le remplacer par l’argument bins = si vous préférez. Vous avez à votre disposition un ensemble de snippets que vous pouvez retrouver dans l’aide-mémoire sur SciViews. N’oubliez pas que vous avez également à votre disposition l’aide-mémoire sur la visualisation des données (Data Visualization Cheat Sheet), via la fonction ggplot(). 3.1.1.3 Histogramme par facteur Lors de l’analyse de jeux de données, vous serez amené à réaliser un histogramme par facteur (c’est-à-dire, en fonction de différents niveau d’une variable représentant des groupes). Par exemple, dans un jeu de données sur des fleurs d’iris, la variable species représente l’espèce d’iris étudiée (trois espèces différentes : I. setosa, I. versicolor et I. virginica). # Importation du jeu de données (iris &lt;- read(&quot;iris&quot;, package = &quot;datasets&quot;, lang = &quot;fr&quot;)) # # A tibble: 150 x 5 # sepal_length sepal_width petal_length petal_width species # &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; # 1 5.1 3.5 1.4 0.2 setosa # 2 4.9 3 1.4 0.2 setosa # 3 4.7 3.2 1.3 0.2 setosa # 4 4.6 3.1 1.5 0.2 setosa # 5 5 3.6 1.4 0.2 setosa # 6 5.4 3.9 1.7 0.4 setosa # 7 4.6 3.4 1.4 0.3 setosa # 8 5 3.4 1.5 0.2 setosa # 9 4.4 2.9 1.4 0.2 setosa # 10 4.9 3.1 1.5 0.1 setosa # # ... with 140 more rows # Réalisation de l&#39;histogramme par facteur chart(data = iris, ~ sepal_length %fill=% species) + geom_histogram(bins = 25) + ylab(&quot;Occurences&quot;) + scale_fill_viridis_d() # palette de couleur harmonieuse Figure 2.3: Distribution des longueurs de sépales de trois espèces d’iris. Ici, nous avons tracé un histogramme unique, mais en prenant soin de colorier les barres en fonction de l’espèce. la formule fait toujours intervenir la variable numérique à découper en classes à la droite du tilde ~, ici sepal_length, mais nous y avons ajouté une directive supplémentaire pour indiquer que le remplissage des barres (%fill=%) doit se faire en fonction du contenu de la variable species. Nous avons ici un bon exemple d’histogramme multimodal lié à la présence de trois sous-groupes (les trois espèces différentes) au sein d’un jeu de données unique. Le rendu du graphique n’est pas optimal. Voici deux astuces pour l’améliorer. La premières consiste à représenter trois histogrammes séparés, mais rassemblés dans une même figure. Pour cela, nous utilisons des facettes (facets) au lieu de l’argument %fill=%. Dans chart(), les facettes peuvent être spécifiées an utilisant l’opérateur | dans la formule. chart(data = iris, ~ sepal_length | species) + geom_histogram(bins = 25) + ylab(&quot;Occurences&quot;) Figure 2.4: Distribution de la longueur des sépales de trois espèces d’iris (en employant les facettes pour séparer les espèces). L’histogramme est maintenant séparé en trois en fonction des niveaux de la variable facteur species. Cela rend la lecture plus aisée. Une seconde solution combine les facettes avec | et l’argument %fill=%10. Il faut ensuite ajouter par derriere un histogramme grisé de l’ensemble des données. nbins &lt;- 25 chart(data = iris, ~ sepal_length %fill=% species | species) + # histogramme d&#39;arrière plan en gris ne tenant pas compte de la variable species geom_histogram(data = select(iris, -species), fill = &quot;grey&quot;, bins = nbins) + geom_histogram(show.legend = FALSE, bins = nbins) + ylab(&quot;Occurences&quot;) + scale_fill_viridis_d() Figure 3.4: Distribution des longueurs de sépales de trois espèces d’iris (avec facettes et histogrammes complets grisés en arrière plans). Vous découvrez sans doute que les graphiques réalisables avec R sont modulables à souhait en ajoutant une série d’instructions successives qui créent autant de couches superposées dans le graphique. Cette approche permet de réaliser quasiment une infinité de graphiques différents en combinant seulement quelques dizaines d’instructions. Pour s’y retrouver, les fonctions qui ajoutent des couches commencent toutes par geom_, et celles qui manipulent les couleurs par scale_, par exemple. Vous découvrirez encore d’autres fonctions graphiques plus loin. La distribution des données en statistique se réfère à la fréquence avec laquelle les différentes valeurs d’une variable s’observent.↩ Une variable numérique est découpée en classes en spécifiant différents intervalles, et ensuite en dénombrant le nombre de fois que les observations rentrent dans ces classes.↩ Les modes d’un histogramme correspondent à des classes plus abondantes localement, c’est-à-dire que les classes à gauche et à droite du mode comptent moins d’occurences que lui.↩ Un histogramme est dit symétrique lorsque son profil à gauche est identique ou très similaire à son profil à droite autour d’un mode.↩ Astuce proposée ici.↩ "],
["graphique-de-densite.html", "3.2 Graphique de densité", " 3.2 Graphique de densité L’histogramme n’est pas le seul outil à votre disposition. Vous pouvez également employer le graphique de densité qui se présente un peu comme un histogramme lissé. Le passage d’un histogramme vers un graphe de densité se base sur une estimation par noyaux gaussien11 Figure 3.5: A. Histogramme et B. graphique de densité montrant la distribution de la taille de zooplancton étudié par analyse d’image. Comme pour les autres graphiques, veuillez à soigner les indications qui permettent d’interpréter le graphique. Outre la courbe de densité, il faut : Les axes avec les graduations (en rouge) les labels des axes, et l’unité pour l’axe des abscisses (en bleu) Les instructions en R pour produire un graphique de densité avec la fonction chart() sont : # Importation du jeu de données (zooplankton &lt;- read(&quot;zooplankton&quot;, package = &quot;data.io&quot;, lang = &quot;fr&quot;)) # # A tibble: 1,262 x 20 # ecd area perimeter feret major minor mean mode min max std_dev # &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 0.770 0.465 4.45 1.32 1.16 0.509 0.363 0.036 0.004 0.908 0.231 # 2 0.700 0.385 2.32 0.728 0.713 0.688 0.361 0.492 0.024 0.676 0.183 # 3 0.815 0.521 4.15 1.33 1.11 0.598 0.308 0.032 0.008 0.696 0.204 # 4 0.785 0.484 4.44 1.78 1.56 0.394 0.332 0.036 0.004 0.728 0.218 # 5 0.361 0.103 1.71 0.739 0.694 0.188 0.153 0.016 0.008 0.452 0.110 # 6 0.832 0.544 5.27 1.66 1.36 0.511 0.371 0.02 0.004 0.844 0.268 # 7 1.23 1.20 15.7 3.92 1.37 1.11 0.217 0.012 0.004 0.784 0.214 # 8 0.620 0.302 3.98 1.19 1.04 0.370 0.316 0.012 0.004 0.756 0.246 # 9 1.19 1.12 15.3 3.85 1.34 1.06 0.176 0.012 0.004 0.728 0.172 # 10 1.04 0.856 7.60 1.89 1.66 0.656 0.404 0.044 0.004 0.88 0.264 # # ... with 1,252 more rows, and 9 more variables: range &lt;dbl&gt;, size &lt;dbl&gt;, # # aspect &lt;dbl&gt;, elongation &lt;dbl&gt;, compactness &lt;dbl&gt;, transparency &lt;dbl&gt;, # # circularity &lt;dbl&gt;, density &lt;dbl&gt;, class &lt;fct&gt; # Réalisation du graphique chart(data = zooplankton, ~ size) + geom_density() Figure 3.6: Distribution des tailles au sein de l’échantillon de zooplancton. Ici, nous utilisons donc la fonction geom_density(). L’opération effectuée pour passer d’un histogramme à une courbe de densité consiste effectivement à lisser les pics plus ou moins fort dans l’histogramme de départ.↩ "],
["diagramme-en-violon.html", "3.3 Diagramme en violon", " 3.3 Diagramme en violon Le graphique en violon est constitué de deux graphiques de densité en miroir. Le résultat fait penser un peu à un violon pour une distribution bimodale. Cette représentation est visuellement très convainquante lorsque la variable étudiée contient suffisamment d’observations pour permettre de déterminer précisément sa distribution (plusieurs dizaines ou centaines d’individus mesurés). Figure 3.7: Graphe en violon de la distribution de la taille en fonction des groupes taxonomiques dans un échantillon de zooplancton. Les instructions en R pour produire un diagramme en violon à l’aide de la fonction chart() sont : # Importation du jeu de données zooplankton &lt;- read(&quot;zooplankton&quot;, package = &quot;data.io&quot;, lang = &quot;fr&quot;) # Réduction du jeu de données zooplankton_sub &lt;- filter(zooplankton, class %in% c(&quot;Annelid&quot;, &quot;Calanoid&quot;, &quot;Cyclopoid&quot;, &quot;Decapod&quot;)) # Réalisation du graphique chart(data = zooplankton_sub, size ~ class) + geom_violin() Figure 3.8: Distribution des tailles pour 4 groupes taxonomiques de zooplancton. Ici, la formule fournie à chart() indique la variable numérique à représenter par une graphe de densité dans le terme de gauche, et la variable facteur qui découpe l’échantillon en classes à droite : YNUM (size) ~ XFACT (class). Pour réaliser un graphique de densité vous devez ensuite ajouter la fonction geom_violin(). Vous pouvez aussi utiliser %fill=% pour colorer vos différents graphes en fonction de la variable facteur également, comme dans la Fig. 3.7. 3.3.1 Pièges et astuces Parfois, les labels sur l’axe des abscisses d’un diagramme en violon apparaissent trop rapprochés et se chevauchent, comme ci-dessous. chart(data = zooplankton, size ~ class) + geom_violin() Figure 3.9: Distribution de tailles des 17 classes d’organismes planctoniques (diagramme en violon). La fonction coord_flip() permute les axes. Ainsi les labels ne se chevauchent plus sur l’axe des ordonnées. chart(data = zooplankton, size ~ class) + geom_violin() + coord_flip() Figure 3.10: Distribution de tailles des 17 classes d’organismes planctoniques (diagramme en violon avec l’ajout de la fonction coord_flip()). Le package ggridges propose une seconde solution basée sur le principe de graphique de densité avec la fonction geom_density_ridges() qui crée un graphique en lignes de crêtes. Attention : remarquez que la notation est ici inverse du diagramme en violon, soit XFACT (class) ~ YNUM (size) ! chart(data = zooplankton, class ~ size) + ggridges::geom_density_ridges() Figure 3.11: Distribution des tailles des 17 classes d’organismes planctoniques (sous forme de graphique en lignes de crêtes). "],
["a-vous-de-jouer-4.html", "3.4 A vous de jouer !", " 3.4 A vous de jouer ! Reprenez vos différents projets et étudiez la distribution de variables numériques de différentes manières. Terminez ce module en vérifiant que vous avez bien compris les notions apprises jusqu’ici. Ouvrez RStudio dans votre SciViews Box, puis exécutez l’instruction suivante dans la fenêtre console : BioDataScience::run(&quot;03a_test&quot;) "],
["visu3.html", "Module 4 Visualisation III", " Module 4 Visualisation III Objectifs Savoir réaliser différents graphiques pour représenter des variables facteurs comme le graphique en barres, ou le graphique en camembert dans R avec la fonction chart() Comprendre et utiliser la boîte de dispersion pour synthétiser la distribution de données numériques Arranger différents graphiques dans une figure unique Découvrir différents systèmes graphiques (graphiques de base, lattice, ggplot2) et les comparer entre eux Prérequis Assurez-vous de bien maîtriser les notions relatives à la représentation graphiques vues jusqu’ici dans les modules 2 et 3. "],
["graphique-en-barres.html", "4.1 Graphique en barres", " 4.1 Graphique en barres 4.1.1 Dénombrement d’observations par facteur Le graphique en barres est très similaire à l’histogramme, si ce n’est que l’on ne part pas d’une variable numérique découpée en classes, mais d’une variable facteur dont les observations sont donc déjà réparties en un (petit) nombre de classes distinctes. La question du nombre et/ou de l’intervalle des classes ne se pose donc plus ici. Par défaut, les barres seront séparées les unes des autres par un petit espace vide pour bien indiquer visuellement qu’il n’y a pas continuité entre les classes (dans l’histogramme, les barres sont accolées les unes aux autres pour matérialiser justement cette continuité). La formule que vous utiliserez, ici encore, ne fait appel qu’à une seule variable et s’écrira donc : \\[\\sim variable \\ facteur\\] Figure 1.1: Exemple d’un graphique en barres montrant le dénombrement des niveaux d’une variable facteur, avec les éléments importants du graphique mis en évidence en couleurs. Outre les barres elles-mêmes, prêtez toujours attention aux élements suivants du graphique (ici mis en évidence en couleurs) : les axes avec les graduations (en rouge) les niveaux de la variable facteur (en rouge également) le label des axes (en bleu) Les instructions dans R pour produire un graphique en barres à l’aide de la fonction chart() sont : # Importation du jeu de données (zooplankton &lt;- read(&quot;zooplankton&quot;, package = &quot;data.io&quot;, lang = &quot;fr&quot;)) # # A tibble: 1,262 x 20 # ecd area perimeter feret major minor mean mode min max std_dev # &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 0.770 0.465 4.45 1.32 1.16 0.509 0.363 0.036 0.004 0.908 0.231 # 2 0.700 0.385 2.32 0.728 0.713 0.688 0.361 0.492 0.024 0.676 0.183 # 3 0.815 0.521 4.15 1.33 1.11 0.598 0.308 0.032 0.008 0.696 0.204 # 4 0.785 0.484 4.44 1.78 1.56 0.394 0.332 0.036 0.004 0.728 0.218 # 5 0.361 0.103 1.71 0.739 0.694 0.188 0.153 0.016 0.008 0.452 0.110 # 6 0.832 0.544 5.27 1.66 1.36 0.511 0.371 0.02 0.004 0.844 0.268 # 7 1.23 1.20 15.7 3.92 1.37 1.11 0.217 0.012 0.004 0.784 0.214 # 8 0.620 0.302 3.98 1.19 1.04 0.370 0.316 0.012 0.004 0.756 0.246 # 9 1.19 1.12 15.3 3.85 1.34 1.06 0.176 0.012 0.004 0.728 0.172 # 10 1.04 0.856 7.60 1.89 1.66 0.656 0.404 0.044 0.004 0.88 0.264 # # ... with 1,252 more rows, and 9 more variables: range &lt;dbl&gt;, size &lt;dbl&gt;, # # aspect &lt;dbl&gt;, elongation &lt;dbl&gt;, compactness &lt;dbl&gt;, transparency &lt;dbl&gt;, # # circularity &lt;dbl&gt;, density &lt;dbl&gt;, class &lt;fct&gt; # Réduction du jeu de données (copepoda &lt;- filter(zooplankton, class %in% c(&quot;Calanoid&quot;, &quot;Cyclopoid&quot;, &quot;Harpacticoid&quot;, &quot;Poecilostomatoid&quot;))) # # A tibble: 535 x 20 # ecd area perimeter feret major minor mean mode min max std_dev # &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 0.770 0.465 4.45 1.32 1.16 0.509 0.363 0.036 0.004 0.908 0.231 # 2 0.815 0.521 4.15 1.33 1.11 0.598 0.308 0.032 0.008 0.696 0.204 # 3 0.785 0.484 4.44 1.78 1.56 0.394 0.332 0.036 0.004 0.728 0.218 # 4 0.361 0.103 1.71 0.739 0.694 0.188 0.153 0.016 0.008 0.452 0.110 # 5 0.832 0.544 5.27 1.66 1.36 0.511 0.371 0.02 0.004 0.844 0.268 # 6 1.23 1.20 15.7 3.92 1.37 1.11 0.217 0.012 0.004 0.784 0.214 # 7 0.620 0.302 3.98 1.19 1.04 0.370 0.316 0.012 0.004 0.756 0.246 # 8 1.19 1.12 15.3 3.85 1.34 1.06 0.176 0.012 0.004 0.728 0.172 # 9 1.04 0.856 7.60 1.89 1.66 0.656 0.404 0.044 0.004 0.88 0.264 # 10 0.725 0.412 7.14 1.90 0.802 0.655 0.209 0.008 0.004 0.732 0.202 # # ... with 525 more rows, and 9 more variables: range &lt;dbl&gt;, size &lt;dbl&gt;, # # aspect &lt;dbl&gt;, elongation &lt;dbl&gt;, compactness &lt;dbl&gt;, transparency &lt;dbl&gt;, # # circularity &lt;dbl&gt;, density &lt;dbl&gt;, class &lt;fct&gt; # Réalisation du graphique chart(data = copepoda, ~ class) + geom_bar() + ylab(&quot;Dénombrement&quot;) Figure 2.2: Abondances de quatres types de copépodes dans un échantillon de zooplancton. La fonction geom_bar() se charge d’ajouter les barres verticales dans le graphique. La hauteur de ces barres correspond au nombre d’observations rencontrées dans le jeu de données pour chaque niveau (ou classe, ou groupe) de la variable facteur représentée. 4.1.1.1 Dénombrement par plusieurs facteurs # Importation des données biometry (biometry &lt;- read(&quot;biometry&quot;, package = &quot;BioDataScience&quot;, lang = &quot;fr&quot;)) # # A tibble: 395 x 7 # gender day_birth weight height wrist year_measure age # &lt;fct&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 M 1995-03-11 69 182 15 2013 18 # 2 M 1998-04-03 74 190 16 2013 15 # 3 M 1967-04-04 83 185 17.5 2013 46 # 4 M 1994-02-10 60 175 15 2013 19 # 5 W 1990-12-02 48 167 14 2013 23 # 6 W 1994-07-15 52 179 14 2013 19 # 7 W 1971-03-03 72 167 15.5 2013 42 # 8 W 1997-06-24 74 180 16 2013 16 # 9 M 1972-10-26 110 189 19 2013 41 # 10 M 1945-03-15 82 160 18 2013 68 # # ... with 385 more rows # Conversion de la variable year_measure de numérique à facteur biometry$year_measure &lt;- as.factor(biometry$year_measure) label(biometry$year_measure) &lt;- &quot;Année de la mesure&quot; Différentes représentations sont possibles pour observer des dénombrements tenant compte de plusieurs variables facteurs. Par défaut, l’argument position = a pour valeur par défaut stack (donc, lorsque cet argument n’est pas précisé dans geom_bar()). a &lt;- chart(data = biometry, ~ gender) + geom_bar() + ylab(&quot;Dénombrement&quot;) b &lt;- chart(data = biometry, ~ gender %fill=% year_measure) + geom_bar() + ylab(&quot;Dénombrement&quot;) + scale_fill_viridis_d() combine_charts(list(a, b), common.legend = TRUE) Figure 3.2: Dénombrement des hommes (M) et des femmes (W) dans l’étude sur l’obésité en Hainaut en tenant compte des années de mesure pour (B). Il existe d’autres options en utilisant la valeur dodge ou fill pour l’argument position =. a &lt;- chart(data = biometry, ~ gender %fill=% year_measure) + geom_bar(position = &quot;stack&quot;) + ylab(&quot;Effectifs&quot;) + scale_fill_viridis_d() b &lt;- chart(data = biometry, ~ gender %fill=% year_measure) + geom_bar(position = &quot;dodge&quot;) + ylab(&quot;Effectifs&quot;) + scale_fill_viridis_d() c &lt;- chart(data = biometry, ~ gender %fill=% year_measure) + geom_bar(position = &quot;fill&quot;) + ylab(&quot;Fractions&quot;) + scale_fill_viridis_d() combine_charts(list(a, b, c), common.legend = TRUE) Figure 2.3: Dénombrement des hommes (M) et des femmes (W) dans l’étude sur l’obésité en Hainaut en tenant compte des années de mesure (différentes présentations). Soyez vigilant à la différence entre l’argument position = stack et position = fill qui malgré un rendu semblable ont l’axe des ordonnées qui diffère (dans le cas de fill, il s’agit de la fraction par rapport au total qui est représentée, et non pas des effectifs absolus dénombrés). 4.1.1.2 Pièges et Astuces 4.1.1.2.1 Réordonner la variable facteur par fréquence Vous pouvez avoir le souhait d’ordonner votre variable facteur afin d’améliorer le rendu visuel de votre graphique. Pour cela, vous pouvez employer la fonction fct_infreq(). chart(data = copepoda, ~ fct_infreq(class)) + geom_bar() + labs(x = &quot;Classe&quot;, y = &quot;Abondance&quot;) Figure 2.4: Dénombrement des classes de copépodes du jeu de données zooplankton. 4.1.1.2.2 Rotation du graphique en barre Lorsque les niveaux dans la variable étudiée sont trop nombreux, la légende en abscisse risque de se chevaucher, comme dans la Fig. 4.1 chart(data = zooplankton, ~ class) + geom_bar() + ylab(&quot;Dénombrement&quot;) Figure 4.1: Dénombrement des classes du jeu de données zooplankton. Avec la fonction coord_flip() ajoutée à votre graphique, vous pouvez effectuer une rotation des axes pour obtenir un graphique en barres horizontales. De plus, l’oeil humain perçoit plus distinctement les différences de longueurs horizontales que verticales. Donc, de ce point de vue, le graphe en barres horizontal est considéré comme meilleur que le graphe en barres verticales. chart(data = zooplankton, ~ class) + geom_bar() + ylab(&quot;Dénombrement&quot;) + coord_flip() Figure 3.4: Dénombrement des classes du jeu de données zooplankton (version avec barres horizontales). 4.1.1.3 Pour en savoir plus Graphes en barres à l’aide de ggplot2. Un tutoriel en français utilisant la fonction ggplot(). L’annotation des barres est également présentée. Page d’aide de la fonction geom_bar() en anglais. Autres exemples de graphes en barres à l’aide de `ggplot(). 4.1.2 Valeurs moyennes à l’aide d’un graphe en barres Le graphique en barres peut être employé pour résumer des données numériques via la moyenne. Il ne s’agit plus de dénombrer les occurrences d’une variable facteur mais de résumer des données numériques en fonction d’une variable facteur. On peut exprimer cette relation dans R sous la forme de \\[y \\sim x\\] que l’on peut lire : \\[y \\ en \\ fonction \\ de \\ x\\] Avec y une variable numérique et x une variable facteur. Considérez l’échantillon suivant : 1, 71, 55, 68, 78, 60, 83, 120, 82 ,53, 26 Calculez la moyenne sur base de la formule de la moyenne \\[\\overline{y} = \\sum_{i = 1}^n \\frac{y_i}{n}\\] # Création du vecteur x &lt;- c(1, 71, 55, 68, 78, 60, 83, 120, 82, 53, 26) # Calcul de la moyenne mean(x) # [1] 63.36364 Les instructions pour produire ce graphe en barres à l’aide de chart() sont : chart(data = copepoda, size ~ class) + stat_summary(geom = &quot;col&quot;, fun.y = &quot;mean&quot;) Figure 3.6: Exemple de graphique en barres représentant les moyennes de tailles par groupe zooplanctonique. Ici, nous faisons appel à une autre famille de fonctions : celles qui effectuent des calculs sur les données avant de les représenter graphiquement. Le graphe en barres pour représenter les moyennes est très répandu dans le domaine scientifique malgré le grand nombre d’arguments en sa défaveur et que vous pouvez lire dans la section pour en savoir plus ci-dessous. L’un des arguments le plus important est la faible information qu’il véhicule puisque l’ensemble des données n’est plus représentée que par une valeur (la moyenne) pour chaque niveau de la variable facteur. Pour un petit nombre d’observations, il vaut mieux toutes les représenter à l’aide d’un nuage de points. Si le nombre d’observation devient très grand (dizianes ou plus), le graphique en boites de dispersion est plus indiqué (voir plus loin dans ce module). 4.1.2.1 Pour en savoir plus Beware of dynamite. Démonstration de l’impact d’un graphe en barres pour représenter la moyenne (et l’écart type) = graphique en “dynamite”. Dynamite plots : unmitigated evil? Une autre comparaison du graphe en dynamite avec des représentations alternatives qui montre que le premier peut avoir quand même quelques avantages dans des situations particulières. "],
["graphique-en-camembert.html", "4.2 Graphique en camembert", " 4.2 Graphique en camembert Le graphique en camembert va vous permettre de visualiser un dénombrement d’observations par facteur, tout comme le graphique en barres. chart(data = copepoda, ~ factor(0) %fill=% class) + geom_bar(width = 1) + coord_polar(&quot;y&quot;, start = 0) + theme_void() + scale_fill_viridis_d() Figure 3.9: Exemple de graphique en camembert montrant le dénombrement des niveaux d’une variable facteur. Ce graphique est plus difficile à réaliser à l’aide de chart() ou ggplot(). En fait, il faut ruser ici, et l’auteur du package ggplot2 n’avait tout simplement pas l’intention d’ajouter ce type de graphique dans la panoplie proposée. En effet, il faut savoir que l’oeil humain est nettement moins bon pour repérer des angles que pour comparer des longueurs. Donc, le diagramme en barres est souvent meilleur pour comparer des dénombrements par classes. Mais d’une part, le graphique en camembert est (malheureusement) un graphique très répandu et il faut savoir l’interpréter, et d’autre part, il peut s’avérer quand même utile dans certaines situations. Notez l’utilisation de la fonction theme_void() qui crée un graphique sans axes. 4.2.1 Pièges et astuces Partons d’un exemple fictif pour vous convaincre qu’un graphique en barres est souvent plus lisible qu’un graphique en camembert. Combien d’observations comptez-vous pour la lettre h ? Figure 3.11: Arrivez-vous à lire facilement des valeurs sur un graphique en camenbert (une échelle y est ajoutée de manière exceptionnelle pour vous y aider). Maintenant, effectuez le même exercice sur base d’un graphique en barres, combien d’observations pour la lettre h ? Figure 4.2: Dénombrement des niveaux d’une variable facteur sur un graphique en barres. Dans ce dernier cas, c’est bien plus facile : il y a effectivement 24 observations relatives à la lettre h. 4.2.2 Pour en savoir plus Graphique en camembert à l’aide de la fonction ggplot(). Explications en français des différentes étapes pour passer d’un graphique en barres à un graphique en camembert avec ggplot2. Autre explication en français, également accompagnée d’informations sur les bonnes pratiques en matière de graphique en camembert. Save the pies for dessert est une démonstration détaillée des méfaits du graphique en camembert (le graphique en camembert, un graphique puant ? Pourrait-on peut-être titrer en français). Les côtés positifs du graphe en camembert sont mis en évidence dans ce document (en anglais). "],
["boite-de-dispersion.html", "4.3 Boite de dispersion", " 4.3 Boite de dispersion Vous souhaitez représenter graphiquement cette fois un résumé d’une variable numérique mesurée sur un nombre (relativement) important d’individus, soit depuis une dizaine jusqu’à plusieurs millions. Vous souhaitez également conserver de l’information sur la distribution des données, et voulez éventuellement comparer plusieurs distributions entre elles : soit différentes variables, soit différents niveaux d’une variable facteur. Nous avons déjà vu au module 3 les diagrammes en violon et en lignes de crêtes pour cet usage. Nous allons étudier ici les boites de dispersion comme option alternative intéressante. La boite de dispersion va représenter graphiquement cinq descripteurs appelés les cinq nombres. Considérez l’échantillon suivant : 1, 71, 55, 68, 78, 60, 83, 120, 82 ,53, 26 Ordonnez-le de la plus petite à la plus grande valeur : # Créer du vecteur x &lt;- c(1, 71, 55, 68, 78, 60, 83, 120, 82, 53, 26) # Ordonner le vecteur par ordre croissant sort(x) # [1] 1 26 53 55 60 68 71 78 82 83 120 Le premier descripteur des cinq nombres est la médiane qui est la valeur se situant à la moitié des observations, donc, avec autant d’observations plus petites et d’observations plus grande qu’elle. La médiane sépare l’échantillon en deux. median(x) # [1] 68 Les quartiles séparent l’échantillon en quatre. Le premier quartile (Q1) sera la valeur pour laquelle 25% des observations seront plus petites. Elle se situe donc entre la valeur minimale et la médiane. Cette médiane est égale au second quartile (50% des observations plus petites). Le troisième quartile (Q3) est la valeur pour laquelle 75% des observations de l’échantillon sont plus petites12. Enfin, la valeur minimale et la valeur maximale observées dans l’échantillon complètent ces cinq nombres qui décrivent de manière synthétique la position et l’étendue des observations. Les cinq nombres sont : la valeur minimale, le premier quartile, la médiane (ou deuxième quartile), le troisième quartile et la valeur maximale. fivenum(x) # [1] 1 54 68 80 120 La boite de dispersion est une représentation graphique codifiée de ces cinq nombres. La représentation de x sous forme de nuage de points n’est ni très esthétique, ni très lisible, surtout si nous avons affaire à des milliers ou des millions d’observations qui se chevauchent sur le graphique13. Figure 4.3: Nuage de points univarié. La boite de dispersion va remplacer cette représentation peu lisible par un objet géométrique qui représente les cinq nombres. Figure 4.4: A) Nuage de points annoté avec les cinq nombres représentés par des traits horizontaux. B) Boite de dispersion obtenue pour les même données que A. Vous observez à la Fig. 4.4 que certaines valeurs minimales et maximales ne sont pas reliées à la boite de dispersion, il s’agit de valeurs extrêmes. Règle pour déterminer s’il y a des valeurs extrêmes avec une boite de dispersion : une valeur est considérée comme extrême si son écart par rapport à la boite est supérieur à une fois et demi la hauteur de la boite (encore appelée espace inter-quartile correspondant à Q3 - Q1). Les tiges (ou “moustaches”) qui prolongent la boite de dispersion s’arrêtent donc aux dernières valeurs les plus petites et plus grandes, mais qui rentrent encore dans une fois et demi l’IQR. Les valeurs extrêmes sont ensuite représentées individuellement par un point au dessus et en dessous. La boite de dispersion finale ainsi que sa description sont représentées à la Fig. 4.5 ci-dessous. Figure 4.5: A) Boite de dispersion pour x et B) description des différents éléments constitutifs. Les instructions dans R pour produire un graphique en boites de dispersion parallèles (comparaison de la distribution d’une variable numérique pour différents niveaux d’une autre variable facteur) sont : chart(data = copepoda, size ~ class) + geom_boxplot() Figure 4.6: Distribution des tailles par groupes taxonomiques pour le zooplancton. La formule à employer est YNUM (size) ~ XFACTOR (class). Ensuite, pour réaliser une boite de dispersion vous devez ajouter la fonction geom_boxplot(). 4.3.1 Pièges et Astuces 4.3.1.1 Nombre d’observations par boite de dispersion Lors de la réalisation de boites de dispersion, vous devez être vigilant au nombre d’observations qui se cachent sous chacune d’elles. En effet, réaliser une boite de dispersion à partir d’échantillons ne comportant que cinq valeurs ou moins n’a aucun sens ! Figure 4.7: Piège des boites de dispersion : trop peu d’observations disponibles pour a. La boite de dispersion a est calculée à partir de seulement quatre observations. C’est trop peu. Comme les points représentant les observations ne sont habituellement pas superposés à la boite, cela peut passer inaperçu et tromper le lecteur ! Une bonne pratique consiste à ajouter n, le nombre d’observations au-dessus de chaque boite. Cela peut se faire facilement avec les fonctions give_n() et stat_summary() ci-dessous. give_n &lt;- function(x) c(y = max(x) * 1.1, label = length(x)) chart(data = copepoda, size ~ class) + geom_boxplot() + stat_summary(fun.data = give_n, geom = &quot;text&quot;, hjust = 0.5) Figure 4.8: Taille de copépodes pour différents groupes taxonomiques (le nombre d’observations est indiqué au dessus de chaque boite). La Fig. 4.9 présente un graphique en boites de dispersion parallèles qui combine l’usage de deux variables facteurs différentes. # Importation du jeu de données ToothGrowth (tooth_growth &lt;- read(&quot;ToothGrowth&quot;, package = &quot;datasets&quot;)) # # A tibble: 60 x 3 # len supp dose # &lt;dbl&gt; &lt;fct&gt; &lt;dbl&gt; # 1 4.2 VC 0.5 # 2 11.5 VC 0.5 # 3 7.3 VC 0.5 # 4 5.8 VC 0.5 # 5 6.4 VC 0.5 # 6 10 VC 0.5 # 7 11.2 VC 0.5 # 8 11.2 VC 0.5 # 9 5.2 VC 0.5 # 10 7 VC 0.5 # # ... with 50 more rows # Remaniement et labelisation du jeu de données tooth_growth$dose &lt;- as.ordered(tooth_growth$dose) tooth_growth &lt;- labelise(tooth_growth, self = FALSE, label = list( len = &quot;Longueur des dents&quot;, supp = &quot;Supplémentation&quot;, dose = &quot;Dose&quot; ), units = list( len = &quot;mm&quot;, supp = NA, dose = &quot;mg/J&quot; ) ) # Réalisation graphique chart(data = tooth_growth, len ~ supp %fill=% dose) + geom_boxplot() + stat_summary(fun.data = give_n, geom = &quot;text&quot;, hjust = 0.5, position = position_dodge(0.75)) Figure 4.9: Croissance de dents de cochons d’Inde en fonction de la supplémentation (OJ = jus d’orange, VC = vitamine C) et de la dose administrée (n indiqué au dessus de chaque boite). 4.3.2 Pour en savoir plus ! Un tutoriel boites de dispersion à l’aide de ggplot() présentant encore bien d’autres variantes possibles. Box plots in ggplot2. Autre explication en anglais avec sortie utilisant plotly. Grouped box plots. Explication plus détaillée sur les cinq nombres, en anglais. Notez que, lorsque la coupure tombe entre deux observations, une valeur intermédiaire est utilisée. Ici par exemple, le premier quartile est entre 53 et 55, donc, il vaut 54. Le troisième quartile se situe entre 78 et 82. Il vaut donc 80.↩ Il est possible de modifier la transparence des points et/ou de les déplacer légèrement vers la gauche ou vers la droite de manière aléatoire pour résoudre le problème de chevauchement des points sur un graphique en nuage de points univarié.↩ "],
["figures-composees.html", "4.4 Figures composées", " 4.4 Figures composées Il arrive fréquemment de vouloir combiner plusieurs graphiques dans une même figure. Plusieurs fonctions sont à votre disposition pour cela. Il faut tout d’abord distinguer deux types de figures multi-graphiques : Soit il s’agit d’un seul graphique que vous souhaitez subdiviser par rapport à une ou des variables facteurs. Soit il s’agit de graphiques indépendants que vous souhaitez assembler dans une même figure parce que les données ont un lien entre elles, ou parce que ces graphiques sont complémentaires pour comprendre les données. Dans le premier cas, les fonctions facet_XXX() comme facet_grid() peuvent être employées. Dans le second cas, la fonction combine_charts() est l’une des alternatives possibles. 4.4.1 Facettes L’une des règles les plus importantes que vous devez impérativement garder à l’esprit lors de la réalisation de vos graphiques est la simplicité. Plus votre graphique va contenir d’information au plus il sera compliqué à décoder par vos lecteurs. # Importation de données relative à la croissance de poulets (chick_weight &lt;- read(&quot;ChickWeight&quot;, package = &quot;datasets&quot;)) # # A tibble: 578 x 4 # weight Time Chick Diet # &lt;dbl&gt; &lt;dbl&gt; &lt;ord&gt; &lt;fct&gt; # 1 42 0 1 1 # 2 51 2 1 1 # 3 59 4 1 1 # 4 64 6 1 1 # 5 76 8 1 1 # 6 93 10 1 1 # 7 106 12 1 1 # 8 125 14 1 1 # 9 149 16 1 1 # 10 171 18 1 1 # # ... with 568 more rows # Réalisation du graphique (points semi-transparents) chart(data = chick_weight, weight ~ Time %col=% Diet) + geom_point(alpha = 0.5) + labs(x = &quot;Age [j]&quot;, y = &quot;Masse [g]&quot;) Figure 4.10: Croissance de poulets en utilisant quatre aliments différents. Le graphique à la Fig. 4.10 est mal adapté pour montrer les différences entre les quatre aliments : tous les points sont entremélés. Il peut typiquement être simplifié en utilisant des facettes pour représenter les résultats relatifs aux différents régimes alimentaires sur des graphiques séparés. L’information est la même mais la lecture est beaucoup plus aisée. chart(data = chick_weight, weight ~ Time | Diet) + geom_point(alpha = 0.5) + labs(x = &quot;Age [j]&quot;, y = &quot;Masse [g]&quot;) Figure 4.11: Croissance de poulets en utilisant quatre aliments différents (1-4). Vous observez que les échelles en abscisse et en ordonnée sont similaires sur tous les graphiques. Cela permet une meilleure comparaison. Notez toutefois que, plus le nombre de facettes augmente, plus chaque graphique individuel devient petit. Faites attention à ne pas finir avec des graphiques individuels tellement petits qu’ils en deviennent illisibles ! 4.4.2 Graphiques assemblés La fonction combine_charts() permet de combiner plusieurs graphiques dans une figure unique. Nous l’avons déjà utilisée à plusieurs reprises. Cette fonction attend une liste de graphiques de type chart() à assembler. # Importation des données urchin &lt;- read(&quot;urchin_bio&quot;, package = &quot;data.io&quot;, lang = &quot;FR&quot;) # Réalisation des graphiques a &lt;- chart(data = urchin, weight ~ height %col=% origin) + geom_point() b &lt;- chart(data = urchin, weight ~ solid_parts %col=% origin) + geom_point() # Combinaison des graphiques dans une même figure combine_charts(list(a, b), common.legend = TRUE) Figure 4.12: A) Masse d’oursins en fonction de leur taille et de leur origine. B) Masse totale en fonction de la masse des parties solides de ces mêmes oursins. Il existe d’autres fonctions permettant de combiner plusieurs graphiques comme plot_grid() du package cowplot, mais avec combine_charts() vous pourrez déjà faire beaucoup. De plus, un libellé sous forme d’une lettre majuscule est automatiquement associé à chaque sous-région de la figure composée. Cela permet d’y faire plus facilement référence dans le texte et/ou dans la légende. 4.4.2.1 Pour en savoir plus ! Partitionnement des graphiques en facettes. Differentes options sont présentées ici. Figures composées à l’aide de grid.arrange(). Une autre option, mais moins flexible et moins riche que combine_charts(). Figures composées à l’aide de plot_grid() avec les différentes options, aussi disponibles avec combine_charts(). Troisième possibilité pour des figures composées à l’aide de ggarrange(). combine_charts() fait la même chose, mais avec des valeurs par défaut légèrement différentes (labels = &quot;auto&quot; par défault pour ce dernier, mais labels = NULL pour `ggarrange()). "],
["differents-moteurs-graphiques.html", "4.5 Différents moteurs graphiques", " 4.5 Différents moteurs graphiques Depuis le début, l’ensemble des graphiques que nous vous avons proposés utilise la fonction chart() du package chart. Cependant, il ne s’agit pas de la seule fonction permettant de réaliser des graphiques dans R, loin de là. En fait, chart est tout récent et a été développé pour homogénéiser autant que possible les graphiques issus de trois moteurs graphiques différents : ggplot2, lattice et les graphiques base. La fonction chart() a d’autres avantages également : Un thème par défaut qui est le plus proche possible d’un rendu typique d’une publication scientifique. La possibilité d’utiliser l’interface formule avec ggplot2. La cohérence des objets graphiques obtenus qui peuvent tous êtres combinés en une figure composée, même si ils sont produits avec des moteurs graphiques différents. Un libellé automatique des axes et autres éléments du graphique en fonction des attributs label et units des variables (pour l’instant, seulement les graphiques de type ggplot2). # Importation des données (urchin &lt;- read(&quot;urchin_bio&quot;, package = &quot;data.io&quot;, lang = &quot;FR&quot;)) # # A tibble: 421 x 19 # origin diameter1 diameter2 height buoyant_weight weight solid_parts # &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 Pêche… 9.9 10.2 5 NA 0.522 0.478 # 2 Pêche… 10.5 10.6 5.7 NA 0.642 0.589 # 3 Pêche… 10.8 10.8 5.2 NA 0.734 0.677 # 4 Pêche… 9.6 9.3 4.6 NA 0.370 0.344 # 5 Pêche… 10.4 10.7 4.8 NA 0.610 0.559 # 6 Pêche… 10.5 11.1 5 NA 0.610 0.551 # 7 Pêche… 11 11 5.2 NA 0.672 0.605 # 8 Pêche… 11.1 11.2 5.7 NA 0.703 0.628 # 9 Pêche… 9.4 9.2 4.6 NA 0.413 0.375 # 10 Pêche… 10.1 9.5 4.7 NA 0.449 0.398 # # ... with 411 more rows, and 12 more variables: integuments &lt;dbl&gt;, # # dry_integuments &lt;dbl&gt;, digestive_tract &lt;dbl&gt;, # # dry_digestive_tract &lt;dbl&gt;, gonads &lt;dbl&gt;, dry_gonads &lt;dbl&gt;, # # skeleton &lt;dbl&gt;, lantern &lt;dbl&gt;, test &lt;dbl&gt;, spines &lt;dbl&gt;, # # maturity &lt;int&gt;, sex &lt;fct&gt; # Réalisation du graphique chart(data = urchin, height ~ weight %col=% origin) + geom_point() Figure 4.13: Graphique typique obtenu avec chart() : rendu par défaut publiable tel quel, et libellé automatique des axes avec les unités. 4.5.1 ggplot2 Le moteur graphique ggplot2 est écrit pas Hadley Wickham, un personnage emblématique de la “révolution tidyverse” qui propose une surcouche moderne au dessus de R. ggplot2 implémente une “grammaire graphique” particulièrement puissante et flexible, proposée et popularisée par le statisticien Leland Wilkinson. Par défaut, chart() crée en réalité un graphique ggplot2 adapté. Voici la version ggplot2 standard du même graphique représenté à la Fig. 4.13 : ggplot(data = urchin, mapping = aes(x = weight, y = height, col = origin)) + geom_point() Figure 4.14: Graphique typique obtenu avec ggplot() (moteur graphique ggplot2). En comparant les Figs. 4.13 et 4.14 (en faisant abstraction des instructions R utilisées pour l’instant), plusieurs points sautent immédiatement aux yeux: Le thème par défaut de ggplot2 est très reconnaissable avec un quadrillage blanc sur fond gris clair. On aime ou on n’aime pas, mais il est clair que (1) ce n’est pas une présentation “standard” d’un graphique scientifique, et (2) le thème tord un peu le cou à une règle importante pour réaliser un graphique de qualité : minimiser la quantité d’“encre” nécessaire pour représenter un graphique, autrement dit, plus le graphique est simple et sobre, mieux c’est. Le thème par défaut de chart() respecte mieux tout ceci14. La taille des caractères est légèrement plus grande dans la Fig. 4.13 réalisée avec chart(). Le manque de lisibilité des parties textuelles dans un graphique est un défaut fréquent, dépendant de la résolution et de la taille de reproduction du graphique dans le document final. Le choix de chart() recule un peu ce risque. chart() est capable d’aller lire les métadonnées (libellés en français et unités des variables) et les utilisent automatiquement pour proposer des libellés corrects et complets des axes par défaut. ggplot() ne peut pas le faire, et il faut utiliser la fonction labs() pour l’indiquer manuellement. De manière générale, par rapport à ggplot(), chart() a été conçu pour produire le graphique le plus proche d’un rendu final impeccable avec tous les paramètres par défaut. Quelques règles simples vous permettent de passer des instructions ggplot() à chart() et vice versa15 : On peut toujours remplacer ggplot() par chart() dans les instructions R (à condition que le package chart soit chargé bien sûr, par exemple via SciViews::R). Dans ce cas, le thème par défaut diffère, et le libellé automatique des axes (non disponible avec ggplot()) est activé. Avec chart() on peut utiliser aes() pour spécifier les “esthétiques” (éléments à visualiser sur le graphique) comme pour ggplot(), mais on peut aussi utiliser une interface formule plus compacte. Cette interface formule rapproche la version chart() des graphiques ggplot2 d’un autre moteur de graphique dans R : lattice. Outre les esthétiques classiques x et y, l’interface formule de chart() permet d’en inclure d’autres directement dans la formule à l’aide d’opérateurs spécifiques %&lt;esth&gt;%=. Par exemple, aes(x = weight, y = height, col = origin) dans la Fig. 4.14 se traduit en la formule plus concise height ~ weight %col=% origin avec chart() (notez la position inversée de x et y dans la formule puisqu’on a y ~ x). Tous les esthétiques de ggplot2 sont supportés de cette manière. Partout où aes() est utilisé pour les instructions ggplot2, on peut utiliser à la place f_aes() et y spécifier plutôt une formule de type chart(). Avec ggplot() les facettes doivent être spécifiées à l’aide de facet_XXX(). A condition d’utiliser chart(), il est possible d’inclure les spécifications des facettes les plus utilisées directement dans la formule en utilisant l’opérateur |. Cette façon de procéder est, encore une fois, identique à ce qui se fait dans lattice (voir plus loin). Le point (5) mérite une petite démonstration pour comparaison : a &lt;- chart(data = urchin, height ~ weight | origin) + geom_point() b &lt;- ggplot(data = urchin, mapping = aes(x = weight, y = height)) + geom_point() + facet_grid( ~ origin) combine_charts(list(a, b)) Figure 4.15: Graphique à facettes. A. version chart(), B. version ggplot(). 4.5.2 lattice Autant ggplot2 est complètement modulable en ajoutant littéralement à l’aide de l’opérateur + des couches successives sur le graphique, autant lattice vise à réaliser les graphiques en une seule instruction. lattice utilise également abondamment l’interface formule pour spécifier les variables à utiliser dans le graphique. La version lattice du graphique d’exemple est présentée à la Fig. 4.16. xyplot(height ~ weight, data = urchin, groups = origin, auto.key = TRUE) Figure 4.16: Graphique exemple réalisé avec lattice. Et voici la version chart() utilisant le moteur lattice. Notez la façon d’appeler la fonction xyplot() de lattice via chart$xyplot() : theme_sciviews_lattice(n = 2) a &lt;- chart$xyplot(height ~ weight, data = urchin, groups = origin, auto.key = list(space = &quot;right&quot;, title = &quot;Origine&quot;, cex.title = 1, columns = 1), ylab = &quot;Hauteur du test [mm]&quot;, xlab = &quot;Masse totale [g]&quot;, par.settings = list(superpose.symbol = list(col = scales::hue_pal()(2)))) b &lt;- chart(data = urchin, height ~ weight %col=% origin) + geom_point() combine_charts(list(a, b)) Figure 4.17: Graphique exemple réalisé avec chart() A. avec le moteur lattice, B. avec le moteur ggplot2. La quantité d’instructions nécessaires pour rendre la version lattice proche de la version ggplot2 devrait disparaitre dans les prochaines versions de chart(). Un autre objectif est aussi de gommer le plus possible les différences entre les rendus des différents moteurs de graphiques R, et en particuliers entre ggplot2 et lattice. Comparez la Fig. 4.17A avec la Fig. 4.16 pour apprécier le gain déjà obtenu en matière d’homogénéisation. Par rapport à ggplot2, les graphiques lattice sont moins flexibles du fait qu’ils doivent être spécifiés en une seule instruction. Cependant, ils sont beaucoup plus rapides à générer (appréciable quand il y a beaucoup de points à tracer) ! lattice offre également quelques types de graphiques non supportés par ggplot2 comme les graphiques en 3D à facettes, par exemple. Voici un graphique à facettes réalisé avec chart() et le moteur lattice. Notez que la formule utilisée est identique à cette employée pour la version ggplot2 avec chart(). chart$xyplot(data = urchin, height ~ weight | origin, scales = list(alternating = 1), xlab = &quot;Masse totale [g]&quot;, ylab = &quot;Hauteur du test [mm]&quot;) Figure 4.18: Graphique à facettes, avec chart() version lattice. Mise à part les instructions additionnelles encore nécessaires dans cette version de chart(), l’appel et le rendu sont très similaires par rapport à la version ggplot2 du même graphique avec chart() : chart(data = urchin, height ~ weight | origin) + geom_point() Figure 4.19: Graphique à facettes, avec chart() version ggplot2. 4.5.3 Graphiques de base Comme son nom le suggère, le moteur graphique de base est celui qui est implémenté de manière natif dans R. Il est donc utilisé un peu partout. Il est vieillissant et est plus difficile à manipuler que ggplot2 certainement, et même que lattice. Néanmoins, il est très flexible et rapide, … mais son rendu par défaut n’est plus vraiment au goût du jour. Voici notre graphique d’exemple rendu avec le moteur graphique R de base : plot(urchin$weight, urchin$height, col = c(&quot;red&quot;, &quot;darkgreen&quot;)[urchin$origin], pch = 1) legend(x = 80, y = 10, legend = c(&quot;Culture&quot;, &quot;Pêcherie&quot;), col = c(&quot;red&quot;, &quot;darkgreen&quot;), pch = 1) Figure 4.20: Graphique exemple réalisé avec le moteur graphique R de base. Vous rencontrerez très fréquemment la fonction plot(). C’est une fonction dite générique dont le comportement change en fonction de l’objet fourni en premier argument. Ainsi, elle réalise le graphique le plus pertinent à chaque fois en fonction du contexte. Notez tout de suite les instructions un peu confuses nécessaires pour spécifier la couleur souhaitée en fonction de l’origine des oursins. Le moteur graphique de base ne gère pas automatiquement des aspects plus complexes du graphique, telle que le positionnement d’une légende. Donc, à moins d’avoir prévu la place suffisante avant de tracer le graphique, nous ne pouvons que l’inclure à l’intérieur du cadre du graphique dans un second temps à l’aide de la fonction legend(). Comme cette dernière ne comprend rien à ce qui a été réalisé jusqu’ici, il faut lui respécifier les couleurs, formes et tailles de points utilisés ! C’est un des aspects pénibles du moteur graphique R de base. Voici maintenant une version chart() de ce graphique de base : chart$base({ par(mar = c(5.1, 4.1, 4.1, 6.1)) plot(urchin$weight, urchin$height, col = scales::hue_pal()(2)[urchin$origin], pch = 19, cex = 0.8, xlab = &quot;Masse totale [g]&quot;, ylab = &quot;Hauteur du test [mm]&quot;) legend(x = 105, y = 20, legend = c(&quot;Culture&quot;, &quot;Pêcherie&quot;), title = &quot;Origine&quot;, col = scales::hue_pal()(2), pch = 19, bty = &quot;n&quot;, cex = 0.8, y.intersp = 2) }) Figure 4.21: Graphique exemple réalisé avec le moteur graphique de base et la fonction chart(). Notez que le graphique est généré deux fois : une première fois dans un format propre aux graphiques R de base, et ensuite, il est traduit en une forme compatible avec les autres graphiques ggplot2 et lattice (et au passage, il gagne la grille en traits grisés). Dans le chunck, nous devons spécifier fig.keep = 2 pour éviter d’imprimer la première version dans le rapport lorsqu’on utilise chart$base(). Pour l’instant, le seul avantage de chart() avec les graphiques de base est qu’il les convertit en une forme combinable avec les autres graphiques dans une figure composite (sinon, ce n’est pas possible). A part cela, il faut fournir à chart$base() tout le code nécessaire pour tracer et customiser le graphique. Comme on peut le voir sur cet exemple, cela demande une quantité considérable de code. C’est aussi un autre aspect pénible de ce moteur graphique : il est très flexible, mais l’interface n’est pas optimale. Pour finir, les graphiques de base ont plus de mal avec les facettes, mais il peuvent quand même générer les versions les plus simples, par exemple à l’aide de la fonction coplot() qui accepte une formule très similaire à ce qui s’utilise avec lattice : coplot(data = urchin, height ~ weight | origin) Figure 4.22: Graphique à facettes avec le moteur graphique de base. A l’issue de cette comparaison, vous pourrez décider du moteur graphique que vous préfèrerez utiliser. Dans le cadre de ce cours, nous n’utiliserons en tous cas que quasi-exclusivement des graphiques ggplot2 créés à l’aide la fonction chart(). 4.5.4 Pour en savoir plus Chapitre Data visualisation de R for Data Science qui utilise ggplot(). Site rassemblant des extensions pour ggplot2 Introduction rapide à lattice Variantes de graphiques avec lattice Comparaison de lattice et ggplot2. Cette page fait aussi référence à un ensemble de graphiques différents générés en lattice et en ggplot2 pour comparaison (en anglais). Divers exemples de graphiques réalisés avec le moteur de base Autres exemples de graphiques R de base ggplot2 comparé aux graphiques R de base. Un point de vue différent d’un utilisateur habitué aux graphiques R de base (en anglais). Notez que plusieurs thèmes existent dans ggplot2. Il est facile d’en changer et des les customiser… mais c’est toujours appréciable d’avoir un rendu impeccable dès le premier essai.↩ Etant donné l’abondante littérature écrite sur ggplot2, il est utile de pouvoir convertir des exemples ggplot2 en graphiques chart(), si vous êtes convaincu par cette nouvelle interface.↩ "],
["a-vous-de-jouer-5.html", "4.6 A vous de jouer !", " 4.6 A vous de jouer ! Proposez cinq graphiques inédits (qui n’ont pas été vu jusqu’ici) dans vos différents projets. Employez par exemple les liens suivants pour vous inspirer : https://www.r-graph-gallery.com http://r-statistics.co/Top50-Ggplot2-Visualizations-MasterList-R-Code.html Terminez ce module en vérifiant que vous avez acquis l’ensemble des notions abordées. Ouvrez RStudio dans votre SciViews Box, puis exécutez l’instruction suivante dans la fenêtre console : BioDataScience::run(&quot;....&quot;) "],
["import.html", "Module 5 Importation/transformation des données", " Module 5 Importation/transformation des données Objectifs Savoir importer des données via la fonction read(), ainsi qu’appréhender ses arguments. Appréhender les types de variables et l’importance d’encoder convenablement les variables. Savoir remanier des données afin d’extraire l’information importante d’un jeu de données. Prérequis Si ce n’est déjà fait, vous devez avoir réaliser le module 1 ainsi que les modules liés à la visualisation des données. "],
["importation-des-donnees.html", "5.1 Importation des données", " 5.1 Importation des données Afin de réaliser l’analyse de vos résultats vous devez commencer par importer correctement vos données. Il existe une multitude de fonction pour réaliser l’importation de divers formats de fichiers. La fonction read() du package data.io est l’une d’entre-elles. Durant les précédents modules, vous avez employé cette fonction pour importer vos jeux de données. Reprennons un exemple pour détailler cette fonction. (biometry &lt;- read(&quot;biometry&quot;, package = &quot;BioDataScience&quot;, lang = &quot;fr&quot;)) # # A tibble: 395 x 7 # gender day_birth weight height wrist year_measure age # &lt;fct&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 M 1995-03-11 69 182 15 2013 18 # 2 M 1998-04-03 74 190 16 2013 15 # 3 M 1967-04-04 83 185 17.5 2013 46 # 4 M 1994-02-10 60 175 15 2013 19 # 5 W 1990-12-02 48 167 14 2013 23 # 6 W 1994-07-15 52 179 14 2013 19 # 7 W 1971-03-03 72 167 15.5 2013 42 # 8 W 1997-06-24 74 180 16 2013 16 # 9 M 1972-10-26 110 189 19 2013 41 # 10 M 1945-03-15 82 160 18 2013 68 # # ... with 385 more rows La fonction read() du package data.io assigne à biometry le jeu de données biometry présent dans le package BioDataScience. Il est également spécifié que la langue souhaitée est le français avec l’argument lang = “fr”. Lorsque vous vous retrouvez confrontés à devoir importer de nouvelles données dans R, vous devez vous poser les deux questions suivantes : Où ces données sont stockées ? Les données peuvent provenir de multiples endroits. Vous avez pu vous observer dans les modules précédents que les données peuvaientt être dans un package (par exemple le jeu de données biometry dans le package BioDataScience). Vous avez également pu observer que les données pouvait se retrouver sur votre disque, dans un dossier de votre ordinateur (par exemple, le jeu de données biometry_2014.xlsx lors de la comparaison des workflow entre Excell-Word et R-Rmarkdown). Les données peuvent également provenir d’un lien url (par exemple lors d’encodage de données collaboratives sur Google Sheets) ou d’une base de données. La fonction read() permet d’importer des données sur votre disque, depuis un URL ou encore depuis un package. Elle unifie donc 3 méthodes bien distinctes. Quels est le format de vos données ? Les données peuvent être sauvegardées avec différents formats comme csv, xlsx ou encore txt. Une multitude de formats existe avec des avantages et inconvénients que nous ne developperons pas dans cette section. La fonction read() supporte néanmoins 32 formats de fichier différents en utilisant en interne des fonctions provenant de différents packages dans R. Elle permet donc d’unifier ces différents outils d’importations des données : getOption(&quot;read_write&quot;) # # A tibble: 32 x 5 # type read_fun read_header write_fun comment # &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; # 1 csv readr::read_… data.io::hrea… readr::write_… comma separated valu… # 2 csv2 readr::read_… data.io::hrea… &lt;NA&gt; semicolon separated … # 3 xlcsv readr::read_… data.io::hrea… readr::write_… write a CSV file mor… # 4 tsv readr::read_… data.io::hrea… readr::write_… tab separated values # 5 fwf readr::read_… data.io::hrea… &lt;NA&gt; fixed width file # 6 log readr::read_… &lt;NA&gt; &lt;NA&gt; standard log file # 7 rds readr::read_… &lt;NA&gt; readr::write_… R data file (no comp… # 8 txt readr::read_… &lt;NA&gt; readr::write_… text file (as length… # 9 raw readr::read_… &lt;NA&gt; &lt;NA&gt; binary file (read as… # 10 ssv readr::read_… data.io::hrea… &lt;NA&gt; space separated valu… # # ... with 22 more rows 5.1.1 Données sur le disque La fonction read() vous permet d’importer de nombreux formats de fichiers comme expliqué précédement toute la difficulté va donc être dans la localisation de votre fichier sur votre ordinateur. Vous allez devoir spécifier le chemin d’accès de vos données. Le chemin d’accès à votre fichier peut s’écrire de manière absolue ou bien de manière relative. Vous devez tant que possible employer des chemins relatifs. Les projets dans RStudio définissent un environnement de travail comme vu dans le module 1. Ces projets sont amenés à être employé par différents collaborateurs. Il est donc indispensable que votre projet soit portable. Un projet RStudio pourra être qualifié de portable s’il est possible de déplacer le répertoire de base du projet et tout ce qu’il contient (ou le renommer) sans que les analyses effectuées dans R n’en soient affectées. Ceci est utile pour copier, par exemple, le projet d’un PC à un autre, ou si vous décidez de restructurer vos fichiers sur le disque dur. La démonstration va être effectuée sur base du projet sdd1_biometry qui vous avez traité lors de la comparaison des workflows. Votre projet s’organise comme ceci et se trouve dans le dossier project du dossier shared : /home /sv /shared /projects /sdd1_biometry # Le répertoire de base du projet sdd1_biometry.Rproj # Fichier de configuration du projet créé par RStudio /data # Le dossier avec les données de départ biometry_2014.xlsx # Un jeu de données au format xlsx sur la biométrie humaine /analysis # Un dossier pour les rapports d&#39;analyse biometry.nb.html # Vue HTML du rapport générée automatiquement biometry.Rmd # Un premier rapport au format R Notebook Afin de définir la position de votre fichiers biometry_2014.xlsx, vous devez simplement lister l’ensemble de dossier. Il s’agit du chemin absolu , de la position de votre fichier sur votre ordinateur. Ce format n’est pas du tout portable /home/sv/shared/projects/sdd1_biometry/data/biometry_2014.xlsx Ce chemin est plus portable que le précédent et le tild représente le dossier utilisateur. ~/shared/projects/sdd1_biometry/data/biometry_2014.xlsx Comme rapellez ci-dessus, les projets dans RStudio définissent un environnement de travail. Vous devez déterminer le chemin relatif en fonction du répertoire actif dans un projet R studio, c’est le projet lui même qui est le répertoire actif. data/biometry_2014.xlsx Afin de passer d’un chemin absolu à un chemin relatif vous devez : connaitre le répertoire actif utiliser le / pour rentrer dans un dossier utiliser le ../ pour sortir d’un dossier Pour obtenir une explication complète et détaillée sur l’utilisation des chemins relatifs dans l’organisation d’un projet Rstudio, lisez le tutoriel : “Tutoriel SDD-UMONS : La gestion des fichiers dans un projet et les chemins relatifs” 5.1.1.1 Pièges et astuces L’utilisation des chemins relatifs est indispensable comme expliqués ci-dessus. Lors de vos travaux organisé en plusieurs projets cohérents vous serez amené à travailler principalement dans des fichiers de type Rscript ou des fichiers R notebook ou encore R markdown. Notez ceci Le Rscript utilise comme référence afin de définir la position d’un jeu de données (ou tous autres fichiers) dans un projet, la position de projet R studio. data/biometry_2014.xlsx Le R notebook ou R markdown utilise comme référence afin de définir le chemin d’accès d’un jeu de données (ou tous autres fichiers) dans un projet, sa propre position. ../data/biometry_2014.xlsx L’utilisation des chemins d’accès relatifs respecte les mêmes principes pour l’insertion d’une image par exemple. 5.1.2 Données provenant d’un url Il existe différents programmes qui permettent d’éditer des tableaux de données en ligne et de les transmettre simplement. Google Sheet est l’un de ces programmes. Partez de l’url suivant : https://docs.google.com/spreadsheets/d/1iEuGrMk4IcCkq7gMNzy04DkSaPeWH35Psb0E56KEQMw/edit?usp=sharing Il s’agit d’un tableau de données portant sur la croissance de différentes espèces de coraux. Ce tableau de données peut être transmis sous la forme d’un tableau csv que la fonction read() peut importer. remarque : le lien founit ne permet pas de modifier les données fournie, ce paramètre peut très simplement être modifié. coral &lt;- read(&quot;https://docs.google.com/spreadsheets/d/e/2PACX-1vSxqegwJVjO0PxIs7mObr0syeYwNdpvd25AWUoWkwocQexYUqQUK0hC57NwsypQQUDnsJLiR-hxzSFA/pub?gid=0&amp;single=true&amp;output=csv&quot;, type = &quot;csv&quot;) # Parsed with column specification: # cols( # localisation = col_character(), # species = col_character(), # id = col_integer(), # growth_day = col_double() # ) # Visualisation des premières ligne du tableau de données head(coral) # # A tibble: 6 x 4 # localisation species id growth_day # &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; # 1 A0 s.hystrix 1 1.44 # 2 A0 s.hystrix 2 1.82 # 3 A0 s.hystrix 3 1.66 # 4 A0 s.hystrix 4 1.16 # 5 A0 s.hystrix 5 1.72 # 6 A0 s.hystrix 6 1.65 5.1.3 Données provenant d’un package Les packages que l’on peut assimiler à des boites à outils dans R que vous employer à chaque utilisation sur le programme comme data.io, chart ou encore flow, sont pour certains composés de jeux de données. La fonction read() permet également de les importer. Précédement, une seule fonction était employé pour importer ces données. Il s’agissait de la fonction data(). # Chargement de package library(data.io) # Appel du jeu de données data(urchin_bio) # Visualisation des premières ligne du jeu de données head(urchin_bio) # origin diameter1 diameter2 height buoyant_weight weight solid_parts # 1 Fishery 9.9 10.2 5.0 NA 0.5215 0.4777 # 2 Fishery 10.5 10.6 5.7 NA 0.6418 0.5891 # 3 Fishery 10.8 10.8 5.2 NA 0.7336 0.6770 # 4 Fishery 9.6 9.3 4.6 NA 0.3697 0.3438 # 5 Fishery 10.4 10.7 4.8 NA 0.6097 0.5587 # 6 Fishery 10.5 11.1 5.0 NA 0.6096 0.5509 # integuments dry_integuments digestive_tract dry_digestive_tract gonads # 1 0.3658 NA 0.0525 0.0079 0 # 2 0.4447 NA 0.0482 0.0090 0 # 3 0.5326 NA 0.0758 0.0134 0 # 4 0.2661 NA 0.0442 0.0064 0 # 5 0.4058 NA 0.0743 0.0117 0 # 6 0.4269 NA 0.0492 0.0097 0 # dry_gonads skeleton lantern test spines maturity sex # 1 0 0.1793 0.0211 0.0587 0.0995 0 &lt;NA&gt; # 2 0 0.1880 0.0205 0.0622 0.1053 0 &lt;NA&gt; # 3 0 0.2354 0.0254 0.0836 0.1263 0 &lt;NA&gt; # 4 0 0.0630 0.0167 0.0180 0.0283 0 &lt;NA&gt; # 5 0 NA NA NA NA 0 &lt;NA&gt; # 6 0 NA NA NA NA 0 &lt;NA&gt; La fonction read() est capable d’importer ces données en une seule instruction. # Importation de données provenant d&#39;un package urchin &lt;- read(&quot;urchin_bio&quot;, package = &quot;data.io&quot;) # Visualisation des premières ligne du jeu de données head(urchin) # # A tibble: 6 x 19 # origin diameter1 diameter2 height buoyant_weight weight solid_parts # &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 Fishe… 9.9 10.2 5 NA 0.522 0.478 # 2 Fishe… 10.5 10.6 5.7 NA 0.642 0.589 # 3 Fishe… 10.8 10.8 5.2 NA 0.734 0.677 # 4 Fishe… 9.6 9.3 4.6 NA 0.370 0.344 # 5 Fishe… 10.4 10.7 4.8 NA 0.610 0.559 # 6 Fishe… 10.5 11.1 5 NA 0.610 0.551 # # ... with 12 more variables: integuments &lt;dbl&gt;, dry_integuments &lt;dbl&gt;, # # digestive_tract &lt;dbl&gt;, dry_digestive_tract &lt;dbl&gt;, gonads &lt;dbl&gt;, # # dry_gonads &lt;dbl&gt;, skeleton &lt;dbl&gt;, lantern &lt;dbl&gt;, test &lt;dbl&gt;, # # spines &lt;dbl&gt;, maturity &lt;int&gt;, sex &lt;fct&gt; La fonction read() requiert comme premier argument le nom du jeu de données (e.g. &quot;iris&quot; ou &quot;urchin_bio&quot;), suivi de l’argument package= (e.g. &quot;datasets&quot;, ou &quot;data.io&quot;), suivi de l’argument lang= (e.g. &quot;fr&quot;) qui définit la langue d’intérêt. L’instruction ci-dessous permet d’obtenir une liste de l’ensemble des jeux de données présent dans un package. read(package = &quot;data.io&quot;) 5.1.4 Pièges et astuces 5.1.4.1 Langue du jeu de données La fonction read() a l’avantage de pouvoir employer un fichier annexe pour ajouter simplement les labels et les unités en différentes langues. Certains jeux de données comme le jeu de données de urchin_bio du package data.io possèdent ces fichiers annexes. Lorsque l’on importe le jeu de données avec la fonction data(), les fichiers annexes ne sont pas employé. # Chargement des données data(&quot;urchin_bio&quot;) # Visualisation des données chart(urchin_bio, height ~ weight %col=% origin) + geom_point() Ces fichiers annexes sont par contre employé par la fonction read() pour ajouter les labels et unités au tableau de données. Certaines fonctions comme chart() sont capables d’employer ces labels et unités. # Importation du tableau de données avec l&#39;argument lang qui varie. urchin &lt;- read(&quot;urchin_bio&quot;, package = &quot;data.io&quot;) urchin_en &lt;- read(&quot;urchin_bio&quot;, package = &quot;data.io&quot;, lang = &quot;en&quot;) urchin_fr &lt;- read(&quot;urchin_bio&quot;, package = &quot;data.io&quot;, lang = &quot;fr&quot;) urchin_FR &lt;- read(&quot;urchin_bio&quot;, package = &quot;data.io&quot;, lang = &quot;FR&quot;) L’arguement lang permet de spécifier la langue souhaitée. Les différences dans les labels sont observables sur le graphique ci-dessous. # Réalisation graphique a &lt;- chart(urchin, height ~ weight %col=% origin) + geom_point() b &lt;- chart(urchin_en, height ~ weight %col=% origin) + geom_point() c &lt;- chart(urchin_fr, height ~ weight %col=% origin) + geom_point() d &lt;- chart(urchin_FR, height ~ weight %col=% origin) + geom_point() # Combinaison des graphiques combine_charts(chartlist = list(a, b, c, d)) A &amp; B: l’argument lang par défaut est lang = “en”. Il ajoute les lables et unités en anglais avec les unités dans le système international. C : l’argument lang = “fr” ajoute les labels et unités en français. Il laisse cependant les niveaux des variables facteurs en anglais (Farm et Fishery). D : l’argument lang= “FR” ajoute les lables et unités en français. Dr plus, il traduit également les niveaux des variables facteurs. Il vous est conseillé d’employé l’argument lang=“fr” lors de vos différents travaux. La langues international en science est l’anglais et vous serez très certainement amené dans votre carrière scientifique de produire des documents en français et en anglais. L’utilisation de lang= “FR” rend le code uniquement utilisable dans ces conditions. Observez les exemples proposés ci-dessous. urchin_en %&gt;.% filter(., origin == &quot;Farm&quot;) %&gt;.% head(.) # # A tibble: 6 x 19 # origin diameter1 diameter2 height buoyant_weight weight solid_parts # &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 Farm 53.1 54.5 26.3 9.57 60.2 41.7 # 2 Farm 52.7 52.7 25.9 10.8 63.2 46.6 # 3 Farm 54 54.2 24.5 10.7 64.4 44.3 # 4 Farm 51.1 51.3 28.8 11.2 62.4 45.0 # 5 Farm 52.1 53.6 31.2 11.1 63.7 44.0 # 6 Farm 52.3 51.4 28.6 12.4 68.6 53.9 # # ... with 12 more variables: integuments &lt;dbl&gt;, dry_integuments &lt;dbl&gt;, # # digestive_tract &lt;dbl&gt;, dry_digestive_tract &lt;dbl&gt;, gonads &lt;dbl&gt;, # # dry_gonads &lt;dbl&gt;, skeleton &lt;dbl&gt;, lantern &lt;dbl&gt;, test &lt;dbl&gt;, # # spines &lt;dbl&gt;, maturity &lt;int&gt;, sex &lt;fct&gt; urchin_fr %&gt;.% filter(., origin == &quot;Farm&quot;) %&gt;.% head(.) # # A tibble: 6 x 19 # origin diameter1 diameter2 height buoyant_weight weight solid_parts # &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 Farm 53.1 54.5 26.3 9.57 60.2 41.7 # 2 Farm 52.7 52.7 25.9 10.8 63.2 46.6 # 3 Farm 54 54.2 24.5 10.7 64.4 44.3 # 4 Farm 51.1 51.3 28.8 11.2 62.4 45.0 # 5 Farm 52.1 53.6 31.2 11.1 63.7 44.0 # 6 Farm 52.3 51.4 28.6 12.4 68.6 53.9 # # ... with 12 more variables: integuments &lt;dbl&gt;, dry_integuments &lt;dbl&gt;, # # digestive_tract &lt;dbl&gt;, dry_digestive_tract &lt;dbl&gt;, gonads &lt;dbl&gt;, # # dry_gonads &lt;dbl&gt;, skeleton &lt;dbl&gt;, lantern &lt;dbl&gt;, test &lt;dbl&gt;, # # spines &lt;dbl&gt;, maturity &lt;int&gt;, sex &lt;fct&gt; urchin_FR %&gt;.% filter(., origin == &quot;Pêcherie&quot;) %&gt;.% head(.) # # A tibble: 6 x 19 # origin diameter1 diameter2 height buoyant_weight weight solid_parts # &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 Pêche… 9.9 10.2 5 NA 0.522 0.478 # 2 Pêche… 10.5 10.6 5.7 NA 0.642 0.589 # 3 Pêche… 10.8 10.8 5.2 NA 0.734 0.677 # 4 Pêche… 9.6 9.3 4.6 NA 0.370 0.344 # 5 Pêche… 10.4 10.7 4.8 NA 0.610 0.559 # 6 Pêche… 10.5 11.1 5 NA 0.610 0.551 # # ... with 12 more variables: integuments &lt;dbl&gt;, dry_integuments &lt;dbl&gt;, # # digestive_tract &lt;dbl&gt;, dry_digestive_tract &lt;dbl&gt;, gonads &lt;dbl&gt;, # # dry_gonads &lt;dbl&gt;, skeleton &lt;dbl&gt;, lantern &lt;dbl&gt;, test &lt;dbl&gt;, # # spines &lt;dbl&gt;, maturity &lt;int&gt;, sex &lt;fct&gt; "],
["type-de-variables.html", "5.2 Type de variables", " 5.2 Type de variables Lors de la réalisation de graphiques dans les modules précédents vous avez compris que toutes les variables ne se valait pas dans R. (biometry &lt;- read(&quot;biometry&quot;, package = &quot;BioDataScience&quot;, lang = &quot;fr&quot;)) # # A tibble: 395 x 7 # gender day_birth weight height wrist year_measure age # &lt;fct&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 M 1995-03-11 69 182 15 2013 18 # 2 M 1998-04-03 74 190 16 2013 15 # 3 M 1967-04-04 83 185 17.5 2013 46 # 4 M 1994-02-10 60 175 15 2013 19 # 5 W 1990-12-02 48 167 14 2013 23 # 6 W 1994-07-15 52 179 14 2013 19 # 7 W 1971-03-03 72 167 15.5 2013 42 # 8 W 1997-06-24 74 180 16 2013 16 # 9 M 1972-10-26 110 189 19 2013 41 # 10 M 1945-03-15 82 160 18 2013 68 # # ... with 385 more rows Ce graphique combiné ci-dessous montre de boites de dispersion. a &lt;- chart(biometry, height ~ gender %fill=% gender) + geom_boxplot() b &lt;- chart(biometry, height ~ weight %fill=% gender) + geom_boxplot() combine_charts(chartlist = list(a,b), common.legend = TRUE) # Warning: position_dodge requires non-overlapping x intervals Les jeux de données sont une suite de variables mises côte à côte. Vous avez à votre disposition plusieurs type de variables pour personnaliser le jeu de données : nombre : numérique : numeric entiers : integer valeurs arrondies : double nombre complexe : complex Il s’agit des valeurs numériques qui vont composer une variable du jeux de données. Si une variable numérique ne l’est pas vous pouvez la tranformer avec l’instruction suivante : caractères : character Il s’agit de chaine de charactères qui vont composer une variable du jeux de données. Les chaines de caractères vont avoir 2 but. Soit il s’agit d’une information ayant pour objectif d’être employé comme variable facteur ou bien il s’agit d’une information complémentaire sur les observations qui ne sera pas employer dans l’analyse des données. Cependant, vous pouvez être amené à transformer une variable en caractère avec l’instruction suivante : facteur : factor Il s’agit d’une variable permettant de discriminer des observations avec un ensemble de niveau dans un jeu de données comme la variable portant sur l’origine du tableau de donnés urchin. Date : date Le date dans un jeu de données sont proposé sous le format date. La fonction skim() du package skimr permet de visualiser le type de la variable et bien plus encore. Il fournit une visualisation différentes en fonction du type de la variable. Il propose par exemple un histogramme pour les variables numériques comme le montre le tableau ci-dessous skimr::skim(biometry) # Skim summary statistics # n obs: 395 # n variables: 7 # # ── Variable type:Date ────────────────────────────────────────────────────────────────────────────────────────── # variable missing complete n min max median n_unique # day_birth 0 395 395 1927-08-29 2000-08-11 1988-10-05 210 # # ── Variable type:factor ──────────────────────────────────────────────────────────────────────────────────────── # variable missing complete n n_unique top_counts ordered # gender 0 395 395 2 M: 198, W: 197, NA: 0 FALSE # # ── Variable type:numeric ─────────────────────────────────────────────────────────────────────────────────────── # variable missing complete n mean sd p0 p25 p50 p75 # age 0 395 395 35.34 17.32 15 19 27 50 # height 0 395 395 170.71 9.07 146 164 171 177 # weight 0 395 395 71.2 15.45 41.5 59 69.3 80 # wrist 2 393 395 16.65 1.67 10 15.5 16.5 18 # year_measure 0 395 395 2015.32 1.61 2013 2014 2016 2017 # p100 hist # 89 ▇▂▁▅▂▁▁▁ # 193 ▁▂▆▆▇▅▃▁ # 131 ▂▇▇▆▂▁▁▁ # 23 ▁▁▂▇▇▂▁▁ # 2017 ▅▅▁▁▁▅▁▇ Avec une seule instruction, on obtient une quantité d’information sur notr jeu de données comme le nombre d’observation, le nombre de variables et un traitement spécifique pour chaque type de variable. Cet instruction permet de visualiser et d’appréhender le jeu de données mais ne doit pas figurer tel quel dans un rapport d’analyse. 5.2.0.1 Pièges et astuces tooth &lt;- read(&quot;ToothGrowth&quot;, package = &quot;datasets&quot;, lang = &quot;fr&quot;) Le jeu de données comprend 60 observations sur la croissance de dents de cochons d’inde. Ces derniers reçoivent 2 types de suppléments soit du jus d’orange (OC) ou de la vitamine C (VC). Ils recoivent trois doses 0.5, 1, 2 mg/jour. VOus pouvez observer les données avec la fonction skim(). skimr::skim(tooth) # Skim summary statistics # n obs: 60 # n variables: 3 # # ── Variable type:factor ──────────────────────────────────────────────────────────────────────────────────────── # variable missing complete n n_unique top_counts ordered # supp 0 60 60 2 OJ: 30, VC: 30, NA: 0 FALSE # # ── Variable type:numeric ─────────────────────────────────────────────────────────────────────────────────────── # variable missing complete n mean sd p0 p25 p50 p75 p100 # dose 0 60 60 1.17 0.63 0.5 0.5 1 2 2 # len 0 60 60 18.81 7.65 4.2 13.07 19.25 25.27 33.9 # hist # ▇▁▇▁▁▁▁▇ # ▃▅▃▅▃▇▂▂ La variable dose est encodée sous la forme de variable numérique alors que cette dernière doit être sous la forme de facteur. Vous devez recoder cette variable. tooth$dose &lt;- as.factor(tooth$dose) # Visualisation des données skimr::skim(tooth) # Skim summary statistics # n obs: 60 # n variables: 3 # # ── Variable type:factor ──────────────────────────────────────────────────────────────────────────────────────── # variable missing complete n n_unique # dose 0 60 60 3 # supp 0 60 60 2 # top_counts ordered # 0.5: 20, 1: 20, 2: 20, NA: 0 FALSE # OJ: 30, VC: 30, NA: 0 FALSE # # ── Variable type:numeric ─────────────────────────────────────────────────────────────────────────────────────── # variable missing complete n mean sd p0 p25 p50 p75 p100 # len 0 60 60 18.81 7.65 4.2 13.07 19.25 25.27 33.9 # hist # ▃▅▃▅▃▇▂▂ Vous pouvez cependant aller encore plus loin car la variable est une variable facteur et plus précisement une variable facteur ordonée. Il y a une progression dans les doses administrées. Il est possible de ne pas simplement changer une variable en variable facteur. Il est possible de de préciser les niveaux levels, de l’ordonner avec l’argument ordered = TRUE. Prenez la variable dose du jeu de données ToothGrowth. Etant donné qu’il s’agit de doses croissantes administrées à des cochons d’Inde, cette variable doit donc être une variable ordonnée. tooth$dose &lt;- as.ordered(tooth$dose) # Visualisation des données skimr::skim(tooth) # Skim summary statistics # n obs: 60 # n variables: 3 # # ── Variable type:factor ──────────────────────────────────────────────────────────────────────────────────────── # variable missing complete n n_unique # dose 0 60 60 3 # supp 0 60 60 2 # top_counts ordered # 0.5: 20, 1: 20, 2: 20, NA: 0 TRUE # OJ: 30, VC: 30, NA: 0 FALSE # # ── Variable type:numeric ─────────────────────────────────────────────────────────────────────────────────────── # variable missing complete n mean sd p0 p25 p50 p75 p100 # len 0 60 60 18.81 7.65 4.2 13.07 19.25 25.27 33.9 # hist # ▃▅▃▅▃▇▂▂ La fonction as.factor() et la fonction as.ordered dérive de la fonction factor(). La variable facteur ordonnée est reconnue par une ensemble de fonction dans R. Elle ne sera de ce fait pas traitée de la même manière qu’une variable facteur simple. "],
["remaniement-des-donnees.html", "5.3 Remaniement des données", " 5.3 Remaniement des données Lors du module IV, vous avez réalisé votre premier remaniement de données afin de réaliser un graphique en barre résumant une variable numérique en fonction d’une variable facteur. Le principale remaniement des données peut être réalisé en 4 grands piliers : sélectionner des colonnes au sein d’un jeu de données select() filtrer des lignes dans un jeu de données filter() calculer de nouvelles variables dans un jeu de donées mutate() Résumer de colonnes d’un jeu de données initiale summarise() Ces grands piliers ont été défini dans le chapitre 5 de R for Datascience 5.3.1 select() Lors de l’utilisation vos jeux de données, vous serez amené à réduire vos jeux de données en sous tableau. tg &lt;- read(&quot;ToothGrowth&quot;, package = &quot;datasets&quot;, lang = &quot;fr&quot;) urchin &lt;- read(&quot;urchin_bio&quot;, package = &quot;data.io&quot;, lang = &quot;fr&quot;) Vous vous intéressez dans votre analyse uniquement à certaines variables. La fonction select() et les fonctions d’aide à la selection (?select_helpers) vous apportent la solution à vos besoins. urchin1 &lt;- select(urchin, origin, solid_parts, test) urchin2 &lt;- select(urchin, c(1,4,14)) urchin3 &lt;- select(urchin, origin, contains(&quot;weight&quot;)) urchin4 &lt;- select(urchin, ends_with(&quot;ht&quot;)) Les tableaux de données réduits sont proposé ci-dessous avec la fonction combine_charts(). La mise en forme des tableaux de données est réalisée avec la fontion ggtexttable() du package ggpubr. u1 &lt;- ggtexttable(head(urchin1, n = 4), theme = ttheme(&quot;lBlack&quot;)) u2 &lt;- ggtexttable(head(urchin2, n = 4), theme = ttheme(&quot;classic&quot;)) u3 &lt;- ggtexttable(head(urchin3, n = 4), theme = ttheme(&quot;lRed&quot;)) u4 &lt;- ggtexttable(head(urchin4, n = 4), theme = ttheme(&quot;mGreen&quot;)) # Combinaison combine_charts(chartlist = list(u1, u2, u3, u4)) Figure 4.7: a) Résumé de la sélection effectué ub1, b) Résumé de la sélection effectué ub2, c) Résumé de la sélection effectué ub3, d) Résumé de la sélection effectué ub4 5.3.2 filter() Lors de l’analyse de vos jeux de données, vous serez amené à filtrer les lignes de vos tableaux de données. La fonction filter() est l’un des outils pouvant vous apporter la solution. Repartez du jeu de données portant sur la croissance des oursins simplifié à 3 variables (urchin2). skimr::skim(urchin2) # Skim summary statistics # n obs: 421 # n variables: 3 # # ── Variable type:factor ──────────────────────────────────────────────────────────────────────────────────────── # variable missing complete n n_unique top_counts ordered # origin 0 421 421 2 Far: 218, Fis: 203, NA: 0 FALSE # # ── Variable type:numeric ─────────────────────────────────────────────────────────────────────────────────────── # variable missing complete n mean sd p0 p25 p50 p75 p100 # height 0 421 421 15.48 7.47 2.4 9.3 15 21.6 35.1 # skeleton 163 258 421 7.05 6.38 0.056 1.54 5.17 11.79 26.27 # hist # ▅▇▇▆▆▆▂▁ # ▇▃▂▂▂▁▁▁ Le tableau de données peut être combiné avec le graphique qui utilise les variable a &lt;- chart(urchin2, formula = height ~ skeleton %col=% origin) + geom_point(na.rm = TRUE) # Combinaison graphique et tableau combine_charts(chartlist = list(a,u2), widths = c(2, 1)) Figure 4.11: a) Nuage de points montrant la variation de la hauteur du test des oursins en fonction du poids du squelette. b) Tableau de données résumé de la croissance des oursins. Vous pouvez utiliser une variable facteur pour sélectionner uniquement un niveau. égal à : == tout sauf : != urchin_sub1 &lt;- filter(urchin2, origin != &quot;Fishery&quot;) # tous les origines sauf ceux provenant de Fishery # Tableau u2 &lt;- ggtexttable(head(urchin_sub1, n = 4), theme = ttheme(&quot;classic&quot;)) # Graphique a &lt;- chart(urchin_sub1, formula = height ~ skeleton %col=% origin ) + geom_point(na.rm = TRUE) # Combinaison graphique et tableau combine_charts(chartlist = list(a,u2),widths = c(2, 1)) Figure 5.1: a) Nuage de points montrant la variation de la hauteur du test des oursins en fonction du poids du squelette. b) Tableau de données résumé de la croissance des oursins suite à l’application d’un filtre sur l’orgine des oursins. Vous pouvez utiliser une variable numérique pour filtrer les données. supérieur à : &gt; inférieur à : &lt; supérieur ou égal à : &gt;= inférieur ou égal à : &lt;= urchin_sub2 &lt;- filter(urchin2, height &gt; 20) # hauteur supérieur à 20 # Tableau u2 &lt;- ggtexttable(head(urchin_sub2, n = 4), theme = ttheme(&quot;classic&quot;)) # Graphique a &lt;- chart(urchin_sub2, formula = height ~ skeleton %col=% origin) + geom_point(na.rm = TRUE) # Combinaison graphique et tableau combine_charts(chartlist = list(a,u2), widths = c(2, 1)) Figure 4.20: a) Nuage de points montrant la variation de la hauteur du test des oursins en fonction du poids du squelette. b) Tableau de données résumé de la croissance des oursins suite à l’application d’un filtre sur les tailles des individus. Vous pouvez combiner différents filtres : &amp; : et : ou urchin_sub3 &lt;- filter(urchin2, height &gt; 20 &amp; origin == &quot;Farm&quot;) # hauteur supérieur à 20 et origine contenant uniquement les oursins venant du niveau `Farm` # Tableau u3 &lt;- ggtexttable(head(urchin_sub3, n = 4), theme = ttheme(&quot;classic&quot;)) # Graphique a &lt;- chart(urchin_sub3, formula = height ~ skeleton %col=% origin) + geom_point(na.rm = TRUE) # Combinaison du graphique et du tableau combine_charts(list(a, u3), widths = c(2, 1)) Figure 4.21: a) Nuage de points montrant la variation de la hauteur du test des oursins en fonction du poids du squelette. b) Tableau de données résumé de la croissance des oursins suite à l’application d’un filtre sur l’orgine des oursins et sur les tailles des individus. Avec des variables facteurs composé des nombreux niveaux comme on peut le retrouver dans le jeu de données zooplankton du package BioDataScience, vous pouvez être amené à en sélectionner plusieurs niveaux au sein de cette variable. (zooplankton &lt;- read(&quot;zooplankton&quot;, package = &quot;data.io&quot;, lang = &quot;fr&quot;)) # # A tibble: 1,262 x 20 # ecd area perimeter feret major minor mean mode min max std_dev # &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 0.770 0.465 4.45 1.32 1.16 0.509 0.363 0.036 0.004 0.908 0.231 # 2 0.700 0.385 2.32 0.728 0.713 0.688 0.361 0.492 0.024 0.676 0.183 # 3 0.815 0.521 4.15 1.33 1.11 0.598 0.308 0.032 0.008 0.696 0.204 # 4 0.785 0.484 4.44 1.78 1.56 0.394 0.332 0.036 0.004 0.728 0.218 # 5 0.361 0.103 1.71 0.739 0.694 0.188 0.153 0.016 0.008 0.452 0.110 # 6 0.832 0.544 5.27 1.66 1.36 0.511 0.371 0.02 0.004 0.844 0.268 # 7 1.23 1.20 15.7 3.92 1.37 1.11 0.217 0.012 0.004 0.784 0.214 # 8 0.620 0.302 3.98 1.19 1.04 0.370 0.316 0.012 0.004 0.756 0.246 # 9 1.19 1.12 15.3 3.85 1.34 1.06 0.176 0.012 0.004 0.728 0.172 # 10 1.04 0.856 7.60 1.89 1.66 0.656 0.404 0.044 0.004 0.88 0.264 # # ... with 1,252 more rows, and 9 more variables: range &lt;dbl&gt;, size &lt;dbl&gt;, # # aspect &lt;dbl&gt;, elongation &lt;dbl&gt;, compactness &lt;dbl&gt;, transparency &lt;dbl&gt;, # # circularity &lt;dbl&gt;, density &lt;dbl&gt;, class &lt;fct&gt; %in% copepoda &lt;- filter(zooplankton, class %in% c(&quot;Calanoid&quot;, &quot;Cyclopoid&quot;, &quot;Harpacticoid&quot;, &quot;Poecilostomatoid&quot;)) 5.3.3 mutate() Lors de l’analyse de vos jeux de données, vous serez amené à calculer de nouvelles variables. La fonction mutate() est l’un des outils pouvant vous apporter la solution. Repartez du jeu de données portant sur la croisance des oursins. Vous pouvez tout d’abord employer les - les opérateurs arithmétiques + addition : + + soustraction : - + multiplication : * + division : / + exposant : ^ ou ** + modulo (reste lors d’une division) : %% + division entière : %/% urchin &lt;- mutate(urchin, weight_tot = lantern + spines + test, ratio = weight_tot/skeleton, skeleton2 = skeleton^2) les fonctions mathématiques log sqrt sin, cos, tan urchin &lt;- mutate(urchin, skeleton_log = log(skeleton), skeleton_sqrt = sqrt(skeleton), skeleton_sin = sin(skeleton)) La fonction mutate() permet de calculer de nouvelles variables. Cependant, la fonction transmute() permet de retirer les anciennes variables employées dans le calcule de la nouvelle. 5.3.4 summarise() Lors de l’analyse de vos jeux de données, vous serez amené à résumer vos données. tooth_tab &lt;- summarise(tooth, &quot;moyenne&quot; = mean(len), &quot;minimum&quot; = min(len), &quot;médiane&quot; = median(len), &quot;maximum&quot; = max(len)) ggtexttable(tooth_tab, theme = ttheme(&quot;lBlack&quot;)) Cette fonction n’a de véritable intêrét que couplée avec la fonction `group_by() qui va permettre de grouper un jeu de données en fonction d’une ou plusieurs variable de type facteur. tooth &lt;- group_by(tooth, supp) tooth_tab &lt;- summarise(tooth, &quot;moyenne&quot; = mean(len), &quot;minimum&quot; = min(len), &quot;médiane&quot; = median(len), &quot;maximum&quot; = max(len)) ggtexttable(tooth_tab, theme = ttheme(&quot;lBlack&quot;)) 5.3.4.1 Pièges et astuces Tout comme lors de réalisation d’une boite de dispersion, vous devez être particulièrement vigilant ou nombre d’observation par sous groupe. Ajoutez à chaque tableau résumé des données, le nombre d’observation par sous-groupe. tooth_tab &lt;- summarise(tooth, &quot;moyenne&quot; = mean(len), &quot;minimum&quot; = min(len), &quot;médiane&quot; = median(len), &quot;maximum&quot; = max(len), &quot;observation&quot; = n()) ggtexttable(tooth_tab, theme = ttheme(&quot;lBlack&quot;)) "],
["chainage.html", "5.4 Chainage", " 5.4 Chainage Le chainage (ou le pipe en anglais) permet de combiner une suite de fonction à appliquer sur un jeu de données par exemple comme lorsque vous souhaitez réaliser plusieurs étapes de remaniement des données. Différents pipes existent et nous avons décidé de vous présenter le pipe du package flow. Le jeu de données sur la biométrie humaine va être employé pour cette démonstration qui va comparer le remaniement d’un tableau de données avec et sans l’utilisation du chainage. biometry &lt;- read(&quot;biometry&quot;, package = &quot;BioDataScience&quot;, lang = &quot;fr&quot;) biometry1 &lt;- read(&quot;biometry&quot;, package = &quot;BioDataScience&quot;, lang = &quot;fr&quot;) L’opérateur qui permet de chainer les fonctions est %&gt;.% Sur le jeu biometry, vous vous interessez aux IMC (bmi en anglais) des individus de moins de 25 ans. Vous souhaitez représenter la moyenne, la médiane et le nombre d’observations des hommes et des femmes de cette population dans un tableau. Pour obtenir ces données vous devez : calculer le imc filter le tableau pour n’obtenir que le individus de moins de 25 ans résumer les données afin d’obtenir la moyenne et la médiane par genre. afficher un tableau de données avec ces résultats # Sans chainage biometry &lt;- mutate(biometry, bmi = weight/((height/100))^2) biometry_sub &lt;- filter(biometry, age &lt;=25) biometry_sub &lt;- group_by(biometry_sub, gender) biometry_tab &lt;- summarise(biometry_sub, mean = mean(bmi), median = median(bmi), number = n()) tab1 &lt;- ggtexttable(biometry_tab, theme = ttheme(&quot;lBlack&quot;), rows = NULL, cols = c(&quot;Genre&quot;, &quot;Moyenne&quot;, &quot;Médiane&quot;, &quot;Observations&quot;)) # avec le chainage biometry1 %&gt;.% mutate(., bmi = weight/((height/100))^2) %&gt;.% filter(., age &lt;= 25) %&gt;.% group_by(., gender) %&gt;.% summarise(., mean = mean(bmi), median = median(bmi), number = n()) %&gt;.% ggtexttable(., theme = ttheme(&quot;lBlack&quot;), rows = NULL, cols = c(&quot;Genre&quot;, &quot;Moyenne&quot;, &quot;Médiane&quot;, &quot;Observations&quot;)) -&gt; tab2 # combinaison des deux tableaux pour obtenir une comparaison combine_charts(chartlist = list(tab1, tab2)) Le pipe permet d’éviter certaine répétion afin de réaliser en cascade la suite des opérations. Il permet également de faciliter la lecture du code. Vous devez être vigilant à la structure du pipe qui comprend le pipe %&gt;.%et le point au début des fonctions .. Le pipe fait le lien entre les différentes fonctions et le point renvoit au jeu de données passant de fonction en fonction. 5.4.0.1 Pour en savoir plus Customisation de tableau "],
["a-vous-de-jouer-6.html", "5.5 A vous de jouer !", " 5.5 A vous de jouer ! Un squelette de projet RStudio vous a été fournit dans un dépôt Github Classroom, y compris organisation des fichiers et jeux de données types. Votre objectif est de : Importer les données provenant du ToothGrowth Comprendre les données proposées, en utilisant des visualisations graphiques appropriées Reproduire de plus le graphique ci-dessous Documenter le fruit de votre étude dans un rapport R Notebook. "],
["qualit.html", "Module 6 Données qualitatives", " Module 6 Données qualitatives Variables de type factor/ordered, transformation, découpage en classes, tableau de contigence. Choix des variables à mesurer, biométrie humaine. Suite d’idée afin de rédiger le chapitre 6 Vos objectifs pour ce module sont : Appréhender le découpage en classe d’une variable numérique, afin de réaliser une variable facteur Appréhender la réalisation des tableaux de contingences. Acquérir des données et les encoder de manière reproductible "],
["decoupage-en-classe.html", "6.1 Découpage en classe", " 6.1 Découpage en classe "],
["tableaux-de-contingences.html", "6.2 Tableaux de contingences", " 6.2 Tableaux de contingences "],
["acquisition-de-donnees-scientifiques.html", "6.3 Acquisition de données scientifiques", " 6.3 Acquisition de données scientifiques Vous avez pour objectif de réaliser une recherche Thématique de la biométrie humaine Recherche bibliographique sur la thématique Profil de l’expérience Variables mesurées afin de répondre à la thématique Analyses souhiatées Acquisition des données Précision &amp; exactitude Systèmes de codifications : respect de la vie privée Encodage des données Importation des données Correction des erreurs (tidy) Traitement des données ( Transform, visualise, model ) Visualisation graphiques des données Analyse statistiques des données Réalisation d’un rapport structuré répondant à la question de départ "],
["a-vous-de-jouer-7.html", "6.4 A vous de jouer !", " 6.4 A vous de jouer ! "],
["proba.html", "Module 7 Probabilités &amp; distributions", " Module 7 Probabilités &amp; distributions On part du paradoxe bayésien (effet d’un test de dépistage en fonction de la prévalence d’une maladie) -&gt; probabilités et calculs de probabilités. Généralisation = lois de distributions. Distributions discrètes et continues. Principales lois de distributions et utilisation en pratique. Evaluation par les pairs d’un rapport réalisé jusqu’ici. "],
["chi2.html", "Module 8 Test Chi carré", " Module 8 Test Chi carré Restitution globale concernant l’évaluation de rapports par les pairs. Test de Chi2, et application sur base d’une courte manip réalisée par les étudiants (par exemple, sur des coraux). "],
["moyenne.html", "Module 9 Moyenne", " Module 9 Moyenne Moyenne, intervalle de confiance et t-test. Présentation graphique: dynamite plot + barres d’erreurs. Transformation des données pour linéariser et ou rendre symétrique autour de la moyenne. Comparaison moyenne/médiane =&gt; paramétrique versus non paramétrique. Exemple d’équation avec référence, voir éq. (9.1): \\[\\begin{equation} \\mu=\\sum_{i=1}^n{\\frac{x_i}{n}} \\tag{9.1} \\end{equation}\\] L’équation suivante n’est pas libellée: \\[\\begin{equation*} \\mu=\\frac{\\sum_{i=1}^nx_i}{n} \\end{equation*}\\] "],
["variance.html", "Module 10 Variance", " Module 10 Variance Comparaison de deux populations (suite): Wilcoxon-Mann-Withney + comparaison au t-test. Variance, ANOVAs, test de Bartlett. Graphiques associés. Petite recherche biblio concernant l’application en pratique de ces tests à faire par les étudiants. "],
["correlation.html", "Module 11 Corrélation", " Module 11 Corrélation Suite ANOVA (ANOVA à deux facteurs) + correlation + graphes et tests. Restitution participation à l’élaboration du bookdown commun. "],
["design.html", "Module 12 Design expérimental &amp; critique statistique", " Module 12 Design expérimental &amp; critique statistique Design de l’expérience, choix du nombre de réplicas et puissance d’un test. Critique stat + “bad graphs” + pseudo-réplication. “Challenges” sur base de la critique statistique. Débriefing général. "],
["svbox.html", "A Installation de la SciViews Box", " A Installation de la SciViews Box La SciViews Box est une machine virtuelle (c’est-à-dire, l’équivalent d’un ordinateur complet, mais “dématérialisé” et utilisable à l’intérieur de n’importe quel autre ordinateur physique). Elle est spécialement configurée pour analyser des données et rédiger des documents scientifiques de manière professionnelle. Dans notre cas, le logiciel de gestion de la machine virtuelle, l’hyperviseur, est VirtualBox. C’est un logiciel gratuit qui existe pour Windows, MacOS et la plupart des systèmes Linux. L’avantage d’utiliser une machine virtuelle dans le contexte qui nous concerne ici est double : Elle est complètement pré-configurée et pré-testée. Comme tout le monde utilise la même machine virtuelle, les résultats obtenus chez l’un sont parfaitement reproductibles chez d’autres. L’installation est simple, mais il y a quand même quelques pièges. Suivez le guide… "],
["prerequis-4.html", "A.1 Prérequis", " A.1 Prérequis Avant d’installer la SciViews Box 2018, vérifiez que votre ordinateur répond aux conditions requises et qu’il est correctement configuré. A.1.1 Ordinateur La SciViews Box 2018, et la Science des Données en général, nécessitent un ordinateur ayant une puissance de calcul suffisante. Les tablettes et autres chromebooks sont donc exclus (sauf à être utilisés comme simples browsers web avec les calculs déportés sur un serveur, voir par exemple Chromebook Data Science). Si l’utilisation d’un serveur est une bonne idée pour l’apprentissage, ce n’est pas une solution sur le long terme pour tout le monde. En effet, vous êtes et restez dépendant du serveur que l’on a bien voulu configurer et partager avec vous (sera-t-il encore disponible après votre cours, par exemple ?). La solution proposée avec la SciViews Box vous rend complètement autonome dès le départ. Le choix d’un ordinateur ayant une capacité de calcul suffisante n’est pas aisé et les disparités en matière de performances sont énormes, voir NovaBench CPU score. La configuration de référence est la suivante, avec un score global Novabench de 1000 : Processeur : à 2 ou 4 coeurs / 4 threads d’une vitesse de calcul suffisante (score CPU Novabench d’environ 700). Mémoire vive : 8Go avec un score RAM Novabench de 200. Disque dur : disque rapide SSD de 256Go (score disque Novabench d’environ 100 avec vitesse d’écriture &gt;= 250Mo/s et vitesse de lecture &gt;= 600Mo/s). Affichage : 1920x1080. La plupart des cartes graphiques ou des coprocesseurs graphiques intégrés conviennent (pas besoin d’une bête de course si vos calculs ne nécessitent pas des instructions GPU, en tous cas). Comme base, nous considèrerons un score GPU NovaBench d’environ 200 qui correspond au processeur graphique intégré Intel HD 620. Réseau : Wifi à la norme 802.11ac. Connectique : USB 3.0 ou C pour ajouter des périphériques, HDMI ou DisplayPort pour connecter un écran externe, et une prise casque pour visionner des vidéos sans déranger les voisins. Système d’exploitation : récent et si possible 64-bit. Windows 7 ou plus convient (mais pensez à mettre-à-jour vers Windows 10), MacOS 10.10 Yosemite ou plus, ou un Linux tel Debian 8 (Jessie) ou 9 (Stretch), Ubuntu 16.04 Xenial ou supérieur, … Une configuration “standard” avec au moins 20Go de libre pour la SciViews Box (nécessairement sur le disque C: sous Windows), et une configuration non bidouillée (répertoire utilisateur et programmes standards, entre autres). Pour une configuration de base, vous pouvez aller jusqu’à diviser les scores Novabench et les valeurs (nombre de coeurs CPU, taille de la mémoire vive et du disque) par deux, et pour une configuration performante, multipliez-les par deux, et ajoutez-y éventuellement une carte graphique Nvidia performante pour des calculs GPU et un second disque de 1To pour stocker des gros jeux de données. Un “laptop” (ordinateur portable) est mieux, mais si vous n’avez pas besoin d’une solution nomade, un “desktop” convient aussi et est plus modulable. Pour tester votre système, nous vous proposons donc d’utiliser le logiciel gratuit pour un usage personnel Novabench. Vous obtiendrez un rapport (voir ci-dessous) que vous pourrez comparer à la configuration de référence : A.1.2 Activation de la virtualisation La virtualisation fait appel à un jeu d’instructions disponible sur pratiquement tous les processeurs modernes (Intel VT-x ou AMD-v). Malheureusement, elle est désactivée par défaut sur quasi tous les PC (mais les Macs sont, eux, configurés correctement en sortie d’usine). Tant que ces instructions de virtualisation ne seront pas activées, le programme d’installation de la SciViews Box va bloquer avec le message suivant: Même si vous arriviez à l’installer quand même, vous ne pourriez pas la démarrer, et verriez juste le message suivant (issu de la version précédente de la SciViews Box): Pour activer ce jeu d’instructions, il faut aller dans le BIOS, c’est-à-dire, le petit programme qui démarre votre ordinateur. Il n’y a malheureusement pas de recette unique car chaque constructeur a sa propre façon de faire. De plus, l’endroit où il faut aller dans les menus de configuration du BIOS diffère aussi d’un ordinateur à l’autre. Cependant, la procédure générale est la suivante: Redémarrer l’ordinateur, Au tout début du démarrage, il faut appuyer sur une touche ou une combinaison de touches (par exemple, DEL, F2, …). Restez à l’affût d’un message furtif qui l’indique à l’écran, Une fois entré dans le BIOS, repérez l’entrée correspondant au jeu d’instructions de virtualisation. Vous aurez plus de chances en regardant dans le menu relatif au processeur, ou dans les options avancées. Recherchez une entrée de type “Virtualisation”, “Intel Virtual Technology”, ou “Instructions AMD-v”. Activez cette option (cela n’aura aucun effet sur les logiciels que vous avez installés jusqu’ici et qui n’utilisent pas cette fonction), Sortez du BIOS en sauvegardant les modifications (suivez les instructions à l’écran), Redémarrez l’ordinateur. Si vous n’arrivez pas à entrer dans le BIOS, ou à trouver l’entrée correspondante dans celui-ci, rechercher “BIOS Virtualization” accompagné de la marque et du modèle de votre ordinateur dans votre moteur de recherche internet favori. Vous y trouverez certainement des instructions plus précises relatives à votre ordinateur. Ce site liste quelques uns de raccourcis claviers à utiliser en fonction de la marque des ordinateurs pour entrer dans le BIOS. Dans le cas où vous n’arrivez pas à activer la virtualisation sur votre PC, vous pouvez toujours installer une version 32-bit de la SciViews Box en mode d’émulation logicielle de VirtualBox. Dans ce cas, votre box tournera plus lentement et vous n’aurez pas la possibilité d’utiliser plus d’un seul coeur processeur, mais au moins, vous pourrez quand même l’utiliser. La version 64-bit “complète” se nomme svbox2018a. La version 32-bit est svbox2018b. Si vous optez pour cette dernière, adaptez l’intitulé de la machine ou des fichiers (a-&gt; b) dans la suite de ce tutoriel. Si votre ordinateur est conforme aux spécifications ci-dessus, et si la virtualisation est activée, vous êtes maintenant prêt à installer votre SciViews Box! Dans ce cas, passez directement à la section A.2. Si vous n’avez pas encore d’ordinateur et souhaitez en acheter un, voyez quelques conseils utiles ci-dessous pour faire le bon choix. A.1.3 Conseils pour acheter un ordinateur Pour les étudiants de l’UMONS, vous ne devez pas posséder votre propre ordinateur pour suivre le cours de science des données biologiques. Des ordinateurs en configuration de référence (voir ordinateur) vous sont accessibles au cours et aux travaux pratiques, et en dehors des heures à la salle “Escher” (demander un accès au secrétariat des sciences). Toutefois, si vous pouvez acquérir un ordinateur personnel, cela vous apportera un confort et une flexibilité indéniable, à condition de bien le choisir ! Si vous suivez les directives ci-dessus, vous ne pourrez pas vous tromper. Mais comme vous n’aurez probablement pas la possibilité de tester les ordinateurs avec Novabench avant l’achat, voici quelques exemples de configurations types et leur coûts approximatifs. Attention : cette analyse est réalisée en octobre 2018. Le matériel informatique et les prix changent constamment, et les informations seront rapidement obsolètes. Les lignes directrices devraient, cependant rester valables à l’avenir pour utiliser la SciViews Box 2018. L’élément le plus important étant la vitesse de calcul du processeur, obtenez la référence du processeur de l’ordinateur que vous convoitez et recherchez-le ici. Comparer alors son score à notre configuration de référence, et faites-en de même pour les autres caractéristiques (mémoire vive, type et taille du disque dur, etc.) Prenez aussi comme référence les ordinateurs de votre salle de travaux pratiques. A l’UMONS, dans la salle “Pentagone”, les ordinateurs sont équipés d’Intel Core i5-6400T @ 2.20Ghz. Ce sont des processeurs 4 coeurs/4 threads avec un score CPU Novabench de 511. Ils possèdent également 8Go de mémoire vive, un disque dur SDD avec 190Go dédiés à Windows 10 64-bit, et un processeur graphique intégré qui affiche 1920x1080 pixels à l’écran. Aux salles “Escher” et “Turing”, ce sont des processeurs Intel Core i5-4590 @ 3.30Ghz, également 4 coeurs/4 threads affichant un score CPU Novabench de 515. Le reste de leurs configurations est similaire à celle des ordinateurs “Pentagone”. Vous pouvez également vous baser sur d’autres tests, les CPUMarks et comparer le processeur de l’ordinateur que vous voulez acheter avec les scores de vos machines des salles de travaux pratiques à partir de cette page. Dans le choix de votre ordinateur, il faut tout d’abord vous demander si vous voulez un ordinateur pour apprendre à traiter des données sur des petits tableaux, et que vous prévoyez changer dans 1 ou 2 ans (dans ce cas, une configuration de base convient), ou si vous voulez investir sur plus long terme. Visez alors plus haut. Naturellement, le prix sera un critère fondamental, également16. Justification des besoins : Processeur : l’élément le plus important. Un processeur puissant et multitâche est indispensable. Il vous faut au moins 2 coeurs et 4 threads (selon les modèles, chaque coeur peut gérer une seule tâche -ou “thread” en anglais- ou deux). Un processeur 4 coeurs/4 threads est encore mieux, et à partir de 4 coeurs/8 threads, c’est parfait. Pour la vitesse de calcul, comme indiqué plus haut, un score CPU Novabench de 700 ou mieux, ou un CPUMark de 7000 ou mieux doit être visé pour une configuration de référence ou performante. Avec un score moitié moindre, c’est encore un processeur utilisable, mais ne descendez pas en dessous pour une configuration de base. Mémoire vive : il vous faut suffisamment de mémoire pour la partager entre la machine hôte et la machine virtuelle, et garder assez de resources pour ouvrir des tableaux (moyennement) volumineux. Donc, visez 8Go de mémoire vive si possible. Pas moins de 4Go, et plus vous en avez, mieux c’est. Il existe des configurations laptops à 16Go. C’est utile ! Disque dur : ici, vous devrez peut-être faire un choix entre espace de stockage et vitesse du disque. En effet, les disques mécaniques classiques font maintenant facilement 1To, ce qui est confortable. Par contre, ils sont plus lents que les disques SSD qui sont à privilégier. Mais ces derniers sont de capacité moindre (dans des gammes de prix raisonnables), généralement 128Go ou 256Go. Des configurations plus haut de gamme combinent deux disques : un SSD rapide pour le système et un disque de 1To classique pour les données. C’est l’idéal. Si vous investissez dans un ordinateur ayant un disque dur SSD rapide mais pas assez gros pour contenir vos nombreux fichiers, photos, vidéos, morceaux de musique, etc., vous pourrez toujours compléter votre configuration avec un disque dur de 1To externe USB 3.0 pour une cinquantaine d’euros. Pensez aussi à investir dans une clé USB de 8 ou 16Gb pour transférer vos données. Faites attention de bien choisir un modèle USB 3.0 reconnaissable à son connecteur bleu, infiniment plus rapide qu’un modèle USB 2.0. Il vous en coutera une dizaine d’euros. Carte graphique et écran : la qualité de la carte graphique est moins importante ici. La plupart des configurations actuelles conviennent. Voyez plutôt la taille (et donc, le poids) qui est un critère important pour un ordinateur portable. Voulez-vous un PC de 13 ou 14 pouces plus compact et transportable, ou un 15 à 17 pouces plus confortable, mais plus lourd? Pour la résolution d’écran, ne descendez pas en dessous de 1400x900 pixels pour un travail confortable (RStudio affiche plusieurs fenêtres côte-à-côte), et vérifiez visuellement si la qualité de l’écran vous convient. Wifi et accessoires: une bonne connexion Wifi sera nécessaire pour vous connecter à Internet. La norme WiFi 802.11ac est idéale. Enfin, vérifiez les connexions proposées : USB rapide (3.0, 3.1 ou C), Thunderbold, DisplayPort, HDMI, etc. pour connecter des périphériques et des écrans externes, lecteur de cartes éventuel, etc. D’autres critères comme la qualité de construction, la robustesse, la qualité du clavier et du trackpad éventuel, l’autonomie pour un portable, … sont importants. Pensez à consulter les tests détaillés effectués par des pros avant de vous décider, par exemple, les numériques en français, PCMag ou techradar en anglais. Voici quelques configurations types qui conviennent, volontairement choisies chez différents constructeurs pour ne privilégier personne. Dans le cadre de vos études, vous allez certainement vouloir emporter votre ordinateur avec vous partout. Nous vous présentons donc des ordinateurs portables de moins de 2kg, plus adaptés à cet usage. A.1.3.1 Configurations de base Evitez autant que possible de descendre en dessous de celles-ci. Dites-vous bien que ces machines sont estampillées “bureautique”, et sont trop juste pour analyser des gros jeux de données, mais elles peuvent convenir parfaitement dans le cadre du cours de science des données biologiques. Si vous possédez déjà un PC, faites un bilan avec Novabench et décidez par vous-même si vous pouvez ou non l’utiliser de manière confortable, éventuellement en installant la SciViews Box 2018 et en testant ainsi directement. Les options existent aussi pour “booster” un ordinateur un peu juste : ajout de mémoire vive et/ou remplacement du disque dur par un disque SSD rapide. Modèle Processeur [c/t] (nova/cpu) Mémoire Disque Graphique Ecran Poids Prix Lenovo IdeaPad 320S-14IKB Core i3-7100U [2/4] (406/3798) 8Go SSD 128Go Intel HD620 14’’ (1920x1080) 1.7kg 500€ Acer Swift 3 Core i3-8130U [2/4] (579/5061) 4Go SSD 256Go Intel HD620 14’’ (1920x1080) 1.45kg 600€ MacBook Air Core i5-5350U [2/4] (363/3358) 8Go SSD 128Go Intel HD6000 13.3’’ (1440x900) 1.35kg 1000€ Avec un budget de 500€-600€, des concessions sont nécessaires. A titre d’exemple, nous reprenons deux configurations sous Windows ici. Le Lenovo choisi a 8Go de mémoire vive, mais un disque SDD de faible capacité (128Go) et un processeur un peu juste. L’Acer a un plus gros disque et un meilleur processeur (toujours i3, cependant), mais n’a que 4Go de mémoire vive. Toutefois, un seul disque dur de seulement 128Go, c’est quand même fort juste sous Windows 10 qui est déjà très gourmand en espace disque à la base. Donc votre préférence ira si possible plutôt vers une configuration du type Acer Swift 3 ci-dessus17. Des versions avec processeur Core i5 et 8Go de mémoire existent. Elles sont parfaites, … mais le prix les alignent presque avec nos configurations de référence ci-dessous. Vous verrez aussi dans les tests que ces machines ne sont pas irréprochables, mais il faut mettre les “défauts” relevés en regard du prix très contenu, et relativiser. Pour la science des données, nous privilégierons des ordinateurs plus rapides, quitte a être un peu moins bien cotés dans les tests sur la qualité de l’écran (comme l’Acer, par exemple). Du côté Mac portables, nous avons le MacBook 12’’ et le MacBook Air, présenté ici. Ils sont beaucoup plus chers, mais ce sont des ordinateurs durables et bien finis qui se revendent très bien. Dans les deux cas, le processeur (même si Core i5, ou i7) est fort juste et est plus à l’aise en bureautique. Pour analyser des petits jeux de données, ça fonctionne quand même bien. Ici aussi, des concessions sont nécessaires sur la capacité du disque dur pour tirer le prix à … 1000€ tout de même ! Mais comme le MacBook Air existe depuis 2015 quasiment inchangé, vous pouvez trouver en occasion des modèles à prix équivalent aux deux autres machines, mais faites attention à éviter les modèles anciens à processeurs lents qui se vendent encore, et qui ne sont pas assez puissants ! Un modèle avec un disque de 256Go existe aussi. Attention aussi : même si ce modèle vieilli bien, il est quand même en fin de vie. Ca a un impact sur la revente. A.1.3.2 Configurations de référence Avec un budget un peu plus élevé, vous êtes nettement plus confortable : processeur assez rapide et 8Go de mémoire vive et disque SSD de 256Go. Ces laptops sont parfaits pour le cours de science des données biologiques et pour bien d’autres tâches dans le cadre de vos études. Modèle Processeur [c/t] (nova/cpu) Mémoire Disque Graphique Ecran Poids Prix HP Pavilion X360 Core i5-8250U [2/4] (801/7667) 8Go SSD 256Go GeForce MX130 14’’ (1920x1080) 1.6kg 900€ Acer Swift 5 Core i5-8250U [2/4] (801/7667) 8Go SSD 256Go Intel HD620 14’’ (1920x1080) 0.97kg 900€ MacBook Pro 13’’ Core i5-8259U [2/4] (???/10938) 8Go SSD 256Go Intel Iris+640 13’’ (2560x1600) 1.4kg 1600€ Le HP Pavilion est un portable à écran tactile représentatif de ce créneau (pour les modèles les plus puissants de la gamme en tous cas). Vous combinez un bon processeur, 8Go RAM, un disque dur rapide de 256Go, une carte graphique accélérée et un écran correct pour l’usage prévu pour un poids raisonnable. L’Acer Swift 5 est repris ici pour son poids plume et ses résultats excellents aux tests, mais sa carte graphique est en retrait par rapport au HP (élément secondaire). Un autre très bon exemple de machine portable qui convient parfaitement pour la science des données. Vivement conseillé, donc. Nous avons aussi inclu le premier MacBook Pro en version disque de 256Go à titre de comparaison (testé en version 2017) : il est plus cher mais à ce prix, vous avez tout de même un écran incomparablement meilleur, un processeur très rapide et une valeur à la revente bien plus haute. Chez Apple, restez dans la gamme MacBook Pro en laptops. Les processeurs des autres modèles les font tous entrer dans la catégorie de base. Attention aussi au prix des adaptateurs supplémentaires souvent indispensables pour les produits Apple ! N’oubliez pas de demander votre remise “éducation”, sur présentation de votre carte d’étudiant (le tarif indiqué tient compte de cette remise). A.1.3.3 Configurations performantes Un budget plus large permet d’acquérir un laptop de course qui sera utile pendant des années, et même pour un travail lourd plus tard… Dans ces configurations, pas de concessions. On veut un processeur i7 à 4 ou 6 coeurs ou équivalent, 16Go de RAM, un disque SSD d’au moins 512Go, ou mieux deux disques, une carte graphique rapide (sauf sur les ultra-portables) et un excellent écran. Modèle Processeur [c/t] (nova/cpu) Mémoire Disque Graphique Ecran Poids Prix MSI GF63 Core i7-8750H [6/12] (1400/12548) 16Go SSD 256Go + HDD 1To GeForce GTX1050Ti 15.6’’ (1920x1080) 1.86kg 1300€ Dell XPS 13 9370 Core i7-8550U [4/8] (837/8327) 16Go SSD 512Go Intel HD620 13.3’’ (1920x1080) 1.1kg 1400€ Asus ZenBook Flip Core i7-8550U [4/8] (837/8327) 16Go SSD 512Go Intel HD400 13.3’’ (1920x1080) 1.1kg 1600€ MacBook Pro 15’’ Core i7-8750H [6/12] (1400/12548) 16Go SSD 512Go Radeon Pro 555X 15.4’’ (2880x1800) 1.83kg 2700€ Le MSI est un PC dit “gamer”. Tous les laptops dans cette catégorie sont très rapides… et conviennent parfaitement bien pour la science des données, y compris pour les calculs GPU. Chez MSI, un modèle comme le GS65 Stealth obtient le label de meilleur “gamer laptop 2018” (chez techradar) et des modèles similaires sont très bien placés ailleurs. Mais nous préférons le GF63 moins cher car équipé d’une carte graphique un cran en dessous, et du coup, mieux positionné en rapport qualité/prix pour les sciences des données. Il est aussi nettement moins lourd. Chez Asus (ROG) et Lenovo entre autres, des machines quasi-équivalentes existent aussi. Attention : d’autres configurations de “laptops gamers” sont lourdes et elles chauffent beaucoup. Dans la catégorie ultraportable, on trouve aussi diverses machines plus puissantes. Le Dell XPS 13 de 13’’ est l’un des mieux classés systématiquement dans les tests un peu partout et représentatif de ce type d’ordinateurs ultra-compacts, légers, mais très performants. Poids plume oblige, on a un processeur moins puissant que sur un PC gamer (vérifiez qu’il soit suffisamment performant sur le modèle choisi, en effet, il existe plusieurs processeurs i5 et même i7 trop lents) et une carte graphique plus basique (pas grave). Choisissez un modèle avec 16Go de RAM et au moins 256Go de disque dur. Le nouveau Huawei Matebook X Pro est une splendide machine ultraportable avec un magnifique écran de 3000x2000 pixels (excusez du peu !), mais il n’est pas repris ici, car pas commercialisé en Belgique. Il est toutefois commercialisé en France… si vous acceptez d’utiliser un clavier français légèrement différent du clavier belge. Un test complet est aussi disponible. Ici, vous choisirez la version i5 avec processeur Core i5-8550U, 8Go de RAM et un disque SSD de 256Go pour une configuration de référence à 1500€, mais pourrez opter pour le i7 avec un Core i7-8250U, 16Go de RAM et un disque SDD de 512Go pour une configuration optimale pour environ 2000€. C’est l’un des meilleurs ordinateurs du moment ! Toujours dans les ultraportables, vous trouverez aussi les convertibles. Ceux équipés d’un écran tactile et qui peuvent se “retourner” pour s’utiliser comme une tablette haut de gamme. Les ordinateurs de type Microsoft Surface en sont les représentants emblématiques, mais les tests nous conduisent aussi vers l’Asus Zenbook Flip comme l’un des meilleurs (et assurément, un excellent rapport qualité/prix). Ici, on trouve des versions en 13’‘et en 15’’ mais toujours très portables et puissantes. De très bonnes machines pour analyser ses données ! A titre de comparaison, l’équivalent chez Apple est également présenté (le MacBook Pro 15’’, avec option disque de 512Go et remise “éducation”). Ce dernier est à nouveau beaucoup plus cher. Mais son écran est incomparable, sa finition est impeccable, et il tourne sous MacOS naturellement pour les afficionados ! Le modèle 2018 à 6 coeurs n’a pas encore été testé chez “les numériques”, mais voici le test du modèle 2017. C’est une excellente machine. Malheureusement, la tendance est au minimalisme pour la connectique : du USB-C et c’est tout. Cela oblige à acheter et à transporter des connecteurs supplémentaires. Les anciennes générations de MacBook Pro, “pré touch bar” se trouvent encore dans le marché de l’occasion à des prix proches de PC équivalents sous Windows. Ils sont un peu moins performants que les nouveaux, mais restent excellents, … et possèdent beaucoup plus de connecteurs intégrés (de bonnes affaires, donc). Voilà ! En espérant que ceci pourra vous aider au mieux dans le choix de votre outil informatique. Renseignez-vous au niveau des services étudiants à l’UMONS et à l’AGE : des aides existent pour les étudiants boursiers qui souhaitent acquérir un ordinateur dans le cadre de leurs études.↩ Ce ne sont que des exemples. Recherchez des configurations équivalentes chez d’autres constructeurs aussi !↩ "],
["install.html", "A.2 Installation", " A.2 Installation Vous allez devoir d’abord installer VirtualBox, un logiciel gratuit et libre qui se chargera de gérer votre machine virtuelle. Ensuite, vous installerez la SciViews Box en elle-même. Pour finir, vous aurez aussi besoin de Github Desktop. A.2.1 VirtualBox Récupérez l’installateur correspondant à votre système ici. L’installation avec tous les paramètres par défaut convient. Il se peut que vous voyiez un message vous indiquant que VirtualBox doit réinitialiser le réseau ou une autre ressource. Vérifiez que tous les documents en cours éventuels sont sauvegardés, et ensuite, vous pourrez continuer l’installation sans risques. De même, sous Windows, l’installateur de VirtualBox vous préviendra peut-être qu’il doit installer l’un ou l’autre périphérique. Vous pouvez également continuer sans craintes (précaution prise par Microsoft, mais ces périphériques fonctionnent bien). A.2.2 SciViews Box La procédure d’installation de la SciViews Box diffère selon le système d’exploitation. Reportez-vous à la sous-section correspondante pour Windows, MacOS ou Linux. A.2.2.1 Installation sous Windows Chargez l’installateur ici ou, pour les étudiants de l’UMONS, récupérez-le depuis le disque StudentTemp de la salle informatique (sous-répertoire SDD\\Software\\SciViews Box 2018). Pensez aussi à placer le fichier svbox2018a.vdi.xz dans le même répertoire que l’installateur svbox2018a_win_setup.exe. Sinon vous devrez le télécharger lors de l’installation (il pèse tout de même 2,9Gb)! Lancez l’installation. Vous verrez l’écran suivant (probablement en version française sur votre ordinateur). Vous pouvez cliquer ‘Yes’/‘Oui’. Il s’agit seulement d’une précaution de Microsoft lorsqu’il ne connait pas l’éditeur du programme à installer, comme c’est le cas ici. Si le fichier svbox2018a.vdi.xz n’est pas présent dans le même répertoire que le programme d’installation, il est à présent téléchargé (cliquez sur “Details” pour suivre l’opération): Une fois le téléchargement terminé, l’installation se poursuit. Vous verrez ensuite qu’il y a encore une opération obligatoire à lancer: la décompression du disque virtuel de la SciViews Box (svbox2018a.vdi) via ‘7z’. En cliquant ‘Finish’, cette décompression démarre toute seule. N’interrompez surtout pas la décompression du disque virtuel! Sinon, votre SciViews Box ne pourra pas démarrer et vous devrez tout recommencer à zéro en désinstallant et réinstallant complètement l’application. Losque tout est installé, vous avez une nouvelle icône sur votre bureau. Poursuivez à la section suivante pour démarrer et paramétrer votre SciViews Box. En option, vous pouvez épingler le nouveau programme dans la barre des tâches. Il sera plus facilement accessible (voir ci-dessous). A.2.2.2 Installation sous MacOS Chargez l’installateur ici ou, pour les étudiants de l’UMONS, récupérez-le depuis le disque StudentTemp de la salle informatique (sous-répertoire SDD/Software/SciViews Box 2018). Si vous le pouvez, placez le fichier svbox2018a.vdi.xz dans le dossier de téléchargements (Téléchargements ou Downloads selon la version de votre MacOS), sinon, ce fichier sera téléchargé au même emplacement (il pèse 2,9Gb)! Double-cliquez sur svbox2018a_macos_setup.dmg. Suivez simplement les instructions. Déplacez à la souris ‘SciViews Box 2018a’ vers le dossier ‘Applications’ dans la fenêtre de l’installeur (cette partie de l’installation est très rapide, donc, vous n’aurez peut-être pas l’impression que quelque chose se passe), Ensuite, toujours dans cette fenêtre, double-cliquez sur le dossier ‘Applications’ et recherchez l’entrée ‘SciViews Box 2018a’. Double-cliquez dessus, Si vous avez chargé l’installateur depuis Internet, il se peut que votre Mac indique un message et vous empêche de l’ouvrir. Dans ce cas, il faut cliquer avec le bouton droit de la souris et selectionner “Ouvrir” dans le menu contextuel tout en maintenant la touche ALT enfoncée, et ensuite cliquer “Ouvrir” dans la boite qui s’affiche. Laissez l’installation se terminer. Cela peut prendre plusieurs minutes. En option, vous pouvez aussi accrocher le programme de manière permanente dans le “Dock” pour le lancer facilement depuis cet endroit. Cliquez bouton droit et dans le menu “Options”, sélectionnez l’entrée “Garder dans le Dock”. A.2.2.3 Installation sous Linux Il est parfaitement possible d’installer la SciViews Box sous Linux. Cependant, un programme d’installation simplifié n’a pas encore été développé pour ce système. Voyez au cas par cas avec vos enseignants pour qu’ils vous expliquent comment installer la SciViews Box manuellement sous Linux. A.2.2.4 Migration et désinstallation Le disque dur virtuel de la SciViews Box est un fichier volumineux de plus de 10Go. L’installeur fait en sorte qu’il soit partagé entre plusieurs utilisateurs de l’ordinateur, et qu’il reste inchangé au cours de son utilisation. Ainsi, VirtualBox enregistrera dans vos dossiers personnels un fichier qui stocke les différences par rapport à l’état de départ de la Box. Il est donc possible de désinstaller partiellement la SciViews Box 2018 sans rien perdre. Pour cela, il suffit de désinstaller l’application (sous Windows, allez dans le panneau de configuration -&gt; Applications -&gt; SciViews Box 2018 -&gt; Désinstaller ; sous MacOS déplacez simplement l’application SciViews box 2018a depuis le dossier Applications vers la corbeille). Vous récupèrerez immédiatement près de 11Go d’espace disque. VirtualBox ne pourra plus démarrer la Box, naturellement, mais conservera vos données. Si besoin, vous pourrez réinstaller simplement l’application SciViews Box 2018a pour retrouver votre Box en l’état. Une désinstallation complète nécessite d’aller d’abord supprimer la machine virtuelle dans VirtualBox (clic bouton droit et sélection de Supprimer...) pour tous les utilisateurs qui ont créé une Box avant de désinstaller l’application principale comme ci-dessus. Si vous avez des projets créés avec des SciViews Box antérieures, deux solutions existent : Gardez-les tel quels. Faites éventuellement une désinstallation partielle de la Box. Vous pourrez toujours revenir plus tard sur ces projets après réinstallation. Migrez-les vers la nouvelle SciViews Box. Copiez vos projets depuis le répertoire shared de l’ancienne Box vers celui de la nouvelle. Dans ce cas, vous devrez vérifier que votre code fonctionne toujours sous la nouvelle Box, et l’adapter éventuellement. A.2.3 Github Desktop Dans ce cours, nous utilisons Git et Github pour gérer les différentes versions de vos projets et les partager avec vos binômes et vos enseignants. Github Desktop facilite grandement la gestion de vos projets sous Git. Ce programme gratuit est très facile à installer : son téléchargement et le lancement de son installeur ne pose pas de problèmes particuliers. Notez toutefois que ce programme n’est pas encore disponible pour Linux. A présent, tous les ligiciels requis sont installés… Il ne reste plus que quelques petites opérations de configuration à réaliser. Voyez ceci à la section suivante. "],
["configuration.html", "A.3 Configuration", " A.3 Configuration Même si la SciViews Box est pré-configurée, vous allez avoir quelques manipulations simples à réaliser pour être complètement opérationnel. Ces étapes sont détaillées ci-dessous. Nous en profiterons par la même occasion par nous familiariser avec quelques uns des outils logiciels que vous utiliserez plus tard, à commencer par le lanceur rapide SciViews Box. A.3.1 Lanceur SciViews Box L’application que vous venez d’installer est un lanceur rapide qui facilite le démarrage, la fermeture et la gestion de votre machine virtuelle SciViews Box 2018a. Démarrez-là et vous verrez la fenêtre suivante: Le message en rouge n’apparait pas systématiquement. Il signale des éléments importants. Ici, il indique que la configuration de la SciViews Box doit encore être faite, et pour cela, vous devez (1) la démarrer à l’aide du gros bouton en haut à gauche, (2) vous logger (mot de passe = sv), et (3) répondre Yes lorsqu’une boite de dialogue vous propose d’installer ‘svbox2018a v1.0.0’. Cette dernière étape est importante! Ne cliquez pas No ici, sous peine de ne pas avoir une machine virtuelle configurée comme celle de vos collègues! Le mot de passe vous sera redemandé, et ensuite, l’installation se poursuivra. Elle pourra prendre plusieurs minutes. Soyez patient. Vous pourrez ouvrir la fenêtre du terminal où s’opère le travail pour en suivre la progression, si vous le souhaitez. A la fin vous verrez la fenêtre du configurateur de la SciViews Box apparaître. A.3.2 Configurateur de la Box Prenez le temps de parcourir les différents éléments dans cette fenêtre18. La partie à gauche en haut concerne la configuration du clavier. En effet, la machine virtuelle utilisera votre clavier physique, mais elle n’a aucun moyen de déterminer de quel modèle il est. Vous allez donc l’indiquer maintenant. Utilisez la zone de texte intitulée Test area (type here) pour vérifier que la machine virtuelle interprète correctement les touches de votre clavier. Pour le changer, cliquez sur le bouton Change keyboard layout. La boite de dialogue de sélection du clavier apparait. Elle propose des configurations différentes sous forme de représentations graphiques, avec les touches caractéristiques surlignées en jaune. Vous pouvez entrer les premières lettres du type de clavier pour aller directement à la configuration correspondante dans la liste (ex.: entrez be pour un clavier belge). Si votre clavier ne se trouve pas dans les templates les plus courants, configurez-le à l’aide du bouton Other keyboard.... Fermez cette fenêtre pour retourner au configurateur lorsque vous aurez fini. Enfin, toujours concernant le clavier, la case à cocher Exchange left CTRL / CMD (Mac shortcuts) permet d’utiliser les raccourcis Mac (comme Cmd-c pour copier et Cmd-v pour coller à la place de Ctrl-c ou Ctrl-v sur un PC. Cette option n’est utile qu’aux possesseurs d’un Mac qui veulent avoir des raccourcis plus homogènes entre leur système MacOS hôte et la machine virtuelle19. Juste en dessous, vous voyez la configuration du fuseau horaire. Ici aussi, votre machine virtuelle n’a pas l’information de votre système hôte, et peut donc ne pas afficher l’heure correctement. Vous avez la possibilité de corriger cela en cliquant sur le bouton Change time zone. Vous devez débloquer la boite de dialogue (bouton Unlock en bas, puis entrer le mot de passe pour pouvoir effectuer des changements). Les trois boutons à gauche en bas servent à choisir le stylage des fenêtres, le set d’icônes et l’image d’arrière plan de votre SciViews Box. C’est ici que vous pourrez la paramétrer au mieux pour qu’elle vous plaise visuellement. A noter que, si vous double-cliquez sur les entrées dans les boites de dialogue de configuration, vous allez pouvoir prévisualiser l’effet en live. Utile pour apprécier le rendu avant de faire son choix! La zone en bas à droite permet de modifier le mot de passe. Pour rappel, il s’agit d’un mot de passe simple et peu sécure par défaut: sv. En fait, vous n’avez pas réellement besoin d’un mot de passe à l’intérieur de votre SciViews Box telle qu’elle est configurée car vous ne pouvez y accéder qu’en local à partir de l’ordinateur hôte. Par contre, il est possible d’ouvrir l’accès. A ce moment-là, il serait utile, et même indispensable, de modifier le mot de passe. Dans le cadre de votre utilisation de la SciViews Box pour ce cours, que ce soit sur les machines de la salle de T.P., ou sur votre ordinateur personnel, ne changez pas le mot de passe! Votre machine virtuelle est déjà protégée par votre système hôte puisque seul un accès local est autorisé. La zone en haut à droite permet de configurer votre compte Git. Comme vous allez utiliser Git et Github de manière intensive tout au long de ce cours, veuillez configurer cette partie du système correctement d’amblée! Les trois boutons du bas proposent de s’enregistrer sur trois systèmes distants d’hébergement de dépôts Git (si vous ne savez pas ce que c’est, imaginez juste que c’est là que vous allez pouvoir entreposer de manière sûre tous vos projets!): Github, Gitlab ou Bitbucket. Tous trois ont des avantages et des inconvénients, et ils proposent tous des utilisations gratuites dans certains cas. Durant nos cours de Science des Données à l’UMONS, nous utiliserons Github. Cette utilisation sera gratuite pour vous, et vous allez pouvoir déjà commencer à construire votre identité professionnelle sur le Net par son intermédiaire. Donc, enregistrez-vous de manière sérieuse. Choisissez un login représentatif de vos nom et prénom, pas un truc louffoque ou rigolo sur le moment, mais que vous regretterez plus tard, sachant que votre login ne pourra pas être changé ensuite! Vous allez donc vous créer un compte sur Github en cliquant sur le bouton correspondant, et en indiquant un login et un mot de passe. Nous vous demandons également d’utiliser expressément et uniquement votre adresse email UMONS ici : prénom.nom@student.umons.ac.be. En effet, ce sera, pour nous, notre seul moyen de vous identifier sans erreur sur Github lorsque nous interviendrons pour vous conseiller et/ou pour corriger vos travaux. Une fois enregistré sur le site de Github, reportez votre login et votre adresse email dans le configurateur de la SciViews Box, pour que Git puisse vous identifier correctement en local20. Une fois tout ceci effectué vous pourrez cliquer sur le bouton OK de la fenêtre du configurateur SciViews Box. La machine virtuelle devra redémarrer pour appliquer toutes les modifications de manière durable. Cliquez également OK donc dans la boite de dialogue qui apparait ensuite (sinon, elle redémarrera toute seule après 30 sec) : A.3.3 Installation des tutoriels Nous allons maintenant installer les tutoriels liés à ces cours de science des données biologiques. Vous allez apprendre par la même occasion comment ajouter des applications dans votre SciViews Box. Cela se fait en trois étapes: Télécharger l’installeur de l’application. Vous le trouverez à l’adresse http://go.sciviews.org/BioDataScience1. Assurez-vous de bien le charger dans le répertoire Downloads ou Téléchargements par défaut sur votre ordinateur21. Téléchargez, de même, la mise-à-jour vers la version 2.0 de la SciViews Box à l’adresse http://go.sciviews.org/svbox2018a2. Rentrez dans le lanceur rapide de la SciViews Box. Il repère les autoinstalleurs et les déplace dans le dossier partagé pour les rendre utilisables par la SciViews Box. Vous devez voir un message indiquant la disponibilité d’autoinstalleur(s). Vos fichiers téléchargés ont également disparus du répertoire de téléchargement à ce stade, Rentrez dans la SciViews Box depuis le lanceur. Si la Box était déjà active ou si elle est réveillée du mode veille, vous allez devoir vous délogger et relogger pour que l’installation démarre, … sinon, vous allez voir directement le message suivant qui propose d’installer ces apps (cliquez sur Yes, bien sûr, pour l’installer). Si le message n’apparait pas, voici comment se délogger (log out). Ensuite, entrez votre mot de passe comme d’habitude pour vous relogger… A ce moment, le message doit apparaitre, et l’installation doit se faire après avoir cliqué le bouton Yes. Bravo! Vous avez terminé l’installation et la configuration de votre SciViews Box. Cependant, nous allons encore effectuer une petite opération qui vous facilitera la vie, et nous vous expliquerons par la même occasion comment accéder aux fichiers respectifs de la machine virtuelle et du système hôte dans la section suivante. A.3.4 Accès aux fichiers Le disque physique de votre ordinateur hôte, et le disque virtuel de la SciViews Box sont deux choses différentes. Cela signifie que vous avez, en réalité deux ordinateurs et deux disques indépendants. Donc, vous n’accédez pas aux fichiers d’une machine à partir de l’autre22. Ce n’est pas pratique, et ce n’est pas vrai pour un dossier particuler nommé shared. Ce dossier shared est synchronisé en temps réel entre les deux systèmes. C’est donc l’endroit idéal pour échanger des données et pour faire collaborer vos deux machines. Inutile de préciser, donc, que nous travaillerons essentiellement à l’intérieur de ce dossier. Un sous-dossier, nommé projects sera utilisé pour héberger toutes nos analyses. Il est donc primordial d’y accéder facilement à la fois depuis l’ordinateur hôte et depuis la SciViews Box. Vous allez donc apprendre à retrouver ce dossier projects facilement. Sur votre ordinateur hôte, ce dossier est un peu difficile à trouver en naviguant dans l’explorateur de fichiers (ou le Finder sur le Mac). Pour cette raison, le lanceur rapide propose un bouton pour y accéder plus facilement. Une fois dans le dossier shared, nous vous conseillons d’épingler le sous-dossier projects dans les raccourcis rapides de votre explorateur de fichiers. Voici comment faire sous Windows et sous MacOS. Sous Windows, cliquez bouton droit sur projects, et sélectionnez “épingler dans Accès rapide”. Sous MacOS, vous glissez-déposez projects dans la barre latérale du Finder. Dans la SciViews Box, ce dossier est accessible depuis deux endroits: /media/sf_shared et ~/shared (~ représente le répertoire de l’utilisateur, c’est-à-dire /home/sv). Ici aussi vous pouvez épingler votre dossier projects pour en facilter l’accès: Les deux moyens d’accéder au dossier projects dans la SciViews Box et comment l’épingler sur le côté. A retenir: le dossier shared et ses sous-dossiers comme projects sont considérés un peu comme des dossiers réseau par la SciViews Box. Cela implique que certaines fonctions du système de fichiers n’y sont pas accessibles. Parmi celles-ci, la poubelle. Donc, vous ne pourrez qu’effacer complètement des items en cliquant bouton droit et sélectionnant ‘Delete’ dans le menu contextuel dans le gestionnaire de fichiers. Si vous essayer de placer des fichiers ou dossiers depuis shared dans la poubelle de la SciViews Box, cela vous sera refusé (voir copie d’écran ci-dessous). Par contre, cela fonctionne très bien depuis l’ordinateur hôte. Un tout dernier point concernant les ordinateurs de la salle de T.P. de l’UMONS. Pour des questions de performance, la machine virtuelle SciViews Box, et le dossier shared ne sont pas sur votre compte, mais directement sur le disque de l’ordinateur. Cela signifie qu’ils ne sont pas transportables vers un autre ordinateur. Vous pouvez créer une copie de shared dans mes documents ou sur une clé USB pour les transporter vers un autre ordinateur… mais nous verrons que cela n’est pas nécessaire pour tout ce que vous stockerez sur Github. En effet, vous avez accès à ces contenus depuis n’importe où via n’importe quelle connexion internet. Si jamais vous voulez retourner plus tard au configurateur de la SciViews Box, vous n’aurez qu’à cliquer sur son icône tout en haut à droite dans la barre supérieure.↩ Le Mac définit ses raccourcis claviers différemment du PC. Outre l’inversion de l’utilisation des touches Ctrl et Cmd, le Mac possède deux touches Alt, une à gauche et une à droite. Le PC a, par contre, deux touches correspondantes, mais celle de droite est nommée Alt Gr. Ces touches jouent des rôles différents: raccourcis claviers pour Alt et accès aux touches de niveau 3 et 4 pour Alt Gr. Pour les utilisateurs Mac, notez que vos deux touches Alt ont des rôles différents dans la SciViews Box comme pour un clavier PC. Enfin, VirtualBox réserve une touche clavier à son propre usage. Par défaut, c’est la touche Cmd ou Win de droite. Il est déconseillé de modifier ce choix car toutes les autres touches sont indispensables dans la SciViews box!↩ A la première utilisation de Git à l’intérieur du logiciel RStudio, votre login et votre mot de passe vous seront également redemandés. De même, vous devrez également fournir ces informations dans Github Desktop et la première fois que vous naviguerez vers https://github.com depuis le navigateur Web de votre PC hôte. Mais ensuite, vous accèderez immédiatement au service.↩ Il pourra ainsi être replacé au bon endroit et exécuté dans la Box↩ Le presse-papier est synchronisé entre les deux machines pour le texte qui y est copié.↩ "],
["svbox-use.html", "A.4 Utilisation", " A.4 Utilisation Une fois votre machine virtuelle configurée, vous vous trouvez confronté à cet écran qui montre le fond d’écran et un ensemble d’items par dessus. Nous l’appellerons le bureau de la SciViews Box. Cette machine virtuelle utilise le système d’exploitation Linux. Vous pouvez accèder au application présentes sur cette machine à partir du menu Applications en haut à gauche du bureau. Ce dernier offre un menu déroulant avec l’ensemble des applications disponibles. Ces applications sont rangé en dossier tel que Favorites, Recently Used , All, … Le “dock” en bas du bureau permet de lancer des applications rapidement et d’accéder aux fenêtres des applications en cours d’exécution tel que RStudio, Jupyter, Spyder,… Pour accèder à vos dossiers et fichiers, il suffit de cliquer sur l’icône en forme de dossier avec une image de petite maison que l’on retrouve également dans le dock. "],
["prise.html", "B Prise en main", " B Prise en main Cette annexe comprend une description détaillée des différents outils utilisés dans la cadre de cette formation. Passez à la section suivante pour découvrir les outils. (ex: B.1 RStudio). "],
["rs.html", "B.1 RStudio", " B.1 RStudio Sélectionnez l’icône RStudio dans le dock (cercle bleu avec un R blanc au centre). Un login vers RStudio apparaît. Il faut y entrer les informations suivantes : Username : sv Password : sv Cochez éventuellement Stay signed in pour éviter de devoir réentrer ces informations continuellement : RStudio s’ouvre. C’est votre interface de travail à partir de laquelle vous allez piloter R. La fenêtre principale comporte différents éléments : Une barre de menu et une barre d’outils générale en haut Un panneau à gauche intitulé Console où vous pouvez entrer des instructions dans R pour manipuler vos données Un panneau à droite en haut qui comprend plusieurs onglets, dont Environnement qui vous indique les différents items (on parle d’objets) chargés en mémoire dans R (mais pour l’instant, il n’y a encore rien). Un panneau en bas à droite comportant lui aussi plusieurs onglets. Vous devriez voir le contenu de Files au démarrage, un explorateur de fichiers simplifié relatif au contexte de travail actuel dans RStudio. Pour l’instant, aucun document de travail n’est encore ouvert. Pour en créer un, ou ouvrir un document existant, vous utilisez le menu Files, ou encore, le premier bouton de la barre d’outils générale : Le menu Session permet d’interagir directement avec R qui est lancé automatiquement en arrière plan dès que RStudio est ouvert. Par exemple, il est possible de relancer R à partir d’une entrée dans ce menu : Le menu Help propose différentes possibilités pour accéder à la documentation de R ou de RStudio. Les aide-mémoires (“cheatsheets” en anglais) sont très pratiques lors de l’apprentissage. Nous conseillons de les imprimer et de les consulter régulièrement. Le dernier bouton de la barre d’outils générale, intitulé Project permet d’ouvrir, fermer, et gérer les projets RStudio. Vous avez maintenant repéré les éléments fondamentaux de l’interface de RStudio. A ce stade vous pouvez vous familiariser avec l’aide-mémoire relatif à l’IDE RStudio. Vous verrez qu’il y a beaucoup de fonctionnalités accessibles à partir de la fenêtre principale de RStudio. Ne vous laissez pas intimider : vous les apprendrez progressivement au fur et à mesure de l’utilisation du logiciel. B.1.1 Projet dans RStudio Un projet sert, dans RStudio, à organiser son travail. Un projet va regrouper l’ensemble des jeux de données, des rapports, des présentations, des scripts d’une analyse généralement en relation avec une ou plusieurs expériences ou observations réalisés sur le terrain ou en laboratoire. Voici à quoi ressemble l’interface de RStudio lorsque vous ouvrez un projet : Notez que le nom du projet est mentionné en haut à droite. Notez également, que le répertoire de base de votre projet est le répertoire actif dans l’onglet Console (~/shared/projects/mon_premier_projet/ dans l’exemple), et que l’onglet Files affiche son contenu. Un fichier mon_premier_projet.Rproj y est placé automatiquement par RStudio. Ce fichier contient les paramètres de configuration propres à ce projet23. C’est aussi une excellente façon de repérer qu’un répertoire est la base d’un projet RStudio, en repérant ce fameux fichier .Rproj. B.1.1.1 Création d’un projet Créez votre premier projet en suivant les quatre étapes suivantes : Étape 1. Dans RStudio, Sélectionnez le bouton tout à droite dans la barre d’outils générale de RStudio qui ouvre un menu contextuel relatif aux projets. Sélectionnez y l’entrée New Project.... Étape 2. Une boite de dialogue s’ouvre. Sélectionnez New Directory pour créer votre projet dans un nouveau dossier. Il est également possible d’employer un dossier existant comme point de départ Existing Directory). Étape 3. Sélectionnez New Project tout en haut dans l’écran suivant qui vous propose également des projets particuliers (que nous n’utiliserons pas pour l’instant). Étape 4. Ensuite, RStudio vous demander quelques informations pour préconfigurer votre projet. Nommez le projet : Directory name. Indiquez ici project_test Indiquez où vous voulez le placer : Create project as subdirectory of. Sélectionnez le sous-dossier projects dans le dossier shared partagé entre la SciViews Box et la machine hôte. Sélectionnez Create a git repository Désélectionnez Use packrat with this project(il est important de ne pas sélectionner packrat, sous peine de dupliquer de nombreux packages R dans votre projet) Vous utilisez aussi le menu spécial projet pour créer un nouveau projet (New Project...), ouvrir un projet existant (Open Project...) ou encore fermer un projet (Close Project). Vous remarquez également que les derniers projets employés sont placés sous les trois options citées ci-dessus afin d’y accéder plus rapidement. Un projet ne doit bien sûr être créé qu’une seule fois ! Une fois les étapes ci-dessus effectuées, vous retournez simplement à votre projet en ouvrant le menu contextuel projets et en sélectionnant votre projet dans la liste. S’il n’y apparait pas, choisissez Open Project... et sélectionnez le fichier .Rproj relatif à votre projet. Ne créez bien évidemment jamais de projet à l’intérieur des dossiers d’un autre projet, surtout si vous utilisez Git. Sinon, RStudio va s’emméler les pinceaux ! B.1.1.2 Organisation d’un projet Le répertoire projects contient maintenant un projet RStudio intitulé project_test. Depuis la SciViews Box, il se situe dans : /home /sv /shared /projects /project_test # Le répertoire de base du projet project_test.Rproj # Fichier de configuration du projet créé par RStudio .gitignore # Fichier relatif à la gestion de version Vous devez maintenant structurer votre projet afin d’avoir différents sous-répertoires pour organiser au mieux le travail. Ceci concerne à la fois les données et les rapports d’analyse en lien avec ce projet. Cliquez sur le bouton New Folder dans la barre d’outils de l’onglet Files et appelez ce nouveau dossier data. Ajoutez également les dossiers analysis et R. Vous pouvez faire cela depuis RStudio, mais aussi depuis le système hôte si c’est plus confortable pour vous. /home /sv /Shared /Projects /project_test # Le répertoire de base du projet analysis # Le dossier qui comprend toutes les analyses (rapport, présentation,...) data # Le dossier qui comprend toutes les données project_test.Rproj # Fichier de configuration du projet créé par RStudio .gitignore # Fichier relatif à la gestion de version R # Le dossier qui comprend tous les scripts d&#39;analyse Vous obtenez donc un projet configuré de la manière suivante : L’organisation cohérente d’un projet est indispensable pour le bon fonctionnement et la clarté de vos analyses de données. B.1.1.3 Chemins relatifs dans un projet L’utilisation d’un projet permet de structurer de manière cohérente son travail. Vous allez maintenant devoir rendre votre projet portable. Un projet RStudio pourra être qualifié de portable s’il est possible de déplacer son répertoire de base et tout ce qu’il contient (ou le renommer) sans que les analyses qu’il contient n’en soient affectées. Ceci est utile pour copier, par exemple, le projet d’un PC à un autre, ou si vous décidez de restructurer vos fichiers sur le disque dur. La première règle est de placer tous les fichiers nécessaires dans le dossier du projet ou dans un sous-dossier. C’est ce que nous venons de faire plus haut. La seconde règle est de référencer les différents fichiers au sein du projet avec des chemins relatifs. Nous allons maintenant apprendre à faire cela. /home /sv /Shared /projects /project_test # Le répertoire de base du projet analysis # Le dossier qui comprend toutes les analyses (rapport, présentation,...) rapport_test.rmd # Rapport d&#39;analyse data # Le dossier qui comprend toutes les données dataset.csv # jeu de données exemple project_test.Rproj # Fichier de configuration du projet créé par RStudio .gitignore # Fichier relatif à la gestion de version R # Le dossier qui comprend tous les scripts d&#39;analyse Les différents systèmes d’exploitations (Windows, MacOS, Linux) utilisent des conventions différentes pour les chemins d’accès aux fichiers. Dans notre cas, la machine virtuelle utilise un système d’exploitation Linux. La barre oblique (/ dite “slash” en anglais) sépare les différents dossiers imbriqués sous Linux et sous MacOS. Le système d’exploitation Windows utilise pour sa part, la barre oblique inversée (\\, dite “backslash” en anglais, mais dans R et RStudio, vous pourrez également utiliser le slash /, ce que nous vous conseillons de faire toujours pour un maximum de compatibilité entre systèmes). Par exemple, votre fichier dataset.csv se référence comme suit dans la SciViews Box, donc sous Linux : /home/sv/shared/projects/project_test/data/dataset.csv Ce chemin d’accès est le plus détaillé. Il est dit chemin d’accès absolu au fichier. Vous noterez qu’il est totalement dépendant de la structure actuelle des dossiers sur le disque. Si vous renommez project_test ou si vous le déplacez ailleurs, la référence au fichier sera cassée ! Ainsi, si vous partagez votre projet avec un collaborateur qui le place ailleurs sur son disque dur, le chemin d’accès devra être adapté sans quoi l’analyse ne pourra plus s’exécuter correctement. Décodons ce chemin d’accès : /, racine du système /home/sv/, notre dossier personnel comme utilisateur sv /home/sv/shared/, le dossier partagé entre la SciViews Box et notre PC hôte /home/sv/shared/projects/project_test/, le dossier de base de notre projet /home/sv/shared/projects/project_test/data/, le répertoire qui contient le fichier dataset.csv. Le répertoire utilisateur /home/&lt;user&gt; est différent sous MacOS (il s’appelle /Users/&lt;user&gt;) et sous Windows (il se nomme généralement C:\\Users\\&lt;user&gt;). Comme c’est un répertoire clé, et qu’il est impossible d’écrire un chemin absolu qui soit le même partout, il existe un raccourcis : le “tilde” (~) qui signifie “mon répertoire utilisateur”. Ainsi, vous pouvez aussi accéder à votre jeu de données dataset.csv comme ceci : ~/shared/projects/project_test/data/datasets.csv Ce chemin d’accès est déjà plus “portable” d’un système à l’autre et d’un utilisateur à l’autre. Il est donc à préférer. Notez que sous R, vous devez doubler les backslashs sous Windows (~\\\\Documents\\\\...). Ce n’est ni très esthétique, ni compatible avec les deux autres systèmes. Heureusement, R comprend aussi le slash comme séparateur sous Windows, de sorte que la même syntaxe peut être utilisée partout ! Nous vous conseillons donc d’utiliser aussi systématiquement les slashs sous Windows dans R ou RStudio. Si cette façon d’écrire le chemin d’accès est compatible entre les trois systèmes d’exploitation, elle ne permet toujours pas de déplacer ou de renommer notre projet. L’utilisation d’un chemin relatif permet de définir la position d’un fichier par rapport à un autre dossier qui est dit le répertoire actif. A titre d’exemple, nous voulons faire référence au jeu de données dataset.csv depuis notre rapport rapport_test.Rmd. Demandez-vous d’abord quel est le répertoire actif. Pour un fichier R Markdown ou R Notebook, c’est facile, c’est le dossier qui contient ce fichier. Dans la console R, cela peut varier selon le contexte. Si vous avez ouvert un projet, c’est le répertoire de base du projet par défaut, mais cela peut être modifié. Le répertoire actif pour R est toujours indiqué en gris à côté de l’onglet Console dans RStudio. Vous pouvez aussi interroger R à l’aide de l’instruction getwd(): getwd() Vous pouvez réaliser cela dans un chunk R dans votre document R Notebook par exemple : Une fois que vous connaissez le répertoire actif, vous naviguez à partir de celui-ci. Il existe une convention pour reculer d’un dossier dans la hiérarchie : pour cela vous indiquez .. à la place d’un nom de dossier. Voici ce que cela donne : ../data/dataset.csv Comment lit-on ceci? Tout d’abord, notez (c’est très important) que le chemin d’accès ne commence pas par / (Linux ou MacOS), ou C:/ (ou toute autre lettre, sous Windows). C’est le signe que l’on ne part pas de la racine du système de fichier, mais du répertoire actif. Ensuite, les différents éléments se décryptent comme suit : ~/shared/projects/project_test/analysis, répertoire actif au départ pour le document R Notebook .., retour en arrière d’un niveau. On est donc dans ~/shared/projects/project_test /data, naviguer dans le sous-dossier data. On est donc maintenant dans ~/shared/projects/project_test/data. C’est le répertoire qui contient le fichier qui nous intéresse /datasets.csv, le nom du fichier référencé. A noter que si le fichier se trouve déjà dans le répertoire actif, le chemin relatif se résume au nom du fichier directement ! Nulle part dans ce chemin relatif n’apparaît le nom du répertoire de projet, ni d’aucun autre répertoire parent. Ainsi, il est possible de renommer ou déplacer le projet sans casser la référence relative à n’importe quel fichier à l’intérieur de ce projet. Donc, en utilisant uniquement des références relatives, le projet reste parfaitement portable. B.1.2 Scripts R dans RStudio Un script R est une suite d’instructions qui peuvent être interprétées pour effectuer nos analyses. Ce script est stocké dans un fichier dont l’extension est .R, et que l’on placera de préférence dans le sous-dossier R de notre projet. Un script R s’ouvre dans la fenêtre d’édition de RStudio. Les parties de texte précédées d’un dièse (#) sont des commentaires. Ils ne sont jamais exécutés, mais ils permettent de structurer et d’expliquer le contenu du document (ou bien d’empêcher temporairement l’exécution d’instructions). Afin de bien documenter vos scripts, Commencez-les toujours par quelques lignes de commentaires qui contiennent un titre, le nom du ou des auteurs, la date, un copyright éventuel, … L’utilisation de sections comme à la ligne 6 ci-dessus est vivement conseillée. Ces sections sont créée à l’aide de l’entrée de menu Code -&gt; Insert Section... dans RStudio. Elles sont reprises dans le bas de la fenêtre édition pour une navigation rapide dans le script. B.1.2.1 Création d’un script R Vous avez à votre disposition plusieurs méthodes pour ouvrir un nouveau script R dans RStudio, dont deux vous sont montrées dans l’animation ci-dessous. B.1.2.2 Utilisation d’un script R Un script R est un document natif de R. Ce dernier va interpréter les intructions qui compose le script et qui ne sont pas précédées d’un dièse (cliquez sur Run dans la barre d’outils de la fenêtre d’édition, ou utilisez le raccourci clavier Ctrl+Enter ou Cmd+Enter sur MacOS pour exécuter des instructions). Un script R doit être organisé de manière cohérente afin d’être exécutable de haut en bas. Dans l’exemple ci-dessus, on commence par : Étape 1. Importer les principaux outils avec l’instruction SciViews::R. Étape 2. Utiliser l’instruction urchin &lt;- read(&quot;urchin_bio&quot;, package = &quot;data.io&quot;) pour importer le jeu de données urchin_bio provenant du package data.io et l’assigner à urchin. On retrouve à présent urchin dans l’environnement global (Global environment dans l’onglet Environnement dans le fenêtre en haut à droite) de RStudio. Étape 3. .?urchin et View(urchin) donnent des renseignements sur le jeu de données en renvoyant vers la page d’aide du jeu de données et en ouvrant ce jeu de données dans une fenêtre de visualisation. Étape 4. Réaliser des graphiques avec la fonction chart(). Notez que les instructions exécutées dans le script sont envoyées dans la fenêtre Console en bas à gauche. B.1.3 R Markdown/R Notebook dans RStudio Un document R Markdown est un fichier dont l’extension est .Rmd. Il combine à la fois des instructions R (pour les analyses) et le langage Markdown (pour le texte). le R Markdown ne vous permet pas de visualiser directement le résultat final d’un rapport d’analyse24 Tout comme dans un script R, les intructions doivent être également exécutées lors de la réalisation du rapport. Une forme spéciale de document R Markdown est le R Notebook. Ce dernier est un peu un intermédiaire entre un script R et un R Markdown. Il se présente de manière très similaire à ce dernier, mais vous pouvez également exécuter le code qu’il contient ligne par ligne comme dans un script. Un document R Markdown / R Notebook se structure de la manière suivante : Un préambule Des zones d’édition Le language employé est le Markdown Des zones de code R Ces zones de codes sont appelée des chunks Le préambule est nécessairement situé au tout début du document et est balisé à l’aide de trois tirets --- sans rien d’autre sur une ligne au début et à la fin. Le préambule comporte un ensemble d’entrées de type nom: valeur qui configurent le document ou la façon dont il sera compilé en rapport final. Nous pouvons y indiquer le titre principal, le ou les auteurs, la date, … Le reste du document R Markdown est subdivisé en zones successives de texte et de code R (les fameux “chunks”) contrastés sur des fond de couleurs différentes dans RStudio. Les zones de texte des parties Markdown où vous pouvez écrire votre prose. Les chunks contiennent des instructions qui vont être interprétées pour réaliser un calcul, un graphique, un tableau, etc. Le résultat de ce traitement sera placé à cet endroit dans le rapport final. Ces chunks sont balisés en entrée par trois apostrophes inverses suivies d’accolades contenant des instructions relatives au programme à utiliser, par exemple, ```{r} pour des chunks faisant appel au logiciel R, et sont terminés par trois apostrophes inverses (```). Dans les zones Markdown, vous pouvez ajouter des balises qui permettront de formater votre texte dans la version finale de votre rapport. Par exemple, un ou plusieurs dièses (plus communément connu par sont appellation en anglais : “hastag”) en début de ligne suivi d’un espace indique que la suite correspond à un titre. Titre de niveau 1 avec un seul dièse, de niveau 2 avec deux dièses, et ainsi de suite jusqu’à 6 niveaux possibles. Dans la capture d’écran ci-dessous, nous avons remplacé tout le contenu par défaut d’un R Notebook (à part le préambule) par une série de titres de niveau 1 correspondant à la structure générale d’un rapport scientifique : Introduction Objectif Matériel et méthodes Résultats Discussion Conclusions B.1.3.1 Création d’un R Markdown/Notebook Vous avez à votre disposition deux méthodes pour ouvrir un nouveau R Notebook dans RStudio. Voyez l’animation ci-dessous. B.1.3.2 Utilisation d’un R Markdown/Notebook Afin de visualiser les résultats des chunks dans votre rapport final, Vous devez veiller à exécuter chaque chunks dans l’ordre dans un R Notebook. Ceci n’est pas nécessaire dans un R Markdown, mais dans ce cas, tous les chunks sont systématiquement recompilés à chaque génération de rapport, ce qui peut être pénible si les calculs sont longs. Pour exécuter un chunk, vous pouvez : cliquer sur le bouton “play”, sous forme d’une flèche verte pointant vers la droite, situé en haut à droite du chunk cliquer sur Run et sélectionner Run Current Chunk dans le menu déroulant qui apparait Employer le raccourci clavier Ctrl+Shift+Enter Le bouton Run propose plusieurs actions intéressantes : Exécuter la/les ligne(s) d’instruction sélectionnée(s) : Run Selected Line(s) Exécuter le chunk en entier : Run Current Chunk Exécuter tous les chunk précédents : Run All Chunk Above Redémarer la console R et exécuter tous les chunks: Restart R and Run All Chunks. Cette action est particulière intéressante pour s’assurer que le document est réellement reproductible ! … Aprés la phase d’édition du texte (et des intructions dans les chunks pour un document R Notebook), vous pouvez visualiser votre rapport final en cliquant sur le bouton Preview (Notebook) ou Knit (Markdown). Le rapport est rapidement généré avec un rendu simple et professionnel. Par défaut, ce rapport présente le texte que vous avez écrit, avec les résultats que vous avez choisi de générer via R, mais également les instructions que vous avez employée pour obtenir ces résultats. Ceci permet de mieux comprendre, directement dans le rapport, comment tout cela a été calculé. Il est possible de cacher le code (dans un document généré depuis un Notebook R), ou d’indiquer une directive de compilation dans les chunks pour éviter que le code ne s’imprime dans le rapport final. Voyez les options en cliquant sur le petit engrenage à côté de la flèche verte en haut à droite du chunk. Consultez l’aide-mémoire de R Markdown accessible à partir du menu RStudio Help -&gt; Cheatsheets -&gt; R Markdown Reference Guide, voir chunk options p.2-3 pour plus d’informations sur les nombreuses options disponibles. Par exemple, en ajoutant la directive echo=FALSE dans la balise d’entrée d’un chunk (```{r, echo=FALSE}), on empèche d’imprimer le code de ce chunk dans le rapport. Notez que sur la droite du bouton Preview ou Knit, vous avez un autre bouton représenté par un petit engrenage. Il donne accès à un menu déroulant qui vous donne la possibilité de modifier la façon de générer vos rapports. L’entrée tout en bas Output Options... permet de paramétrer la présentation du rapport. Si vous cliquez sur la petite flèche noire pointant vrs le bas juste après Preview ou Knit, vous avez un autre menu déroulant qui donne accès aux différents formats possibles : HTML, PDF, Word, etc. Essayez les différentes options pour visualiser comment votre rapport se présente dans les différents formats. N’éditer jamais à la main un fichier .Rproj. Laisser RStudio s’en occuper tout seul.↩ Les systèmes d’édition professionnels dissocient en effet le fond de la forme : vous rédiger d’abord le contenu, et ensuite, vous indiquer le style à lui appliquer.↩ "],
["github-1.html", "B.2 Github", " B.2 Github TODO "],
["github-classroom.html", "B.3 Github Classroom", " B.3 Github Classroom TODO "],
["learnr.html", "C Tutoriels “learnr”", " C Tutoriels “learnr” En complément de ce syllabus, vous allez utiliser également des tutoriels interactifs construits avec learnr. Si ce n’est déjà fait, commencez par installer ces tutoriels dans votre SciViews Box (voir A.3.3). Entrez l’instruction ci-dessous dans la fenêtre Console de RStudio suivie de la touche Entrée : BioDataScience::run() La liste des tutoriels vous est proposée (notez que ces tutoriels comme les autres outils pédagogiques sont encore en cours de développement, mais plusieurs vous seront disponibles): 1: 02a_base 2: 02b_decouverte 3: 02c_nuage_de_points 4: 02d_test ... Entrez le numéro correspondant au tutoriel que vous voulez exécuter et un document interactif apparait. Par exemple, en entrant 1 suivi de la touche Entrée, vous êtes redirigé vers le tutoriel concernant les base de R et intitulé 02a_base. La première chose à vérifier à l’ouverture du tutoriel interactif est le nom d’utilisateur (équivalent à votre username dans Github) et votre adresse email (adresse email associée à votre compte Github ou de votre compte d’étudiant). En effet, votre progression sera enregistrée, mais cela ne peut se faire que si vous renseignez ces données correctement avant de travailler dans le tutoriel “learnr”. Le learnr est un outil pédagogique mis au point afin de proposer des tutoriaux interactifs comprennant des illustrations, des questions à choix multiples, des exercices R, … Les learnr qui vous seront proposés tout au long de votre formation seront composé de la manière suivante : Objectif Introduction Une série d’exercices Conclusion Vous retrouvez d’ailleurs cette structure en haut à gauche de ce dernier. Chaque page du tutoriel est importante et nécessite votre attention. Objectifs Cette section va détailler l’ensemble des notions que vous allez apprendre à maitriser durant ce tutoriel. Dans le cadre de ce premier tutoriel, l’objectif est de découvrir les bases du language R. Introduction Cette section va vous replacer dans le contexte du tutoriel interactif avec un rappel succinct des notions théoriques indispensables afin de répondre à la série d’exercices. Cette section ne remplace pas les autres matériels pédagogiques qui vous sont proposés. Vous devez travailler dans l’ordre proposé dans le présent manuel au sein de chaque module pour vous préparer correction au learnr de test en fin de section. Une serie d’exercices Cette section peut être de longueur très variable en fonction de la difficulté et des notions à appréhender. Des zones de codes R vous sont proposées dans les exercices. Elles vous permettent d’expérimenter directement des instructions dans R depuis le document learnr. Pour exécuter ces instructions, il faut cliquer sur Run Code. Vous pouvez le faire autant de fois que vous voulez. Modifiez le code, cliquez Run Code, analysez le résultat, modifiez votre code, recliquez Run Code, etc… juqu’à ce que vous soyez satisfait du résultat. Finissez l’exercice et soumettez votre réponse en cliquant sur Submit Answer. Des boutons Hint, lorsqu’ils sont présents, vous proposent des aides si vous êtes bloqués. Les boutons Solution… montrent ce qu’il fallait entrer. N’allez pas voir directement la solution. Essayez d’abord par vous même ! Conclusion Cette section termine ce tutoriel et propose de laisser des commentaires avec l’utilisation de dièse #. Fermez le tutoriel lorsqu’il est terminé. En retournant dans RStudio, vous devez déconnecter votre process R qui est toujours occupé à servir la page learnr du tutoriel. Pour cela, placez le curseur dans la fenêtre Console et cliquez sur la touche Esc. A ce moment, vous récupérez la main dans R et pouvez à nouveau retravailler normalement dans RStudio. "],
["redaction-scientifique.html", "D Rédaction scientifique", " D Rédaction scientifique La rédaction scientifique respecte un certain caneva expliqué dans cette annexe. Pour en savoir plus… Recherche documentaire et aide à la création (ReDAC). L’Université de Mons met à disposition de ses étudiants un cours en ligne qui rassemble un maximum de renseignements sur la rédaction de rapports scientifiques. "],
["organisation.html", "D.1 Organisation", " D.1 Organisation Un rapport scientifique respecte généralement le schéma suivant : Table des matières (facultatif) Introduction But Matériel et méthodes Résultats Discussion Conclusion Bibliographie Annexe(s) (si nécessaire) Pour des travaux de plus grande ampleur comme les travaux de fin d’études, le schéma ci-dessus est adapté, et éventuellement divisé en chapitres, en y ajoutant généralement une partie remerciement en début de manuscrit. "],
["contenu.html", "D.2 Contenu", " D.2 Contenu Le rapport sert à restituer de façon synthétique les résultats d’une étude scientifique, et les interprétations. Le tout est remis dans le contexte de la bibliographie existante en la synthétisant dans l’introduction et en comparant les résultats avec d’autres études connexes dans la discussion. Il faut garder à l’esprit qu’un lecteur doit comprendre l’intégralité du rapport avec un minimum de connaissances a priori sur l’étude réalisée, mais avec des connaissances générales dans la spécialité. Donc, un rapport sur un sujet biologique est adressé à un lecteur biologiste pour lequel il ne faut pas rappeler les concepts de base dans sa discipline. Par contre, il faut expliquer avec suffisamment de détails comment l’étude a été réalisée dans la section “matériel et méthodes”. En général, les phrases sont simples, directes, courtes et précises (veuillez à utiliser le vocabulaire adéquat et précis). Les explications sont, autant que possible, linéaires. Evitez les renvois dans différentes autres parties du rapport, si ce n’est pour rappeler un élément évoqué plus haut, ou pour se référer à une figure ou une table. A ce sujet, les figures (dont les images, photos, schémas et graphiques) sont numérotées (Figure 1, Figure 2, …) et accompagnées d’une légende en dessous d’elles. La figure et sa légende doivent être compréhensibles telles quelles. Dans le texte, vous pourrez alors vous référer à la figure, par exemple: “Tel phénomène est observable (voir Fig. 3)”, ou “La Fig. 4 montre …”. idem pour les tableaux qui sont également numérotés (Tableau 1, Tableau 2, …) et légendés, mais au dessus du tableau. Les règles de lisibilité du tableau + légende et de renvoi vers les tableaux sont identiques que pour les figures. Les équations peuvent aussi être numérotées et des renvois de type (eq. 5) peuvent être alors utilisés. Enfin, toute affirmation doit être soit démontrée dans le rapport, soit complétée d’une citation vers un autre document scientifique qui la démontre. La partie bibliographie regroupe la liste de tous les documents qui sont ainsi cités à la fin du rapport. Veuillez à respecter les notations propres au système métrique international, les abbrévations usuelles dans la discipline, et le droit d’auteur et les licenses si vous voulez citer un passage ou reprendre une illustration provenant d’un autre auteur. Enfin, en vue de rendre le document parfaitement reproductible, vous pouvez indiquer dans les annexes où trouver la source (le document .Rmd) et les données analysées. Vous pouvez également terminer avec un chunk qui renseigne de l’état du système R utilisé, y compris l’ensemble des packages annexes employés. Ce chunk, présenté en annexe, contiendra l’instruction utils::sessionInfo(), ou mieux : xfun::session_info() (version courte) ou devtools::session_info() (version longue). Par exemple : xfun::session_info() R version 3.4.4 (2018-03-15) Platform: x86_64-apple-darwin15.6.0 (64-bit) Running under: macOS High Sierra 10.13.4 Locale: fr_BE.UTF-8 / fr_BE.UTF-8 / fr_BE.UTF-8 / C / fr_BE.UTF-8 / fr_BE.UTF-8 Package version: acepack_1.4.1 anytime_0.3.1 assertthat_0.2.0 backports_1.1.2 base64enc_0.1-3 BH_1.66.0.1 bindr_0.1.1 bindrcpp_0.2.2 bookdown_0.7 broom_0.5.0 callr_3.0.0 cellranger_1.1.0 chart_1.2.0 checkmate_1.8.5 cli_1.0.0 clipr_0.4.1 cluster_2.0.7-1 codetools_0.2-15 colorspace_1.3-2 compiler_3.4.4 cowplot_0.9.3 crayon_1.3.4 curl_3.2 data.io_1.2.0 data.table_1.11.4 datasets_3.4.4 DBI_1.0.0 dbplyr_1.2.2 digest_0.6.18 dplyr_0.7.7 ellipse_0.4.1 evaluate_0.12 fansi_0.3.0 flow_1.0.0 forcats_0.3.0 foreign_0.8-71 Formula_1.2-3 fs_1.2.6 ggplot2_2.2.1 ggplotify_0.0.3 ggpubr_0.1.8 ggrepel_0.8.0 ggsci_2.9 ggsignif_0.4.0 glue_1.3.0 graphics_3.4.4 grDevices_3.4.4 grid_3.4.4 gridExtra_2.3 gridGraphics_0.3-0 gtable_0.2.0 haven_1.1.2 highr_0.7 Hmisc_4.1-1 hms_0.4.2 htmlTable_1.12 htmltools_0.3.6 htmlwidgets_1.3 httr_1.3.1 igraph_1.2.2 jsonlite_1.5 knitr_1.20 labeling_0.3 lattice_0.20-35 latticeExtra_0.6-28 lazyeval_0.2.1 lubridate_1.7.4 magrittr_1.5 markdown_0.8 MASS_7.3-50 Matrix_1.2-14 methods_3.4.4 mime_0.6 modelr_0.1.2 munsell_0.5.0 nlme_3.1-137 nnet_7.3-12 nycflights13_1.0.0 openssl_1.0.2 pillar_1.3.0 pkgconfig_2.0.2 plogr_0.2.0 plyr_1.8.4 polynom_1.3.9 processx_3.2.0 proto_1.0.0 pryr_0.1.4 ps_1.1.0 purrr_0.2.5 R6_2.3.0 RApiDatetime_0.0.3 RColorBrewer_1.1-2 Rcpp_0.12.19 readr_1.1.1 readxl_1.1.0 rematch_1.0.1 reprex_0.2.1 reshape2_1.4.3 rlang_0.2.99.0000 rmarkdown_1.10 rpart_4.1-13 rprojroot_1.3-2 rstudioapi_0.7 rvcheck_0.1.0 rvest_0.3.2 scales_1.0.0 SciViews_1.1.0 selectr_0.4.1 splines_3.4.4 stats_3.4.4 stringi_1.2.4 stringr_1.3.1 survival_2.42-6 svMisc_1.1.0 tibble_1.4.2 tidyr_0.8.1 tidyselect_0.2.5 tidyverse_1.2.1 tinytex_0.8 tools_3.4.4 tsibble_0.5.1 utf8_1.1.4 utils_3.4.4 viridis_0.5.1 viridisLite_0.3.0 whisker_0.3.2 withr_2.1.2 xfun_0.3 xml2_1.2.0 yaml_2.2.0 D.2.1 Table des matières La table des matières est d’une importance capitale pour un long document (mais facultative pour un plus court rapport) afin de présenter la structure de votre oeuvre aux lecteurs. Heureusement, il n’est pas nécessaire de l’écrire manuellement. La table des matières est générée automatiquement dans un rapport R Markdown. L’instruction à ajouter dans le préambule du document R Notebook afin d’obtenir une table des matières est toc: yes (ne l’encodez pas directement, mais sélectionnez l’option Include table of contents dans les options de formattage du document accessibles à partir du bouton engrenage à droite de Preview ou Knit -&gt; Output Options...). Lorsque vous fermerez cette boite de dialogue de configuration, l’entrée ad hoc sera ajoutée pour vous dans le préambule. Vous pouvez aussi choisir de numéroter vos titres automatiquement. L’instruction à ajouter en plus de toc: yes dans le préambule du document R Notebook afin d’obtenir une table des matières avec des titres numéroté est number_sections: yes. Encore une fois, passez par la boite de dialogue de configuration, et cochez-y l’entrée Number section headings. Voyez l’animation ci-dessous pour accéder à la boite de dialogue de configuration du document R Markdown/R Notebook. D.2.2 Introduction L’introduction d’un rapport (ou d’un mémoire) a pour principal objectif de replacer l’étude scientifique réalisée dans son contexte. La règle la plus importante est qu’un lecteur n’ayant jamais entendu parler de cette étude doit comprendre l’intégralité du rapport. L’introduction doit donc permettre de : Remettre l’expérience dans son contexte, Décrire l’organisme étudié caractéristiques générales de l’organisme, distribution géographique, biotope,… Notez que l’ajout d’images ou d’une carte de distribution est un plus dans l’introduction. D.2.3 But Le but permet de synthétiser la question posée dans cette étude en fonction du contexte de l’expérience expliqué dans l’introduction. D.2.4 Matériel &amp; méthodes La section matériel &amp; méthodes permet de décrire les aspects techniques de l’étude comme le matériel employé et les méthodes mises en oeuvre (protocole) afin d’acquérir les données. Cette section est également le lieu de description des techniques statistiques utilisées pour analyser les données, des programmes informatiques utilisés, … D.2.5 Résultats Les résultats vont généralement contenir deux parties : La description des données, via l’exploration des données récoltées (avec graphiques et/ou estimateurs statistiques) L’application des outils statistiques pertinents pour répondre à la question posée D.2.6 Discussion Cette section comprend l’interprétation biologique des résultats et la remise dans un contexte plus général, notamment en les comparant à des observations connexes réalisées par d’autres auteurs scientifiques. Il est d’une importance capitale d’avoir un regard critique sur les résultats obtenus. Cette mise en contexte aide en ce sens. D.2.7 Conclusion(s) &amp; perspective(s) Cette section va résumer les principales implications à retenir de notre étude et, éventuellement, proposer des perspectives afin de poursuivre la recherche dans cette thématique. D.2.8 Bibliographie (ou références) La rédaction de travaux s’appuye toujours sur une recherche bibliographique au préalable. Cependant, il est capital d’insérer convenablement les sources bibliographiques au sein de cette section afin d’éviter le plagiat volontaire ou involontaire. Une multitude de programmes existent pour faciliter la gestion de votre base de données bibliographique comme Mendeley, Zotero ou encore Endnote. Pour générer correctement ses références bibliographiques dans un document R Markdown/R Notebook, consulter ceci. Il s’agit d’un manuel en anglais de RStudio qui explique comment faire dans le détail. "],
["nom-des-especes.html", "D.3 Nom des espèces", " D.3 Nom des espèces Le nom complet d’une espèce en biologie suit une convention particulière, propre à la nomenclature binomiale de Linné) que vous devez appliquer dans tous vos travaux. Partons de l’exemple de l’oursin violet. Il s’agit ici du nom vernaculaire en français. Mais ce nom n’est pas assez précis pour être utilisé seul dans un travail scientifique. En effet, le nom vernaculaire d’une espèce change d’une langue à l’autre. Il peut aussi varier d’une région géographique à l’autre, ou pire, il peut désigner des espèces différentesselon les endroits. Seul le nom latin fait référence ! Une espèce est classée de la manière suivante (Les niveaux de classification les plus importants sont mis en gras) : Règne : Animalia Embranchement : Echinodermata Sous-Embranchement : Echinozoa Classe : Echinoidea Sous-classe : Euechinoidea Super-ordre : Echinacea Ordre : Camarodonta Infra-ordre : Echinidae Famille : Parachinidae Genre : Paracentrotus Espèce : lividus Afin de former le nom binomial de l’oursin violet, on utilise le genre et l’espèce de la classification proprosée ci-dessus : Paracentrotus lividus En toute rigueur, il faut aussi associer le nom du naturaliste qui a nommé et décrit l’espèce et l’année de la publication de la description (on parle de diagnose en biologie), et ce, uniquement la première fois qu’on cite cette espèce dans notre rapport. Paracentrotus lividus Lamarck 1816 Lors de la première citation d’une espèce, et certainement dans le titre ou le résumé, il est indispensable de spécifier le nom latin complet de l’espèce (genre espèce) qui pourra être éventuellement abbrégé par la suite en indiquant la première lettre du genre. Dans l’exemple cité, on pourra écrire ensuite P. lividus (pour autant que cela ne prête pas à confusion, bien sûr). "],
["references.html", "Références", " Références "]
]
