[
["import.html", "Module 5 Importation/transformation des données", " Module 5 Importation/transformation des données Objectifs Savoir importer des données via la fonction read(), ainsi qu’appréhender ses arguments. Appréhender les types de variables et l’importance d’encoder convenablement les variables. Savoir remanier des données afin d’extraire l’information importante d’un jeu de données. Prérequis Si ce n’est déjà fait, vous devez avoir réaliser le module 1 ainsi que les modules liés à la visualisation des données. "],
["importation-des-donnees.html", "5.1 Importation des données", " 5.1 Importation des données Afin de réaliser l’analyse de vos résultats vous devez commencer par importer correctement vos données. Il existe une multitude de fonction pour réaliser l’importation de divers formats de fichiers. La fonction read() du package data.io est l’une d’entre-elles. Durant les précédents modules, vous avez employé cette fonction pour importer vos jeux de données. Reprennons un exemple pour détailler cette fonction. (biometry &lt;- read(&quot;biometry&quot;, package = &quot;BioDataScience&quot;, lang = &quot;fr&quot;)) # # A tibble: 395 x 7 # gender day_birth weight height wrist year_measure age # &lt;fct&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 M 1995-03-11 69 182 15 2013 18 # 2 M 1998-04-03 74 190 16 2013 15 # 3 M 1967-04-04 83 185 17.5 2013 46 # 4 M 1994-02-10 60 175 15 2013 19 # 5 W 1990-12-02 48 167 14 2013 23 # 6 W 1994-07-15 52 179 14 2013 19 # 7 W 1971-03-03 72 167 15.5 2013 42 # 8 W 1997-06-24 74 180 16 2013 16 # 9 M 1972-10-26 110 189 19 2013 41 # 10 M 1945-03-15 82 160 18 2013 68 # # ... with 385 more rows La fonction read() du package data.io assigne à biometry le jeu de données biometry présent dans le package BioDataScience. Il est également spécifié que la langue souhaitée est le français avec l’argument lang = “fr”. Lorsque vous vous retrouvez confrontés à devoir importer de nouvelles données dans R, vous devez vous poser les deux questions suivantes : Où ces données sont stockées ? Les données peuvent provenir de multiples endroits. Vous avez pu vous observer dans les modules précédents que les données peuvaientt être dans un package (par exemple le jeu de données biometry dans le package BioDataScience). Vous avez également pu observer que les données pouvait se retrouver sur votre disque, dans un dossier de votre ordinateur (par exemple, le jeu de données biometry_2014.xlsx lors de la comparaison des workflow entre Excell-Word et R-Rmarkdown). Les données peuvent également provenir d’un lien url (par exemple lors d’encodage de données collaboratives sur Google Sheets) ou d’une base de données. La fonction read() permet d’importer des données sur votre disque, depuis un URL ou encore depuis un package. Elle unifie donc 3 méthodes bien distinctes. Quels est le format de vos données ? Les données peuvent être sauvegardées avec différents formats comme csv, xlsx ou encore txt. Une multitude de formats existe avec des avantages et inconvénients que nous ne developperons pas dans cette section. La fonction read() supporte néanmoins 32 formats de fichier différents en utilisant en interne des fonctions provenant de différents packages dans R. Elle permet donc d’unifier ces différents outils d’importations des données : getOption(&quot;read_write&quot;) # # A tibble: 32 x 5 # type read_fun read_header write_fun comment # &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; # 1 csv readr::read_… data.io::hrea… readr::write_… comma separated valu… # 2 csv2 readr::read_… data.io::hrea… &lt;NA&gt; semicolon separated … # 3 xlcsv readr::read_… data.io::hrea… readr::write_… write a CSV file mor… # 4 tsv readr::read_… data.io::hrea… readr::write_… tab separated values # 5 fwf readr::read_… data.io::hrea… &lt;NA&gt; fixed width file # 6 log readr::read_… &lt;NA&gt; &lt;NA&gt; standard log file # 7 rds readr::read_… &lt;NA&gt; readr::write_… R data file (no comp… # 8 txt readr::read_… &lt;NA&gt; readr::write_… text file (as length… # 9 raw readr::read_… &lt;NA&gt; &lt;NA&gt; binary file (read as… # 10 ssv readr::read_… data.io::hrea… &lt;NA&gt; space separated valu… # # ... with 22 more rows 5.1.1 Données sur le disque La fonction read() vous permet d’importer de nombreux formats de fichiers comme expliqué précédement toute la difficulté va donc être dans la localisation de votre fichier sur votre ordinateur. Vous allez devoir spécifier le chemin d’accès de vos données. Le chemin d’accès à votre fichier peut s’écrire de manière absolue ou bien de manière relative. Vous devez tant que possible employer des chemins relatifs. Les projets dans RStudio définissent un environnement de travail comme vu dans le module 1. Ces projets sont amenés à être employé par différents collaborateurs. Il est donc indispensable que votre projet soit portable. Un projet RStudio pourra être qualifié de portable s’il est possible de déplacer le répertoire de base du projet et tout ce qu’il contient (ou le renommer) sans que les analyses effectuées dans R n’en soient affectées. Ceci est utile pour copier, par exemple, le projet d’un PC à un autre, ou si vous décidez de restructurer vos fichiers sur le disque dur. La démonstration va être effectuée sur base du projet sdd1_biometry qui vous avez traité lors de la comparaison des workflows. Votre projet s’organise comme ceci et se trouve dans le dossier project du dossier shared : /home /sv /shared /projects /sdd1_biometry # Le répertoire de base du projet sdd1_biometry.Rproj # Fichier de configuration du projet créé par RStudio /data # Le dossier avec les données de départ biometry_2014.xlsx # Un jeu de données au format xlsx sur la biométrie humaine /analysis # Un dossier pour les rapports d&#39;analyse biometry.nb.html # Vue HTML du rapport générée automatiquement biometry.Rmd # Un premier rapport au format R Notebook Afin de définir la position de votre fichiers biometry_2014.xlsx, vous devez simplement lister l’ensemble de dossier. Il s’agit du chemin absolu , de la position de votre fichier sur votre ordinateur. Ce format n’est pas du tout portable /home/sv/shared/projects/sdd1_biometry/data/biometry_2014.xlsx Ce chemin est plus portable que le précédent et le tild représente le dossier utilisateur. ~/shared/projects/sdd1_biometry/data/biometry_2014.xlsx Comme rapellez ci-dessus, les projets dans RStudio définissent un environnement de travail. Vous devez déterminer le chemin relatif en fonction du répertoire actif dans un projet R studio, c’est le projet lui même qui est le répertoire actif. data/biometry_2014.xlsx Afin de passer d’un chemin absolu à un chemin relatif vous devez : connaitre le répertoire actif utiliser le / pour rentrer dans un dossier utiliser le ../ pour sortir d’un dossier Pour obtenir une explication complète et détaillée sur l’utilisation des chemins relatifs dans l’organisation d’un projet Rstudio, lisez le tutoriel : “Tutoriel SDD-UMONS : La gestion des fichiers dans un projet et les chemins relatifs” 5.1.1.1 Pièges et astuces L’utilisation des chemins relatifs est indispensable comme expliqués ci-dessus. Lors de vos travaux organisé en plusieurs projets cohérents vous serez amené à travailler principalement dans des fichiers de type Rscript ou des fichiers R notebook ou encore R markdown. Notez ceci Le Rscript utilise comme référence afin de définir la position d’un jeu de données (ou tous autres fichiers) dans un projet, la position de projet R studio. data/biometry_2014.xlsx Le R notebook ou R markdown utilise comme référence afin de définir le chemin d’accès d’un jeu de données (ou tous autres fichiers) dans un projet, sa propre position. ../data/biometry_2014.xlsx L’utilisation des chemins d’accès relatifs respecte les mêmes principes pour l’insertion d’une image par exemple. 5.1.2 Données provenant d’un url Il existe différents programmes qui permettent d’éditer des tableaux de données en ligne et de les transmettre simplement. Google Sheet est l’un de ces programmes. Partez de l’url suivant : https://docs.google.com/spreadsheets/d/1iEuGrMk4IcCkq7gMNzy04DkSaPeWH35Psb0E56KEQMw/edit?usp=sharing Il s’agit d’un tableau de données portant sur la croissance de différentes espèces de coraux. Ce tableau de données peut être transmis sous la forme d’un tableau csv que la fonction read() peut importer. remarque : le lien founit ne permet pas de modifier les données fournie, ce paramètre peut très simplement être modifié. coral &lt;- read(&quot;https://docs.google.com/spreadsheets/d/e/2PACX-1vSxqegwJVjO0PxIs7mObr0syeYwNdpvd25AWUoWkwocQexYUqQUK0hC57NwsypQQUDnsJLiR-hxzSFA/pub?gid=0&amp;single=true&amp;output=csv&quot;, type = &quot;csv&quot;) # Parsed with column specification: # cols( # localisation = col_character(), # species = col_character(), # id = col_integer(), # growth_day = col_double() # ) # Visualisation des premières ligne du tableau de données head(coral) # # A tibble: 6 x 4 # localisation species id growth_day # &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; # 1 A0 s.hystrix 1 1.44 # 2 A0 s.hystrix 2 1.82 # 3 A0 s.hystrix 3 1.66 # 4 A0 s.hystrix 4 1.16 # 5 A0 s.hystrix 5 1.72 # 6 A0 s.hystrix 6 1.65 5.1.3 Données provenant d’un package Les packages que l’on peut assimiler à des boites à outils dans R que vous employer à chaque utilisation sur le programme comme data.io, chart ou encore flow, sont pour certains composés de jeux de données. La fonction read() permet également de les importer. Précédement, une seule fonction était employé pour importer ces données. Il s’agissait de la fonction data(). # Chargement de package library(data.io) # Appel du jeu de données data(urchin_bio) # Visualisation des premières ligne du jeu de données head(urchin_bio) # origin diameter1 diameter2 height buoyant_weight weight solid_parts # 1 Fishery 9.9 10.2 5.0 NA 0.5215 0.4777 # 2 Fishery 10.5 10.6 5.7 NA 0.6418 0.5891 # 3 Fishery 10.8 10.8 5.2 NA 0.7336 0.6770 # 4 Fishery 9.6 9.3 4.6 NA 0.3697 0.3438 # 5 Fishery 10.4 10.7 4.8 NA 0.6097 0.5587 # 6 Fishery 10.5 11.1 5.0 NA 0.6096 0.5509 # integuments dry_integuments digestive_tract dry_digestive_tract gonads # 1 0.3658 NA 0.0525 0.0079 0 # 2 0.4447 NA 0.0482 0.0090 0 # 3 0.5326 NA 0.0758 0.0134 0 # 4 0.2661 NA 0.0442 0.0064 0 # 5 0.4058 NA 0.0743 0.0117 0 # 6 0.4269 NA 0.0492 0.0097 0 # dry_gonads skeleton lantern test spines maturity sex # 1 0 0.1793 0.0211 0.0587 0.0995 0 &lt;NA&gt; # 2 0 0.1880 0.0205 0.0622 0.1053 0 &lt;NA&gt; # 3 0 0.2354 0.0254 0.0836 0.1263 0 &lt;NA&gt; # 4 0 0.0630 0.0167 0.0180 0.0283 0 &lt;NA&gt; # 5 0 NA NA NA NA 0 &lt;NA&gt; # 6 0 NA NA NA NA 0 &lt;NA&gt; La fonction read() est capable d’importer ces données en une seule instruction. # Importation de données provenant d&#39;un package urchin &lt;- read(&quot;urchin_bio&quot;, package = &quot;data.io&quot;) # Visualisation des premières ligne du jeu de données head(urchin) # # A tibble: 6 x 19 # origin diameter1 diameter2 height buoyant_weight weight solid_parts # &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 Fishe… 9.9 10.2 5 NA 0.522 0.478 # 2 Fishe… 10.5 10.6 5.7 NA 0.642 0.589 # 3 Fishe… 10.8 10.8 5.2 NA 0.734 0.677 # 4 Fishe… 9.6 9.3 4.6 NA 0.370 0.344 # 5 Fishe… 10.4 10.7 4.8 NA 0.610 0.559 # 6 Fishe… 10.5 11.1 5 NA 0.610 0.551 # # ... with 12 more variables: integuments &lt;dbl&gt;, dry_integuments &lt;dbl&gt;, # # digestive_tract &lt;dbl&gt;, dry_digestive_tract &lt;dbl&gt;, gonads &lt;dbl&gt;, # # dry_gonads &lt;dbl&gt;, skeleton &lt;dbl&gt;, lantern &lt;dbl&gt;, test &lt;dbl&gt;, # # spines &lt;dbl&gt;, maturity &lt;int&gt;, sex &lt;fct&gt; La fonction read() requiert comme premier argument le nom du jeu de données (e.g. &quot;iris&quot; ou &quot;urchin_bio&quot;), suivi de l’argument package= (e.g. &quot;datasets&quot;, ou &quot;data.io&quot;), suivi de l’argument lang= (e.g. &quot;fr&quot;) qui définit la langue d’intérêt. L’instruction ci-dessous permet d’obtenir une liste de l’ensemble des jeux de données présent dans un package. read(package = &quot;data.io&quot;) 5.1.4 Pièges et astuces 5.1.4.1 Langue du jeu de données La fonction read() a l’avantage de pouvoir employer un fichier annexe pour ajouter simplement les labels et les unités en différentes langues. Certains jeux de données comme le jeu de données de urchin_bio du package data.io possèdent ces fichiers annexes. Lorsque l’on importe le jeu de données avec la fonction data(), les fichiers annexes ne sont pas employé. # Chargement des données data(&quot;urchin_bio&quot;) # Visualisation des données chart(urchin_bio, height ~ weight %col=% origin) + geom_point() Ces fichiers annexes sont par contre employé par la fonction read() pour ajouter les labels et unités au tableau de données. Certaines fonctions comme chart() sont capables d’employer ces labels et unités. # Importation du tableau de données avec l&#39;argument lang qui varie. urchin &lt;- read(&quot;urchin_bio&quot;, package = &quot;data.io&quot;) urchin_en &lt;- read(&quot;urchin_bio&quot;, package = &quot;data.io&quot;, lang = &quot;en&quot;) urchin_fr &lt;- read(&quot;urchin_bio&quot;, package = &quot;data.io&quot;, lang = &quot;fr&quot;) urchin_FR &lt;- read(&quot;urchin_bio&quot;, package = &quot;data.io&quot;, lang = &quot;FR&quot;) L’arguement lang permet de spécifier la langue souhaitée. Les différences dans les labels sont observables sur le graphique ci-dessous. # Réalisation graphique a &lt;- chart(urchin, height ~ weight %col=% origin) + geom_point() b &lt;- chart(urchin_en, height ~ weight %col=% origin) + geom_point() c &lt;- chart(urchin_fr, height ~ weight %col=% origin) + geom_point() d &lt;- chart(urchin_FR, height ~ weight %col=% origin) + geom_point() # Combinaison des graphiques combine_charts(chartlist = list(a, b, c, d)) A &amp; B: l’argument lang par défaut est lang = “en”. Il ajoute les lables et unités en anglais avec les unités dans le système international. C : l’argument lang = “fr” ajoute les labels et unités en français. Il laisse cependant les niveaux des variables facteurs en anglais (Farm et Fishery). D : l’argument lang= “FR” ajoute les lables et unités en français. Dr plus, il traduit également les niveaux des variables facteurs. Il vous est conseillé d’employé l’argument lang=“fr” lors de vos différents travaux. La langues international en science est l’anglais et vous serez très certainement amené dans votre carrière scientifique de produire des documents en français et en anglais. L’utilisation de lang= “FR” rend le code uniquement utilisable dans ces conditions. Observez les exemples proposés ci-dessous. urchin_en %&gt;.% filter(., origin == &quot;Farm&quot;) %&gt;.% head(.) # # A tibble: 6 x 19 # origin diameter1 diameter2 height buoyant_weight weight solid_parts # &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 Farm 53.1 54.5 26.3 9.57 60.2 41.7 # 2 Farm 52.7 52.7 25.9 10.8 63.2 46.6 # 3 Farm 54 54.2 24.5 10.7 64.4 44.3 # 4 Farm 51.1 51.3 28.8 11.2 62.4 45.0 # 5 Farm 52.1 53.6 31.2 11.1 63.7 44.0 # 6 Farm 52.3 51.4 28.6 12.4 68.6 53.9 # # ... with 12 more variables: integuments &lt;dbl&gt;, dry_integuments &lt;dbl&gt;, # # digestive_tract &lt;dbl&gt;, dry_digestive_tract &lt;dbl&gt;, gonads &lt;dbl&gt;, # # dry_gonads &lt;dbl&gt;, skeleton &lt;dbl&gt;, lantern &lt;dbl&gt;, test &lt;dbl&gt;, # # spines &lt;dbl&gt;, maturity &lt;int&gt;, sex &lt;fct&gt; urchin_fr %&gt;.% filter(., origin == &quot;Farm&quot;) %&gt;.% head(.) # # A tibble: 6 x 19 # origin diameter1 diameter2 height buoyant_weight weight solid_parts # &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 Farm 53.1 54.5 26.3 9.57 60.2 41.7 # 2 Farm 52.7 52.7 25.9 10.8 63.2 46.6 # 3 Farm 54 54.2 24.5 10.7 64.4 44.3 # 4 Farm 51.1 51.3 28.8 11.2 62.4 45.0 # 5 Farm 52.1 53.6 31.2 11.1 63.7 44.0 # 6 Farm 52.3 51.4 28.6 12.4 68.6 53.9 # # ... with 12 more variables: integuments &lt;dbl&gt;, dry_integuments &lt;dbl&gt;, # # digestive_tract &lt;dbl&gt;, dry_digestive_tract &lt;dbl&gt;, gonads &lt;dbl&gt;, # # dry_gonads &lt;dbl&gt;, skeleton &lt;dbl&gt;, lantern &lt;dbl&gt;, test &lt;dbl&gt;, # # spines &lt;dbl&gt;, maturity &lt;int&gt;, sex &lt;fct&gt; urchin_FR %&gt;.% filter(., origin == &quot;Pêcherie&quot;) %&gt;.% head(.) # # A tibble: 6 x 19 # origin diameter1 diameter2 height buoyant_weight weight solid_parts # &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 Pêche… 9.9 10.2 5 NA 0.522 0.478 # 2 Pêche… 10.5 10.6 5.7 NA 0.642 0.589 # 3 Pêche… 10.8 10.8 5.2 NA 0.734 0.677 # 4 Pêche… 9.6 9.3 4.6 NA 0.370 0.344 # 5 Pêche… 10.4 10.7 4.8 NA 0.610 0.559 # 6 Pêche… 10.5 11.1 5 NA 0.610 0.551 # # ... with 12 more variables: integuments &lt;dbl&gt;, dry_integuments &lt;dbl&gt;, # # digestive_tract &lt;dbl&gt;, dry_digestive_tract &lt;dbl&gt;, gonads &lt;dbl&gt;, # # dry_gonads &lt;dbl&gt;, skeleton &lt;dbl&gt;, lantern &lt;dbl&gt;, test &lt;dbl&gt;, # # spines &lt;dbl&gt;, maturity &lt;int&gt;, sex &lt;fct&gt; "],
["type-de-variables.html", "5.2 Type de variables", " 5.2 Type de variables Lors de la réalisation de graphiques dans les modules précédents vous avez compris que toutes les variables ne se valait pas dans R. (biometry &lt;- read(&quot;biometry&quot;, package = &quot;BioDataScience&quot;, lang = &quot;fr&quot;)) # # A tibble: 395 x 7 # gender day_birth weight height wrist year_measure age # &lt;fct&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 M 1995-03-11 69 182 15 2013 18 # 2 M 1998-04-03 74 190 16 2013 15 # 3 M 1967-04-04 83 185 17.5 2013 46 # 4 M 1994-02-10 60 175 15 2013 19 # 5 W 1990-12-02 48 167 14 2013 23 # 6 W 1994-07-15 52 179 14 2013 19 # 7 W 1971-03-03 72 167 15.5 2013 42 # 8 W 1997-06-24 74 180 16 2013 16 # 9 M 1972-10-26 110 189 19 2013 41 # 10 M 1945-03-15 82 160 18 2013 68 # # ... with 385 more rows Ce graphique combiné ci-dessous montre de boites de dispersion. a &lt;- chart(biometry, height ~ gender %fill=% gender) + geom_boxplot() b &lt;- chart(biometry, height ~ weight %fill=% gender) + geom_boxplot() combine_charts(chartlist = list(a,b), common.legend = TRUE) # Warning: position_dodge requires non-overlapping x intervals Les jeux de données sont une suite de variables mises côte à côte. Vous avez à votre disposition plusieurs type de variables pour personnaliser le jeu de données : nombre : numérique : numeric entiers : integer valeurs arrondies : double nombre complexe : complex Il s’agit des valeurs numériques qui vont composer une variable du jeux de données. Si une variable numérique ne l’est pas vous pouvez la tranformer avec l’instruction suivante : caractères : character Il s’agit de chaine de charactères qui vont composer une variable du jeux de données. Les chaines de caractères vont avoir 2 but. Soit il s’agit d’une information ayant pour objectif d’être employé comme variable facteur ou bien il s’agit d’une information complémentaire sur les observations qui ne sera pas employer dans l’analyse des données. Cependant, vous pouvez être amené à transformer une variable en caractère avec l’instruction suivante : facteur : factor Il s’agit d’une variable permettant de discriminer des observations avec un ensemble de niveau dans un jeu de données comme la variable portant sur l’origine du tableau de donnés urchin. Date : date Le date dans un jeu de données sont proposé sous le format date. La fonction skim() du package skimr permet de visualiser le type de la variable et bien plus encore. Il fournit une visualisation différentes en fonction du type de la variable. Il propose par exemple un histogramme pour les variables numériques comme le montre le tableau ci-dessous skimr::skim(biometry) # Skim summary statistics # n obs: 395 # n variables: 7 # # ── Variable type:Date ──────────────────────────────────────────────────────────────────────────────────────────────────────────────── # variable missing complete n min max median n_unique # day_birth 0 395 395 1927-08-29 2000-08-11 1988-10-05 210 # # ── Variable type:factor ────────────────────────────────────────────────────────────────────────────────────────────────────────────── # variable missing complete n n_unique top_counts ordered # gender 0 395 395 2 M: 198, W: 197, NA: 0 FALSE # # ── Variable type:numeric ───────────────────────────────────────────────────────────────────────────────────────────────────────────── # variable missing complete n mean sd p0 p25 p50 p75 # age 0 395 395 35.34 17.32 15 19 27 50 # height 0 395 395 170.71 9.07 146 164 171 177 # weight 0 395 395 71.2 15.45 41.5 59 69.3 80 # wrist 2 393 395 16.65 1.67 10 15.5 16.5 18 # year_measure 0 395 395 2015.32 1.61 2013 2014 2016 2017 # p100 hist # 89 ▇▂▁▅▂▁▁▁ # 193 ▁▂▆▆▇▅▃▁ # 131 ▂▇▇▆▂▁▁▁ # 23 ▁▁▂▇▇▂▁▁ # 2017 ▅▅▁▁▁▅▁▇ Avec une seule instruction, on obtient une quantité d’information sur notr jeu de données comme le nombre d’observation, le nombre de variables et un traitement spécifique pour chaque type de variable. Cet instruction permet de visualiser et d’appréhender le jeu de données mais ne doit pas figurer tel quel dans un rapport d’analyse. 5.2.0.1 Pièges et astuces tooth &lt;- read(&quot;ToothGrowth&quot;, package = &quot;datasets&quot;, lang = &quot;fr&quot;) Le jeu de données comprend 60 observations sur la croissance de dents de cochons d’inde. Ces derniers reçoivent 2 types de suppléments soit du jus d’orange (OC) ou de la vitamine C (VC). Ils recoivent trois doses 0.5, 1, 2 mg/jour. VOus pouvez observer les données avec la fonction skim(). skimr::skim(tooth) # Skim summary statistics # n obs: 60 # n variables: 3 # # ── Variable type:factor ────────────────────────────────────────────────────────────────────────────────────────────────────────────── # variable missing complete n n_unique top_counts ordered # supp 0 60 60 2 OJ: 30, VC: 30, NA: 0 FALSE # # ── Variable type:numeric ───────────────────────────────────────────────────────────────────────────────────────────────────────────── # variable missing complete n mean sd p0 p25 p50 p75 p100 # dose 0 60 60 1.17 0.63 0.5 0.5 1 2 2 # len 0 60 60 18.81 7.65 4.2 13.07 19.25 25.27 33.9 # hist # ▇▁▇▁▁▁▁▇ # ▃▅▃▅▃▇▂▂ La variable dose est encodée sous la forme de variable numérique alors que cette dernière doit être sous la forme de facteur. Vous devez recoder cette variable. tooth$dose &lt;- as.factor(tooth$dose) # Visualisation des données skimr::skim(tooth) # Skim summary statistics # n obs: 60 # n variables: 3 # # ── Variable type:factor ────────────────────────────────────────────────────────────────────────────────────────────────────────────── # variable missing complete n n_unique # dose 0 60 60 3 # supp 0 60 60 2 # top_counts ordered # 0.5: 20, 1: 20, 2: 20, NA: 0 FALSE # OJ: 30, VC: 30, NA: 0 FALSE # # ── Variable type:numeric ───────────────────────────────────────────────────────────────────────────────────────────────────────────── # variable missing complete n mean sd p0 p25 p50 p75 p100 # len 0 60 60 18.81 7.65 4.2 13.07 19.25 25.27 33.9 # hist # ▃▅▃▅▃▇▂▂ Vous pouvez cependant aller encore plus loin car la variable est une variable facteur et plus précisement une variable facteur ordonée. Il y a une progression dans les doses administrées. Il est possible de ne pas simplement changer une variable en variable facteur. Il est possible de de préciser les niveaux levels, de l’ordonner avec l’argument ordered = TRUE. Prenez la variable dose du jeu de données ToothGrowth. Etant donné qu’il s’agit de doses croissantes administrées à des cochons d’Inde, cette variable doit donc être une variable ordonnée. tooth$dose &lt;- as.ordered(tooth$dose) # Visualisation des données skimr::skim(tooth) # Skim summary statistics # n obs: 60 # n variables: 3 # # ── Variable type:factor ────────────────────────────────────────────────────────────────────────────────────────────────────────────── # variable missing complete n n_unique # dose 0 60 60 3 # supp 0 60 60 2 # top_counts ordered # 0.5: 20, 1: 20, 2: 20, NA: 0 TRUE # OJ: 30, VC: 30, NA: 0 FALSE # # ── Variable type:numeric ───────────────────────────────────────────────────────────────────────────────────────────────────────────── # variable missing complete n mean sd p0 p25 p50 p75 p100 # len 0 60 60 18.81 7.65 4.2 13.07 19.25 25.27 33.9 # hist # ▃▅▃▅▃▇▂▂ La fonction as.factor() et la fonction as.ordered dérive de la fonction factor(). La variable facteur ordonnée est reconnue par une ensemble de fonction dans R. Elle ne sera de ce fait pas traitée de la même manière qu’une variable facteur simple. "],
["remaniement-des-donnees.html", "5.3 Remaniement des données", " 5.3 Remaniement des données tg &lt;- read(&quot;ToothGrowth&quot;, package = &quot;datasets&quot;, lang = &quot;fr&quot;) Lors du module IV, vous avez réalisé votre premier remaniement de données afin de réaliser un graphique en barre résumant une variable numérique en fonction d’une variable facteur. Le principale remaniement des données peut être réalisé en 4 grands piliers : sélectionner des colonnes au sein d’un jeu de données select() filtrer des lignes dans un jeu de données filter() calculer de nouvelles variables dans un jeu de donées mutate() Résumer de colonnes d’un jeu de données initiale summarise() 5.3.1 select() Lors de l’utilisation vos jeux de données, vous serez amené à réduire vos jeux de données en sous tableau. Partez du jeu de données portant sur la croissance des oursins, ce dernier contient pas moins de 19 variables étudiées sur 421 individus. ub &lt;- read(&quot;urchin_bio&quot;, package = &quot;data.io&quot;, lang = &quot;fr&quot;) Vous vous intéressez dans votre analyse uniquement à certaines variables. La fonction select() et les fonctions d’aide à la selection (?select_helpers) peut vous apporter la solution à votre demande. ub1 &lt;- select(ub, origin, solid_parts, test) ub2 &lt;- select(ub, c(1,4,14)) ub3 &lt;- select(ub, origin, contains(&quot;weight&quot;)) ub4 &lt;- select(ub, ends_with(&quot;ht&quot;)) u1 &lt;- ggtexttable(head(ub1, n = 4), theme = ttheme(&quot;lBlack&quot;)) u2 &lt;- ggtexttable(head(ub2, n = 4), theme = ttheme(&quot;classic&quot;)) u3 &lt;- ggtexttable(head(ub3, n = 4), theme = ttheme(&quot;lRed&quot;)) u4 &lt;- ggtexttable(head(ub4, n = 4), theme = ttheme(&quot;mGreen&quot;)) ggpubr::ggarrange(u1, u2, u3, u4, labels = &quot;auto&quot;) Figure 5.1: a) Résumé de la sélection effectué ub1, b) Résumé de la sélection effectué ub2, c) Résumé de la sélection effectué ub3, d) Résumé de la sélection effectué ub4 5.3.2 filter() Lors de l’analyse de vos jeux de données, vous serez amené à filtrer les lignes de vos tableaux de données. La fonction filter() est l’un des outils pouvant vous apporter la solution. Repartez du jeu de données portant sur la croissance des oursins simplifié à 3 variables (l’origine, la hauteur et la masse du squelette). a &lt;- chart(ub2, formula = height ~ skeleton %col=% origin) + geom_point(na.rm = TRUE) ggarrange(a,u2, labels = &quot;auto&quot;, widths = c(2, 1)) Figure 5.2: a) Nuage de points montrant la variation de la hauteur du test des oursins en fonction du poids du squelette. b) Tableau de données résumé de la croissance des oursins. Vous pouvez utiliser une variable facteur pour sélectionner uniquement un niveau. égal à : == tout sauf : != u &lt;- filter(ub2, origin != &quot;Fishery&quot;) # tous les origines sauf ceux provenant de Fishery u2 &lt;- ggtexttable(head(u, n = 4), theme = ttheme(&quot;classic&quot;)) a &lt;- chart(u, formula = height ~ skeleton %col=% origin ) + geom_point(na.rm = TRUE) ggarrange(a,u2,labels = &quot;auto&quot;, widths = c(2, 1)) Figure 5.3: a) Nuage de points montrant la variation de la hauteur du test des oursins en fonction du poids du squelette. b) Tableau de données résumé de la croissance des oursins suite à l’application d’un filtre sur l’orgine des oursins. Vous pouvez utiliser une variable numérique pour filtrer les données. supérieur à : &gt; inférieur à : &lt; supérieur ou égal à : &gt;= inférieur ou égal à : &lt;= u &lt;- filter(ub2, height &gt; 20) # hauteur supérieur à 20 u2 &lt;- ggtexttable(head(u, n = 4), theme = ttheme(&quot;classic&quot;)) a &lt;- chart(u, formula = height ~ skeleton %col=% origin) + geom_point(na.rm = TRUE) ggarrange(a,u2,labels = &quot;auto&quot;, widths = c(2, 1)) Figure 5.4: a) Nuage de points montrant la variation de la hauteur du test des oursins en fonction du poids du squelette. b) Tableau de données résumé de la croissance des oursins suite à l’application d’un filtre sur les tailles des individus. Vous pouvez combiner différents filtres : &amp; : et : ou u &lt;- filter(ub2, height &gt; 20 &amp; origin == &quot;Farm&quot;) # hauteur supérieur à 20 et origine contenant uniquement les oursins venant du niveau `Farm` u2 &lt;- ggtexttable(head(u, n = 4), theme = ttheme(&quot;classic&quot;)) a &lt;- chart(u, formula = height ~ skeleton %col=% origin) + geom_point(na.rm = TRUE) ggarrange(a, u2,labels = &quot;auto&quot;, widths = c(2, 1)) Figure 5.5: a) Nuage de points montrant la variation de la hauteur du test des oursins en fonction du poids du squelette. b) Tableau de données résumé de la croissance des oursins suite à l’application d’un filtre sur l’orgine des oursins et sur les tailles des individus. 5.3.2.1 Pièges et astuces Avec des variables facteurs composé des nombreux niveaux, on peut être amené à en sélectionné plusieurs is &lt;- filter(iris, Species == &quot;virginica&quot;| &quot;setosa&quot;) ## erreur is &lt;- filter(iris, Species %in% c(&quot;setosa&quot;, &quot;virginica&quot;)) 5.3.3 mutate() Lors de l’analyse de vos jeux de données, vous serez amené à calculer de nouvelles variables. La fonction mutate() est l’un des outils pouvant vous apporter la solution. Repartez du jeu de données portant sur la croisance des oursins. Vous pouvez tout d’abord employer les - les opérateurs arithmétiques + addition : + + soustraction : - + multiplication : * + division : / + exposant : ^ ou ** + modulo (reste lors d’une division) : %% + division entière : %/% ub &lt;- mutate(ub, v1 = lantern + spines + test, v2 = v1/skeleton, v3 = skeleton^2) les fonctions mathématiques log sqrt sin, cos, tan ub &lt;- mutate(ub, v1_log = log(skeleton), v2_sqrt = sqrt(skeleton), v3_sin = sin(skeleton)) 5.3.3.1 Pièges et astuces La fonction mutate() permet de calculer de nouvelles variables. Cependant, la fonction transmute() permet de retirer les anciennes variables employées dans le calcule de la nouvelle. 5.3.4 summarise() Lors de l’analyse de vos jeux de données, vous serez amené à résumer vos données. a &lt;- summarise(tg, &quot;moyenne&quot; = mean(len), &quot;minimum&quot; = min(len), &quot;médiane&quot; = median(len), &quot;maximum&quot; = max(len)) ggtexttable(a, theme = ttheme(&quot;lBlack&quot;)) Cette fonction n’a de véritable intêrét que couplée avec la fonction `group_by() qui va permettre de grouper un jeu de données en fonction d’une ou plusieurs variable de type facteur. tg &lt;- group_by(tg, supp) a &lt;- summarise(tg, &quot;moyenne&quot; = mean(len), &quot;minimum&quot; = min(len), &quot;médiane&quot; = median(len), &quot;maximum&quot; = max(len)) ggtexttable(a, theme = ttheme(&quot;lBlack&quot;)) tg &lt;- group_by(tg, supp, dose) a &lt;- summarise(tg, &quot;moyenne&quot; = mean(len), &quot;minimum&quot; = min(len), &quot;médiane&quot; = median(len), &quot;maximum&quot; = max(len)) ggtexttable(a, theme = ttheme(&quot;lBlack&quot;)) 5.3.4.1 Pièges et astuces Tout comme lors de réalisation d’une boite de dispersion, vous devez être particulièrement vigilant ou nombre d’observation par sous groupe. Ajoutez à chaque tableau résumé des données, le nombre d’observation par sous-groupe. a &lt;- summarise(tg, &quot;moyenne&quot; = mean(len), &quot;minimum&quot; = min(len), &quot;médiane&quot; = median(len), &quot;maximum&quot; = max(len), &quot;observation&quot; = n()) ggtexttable(a, theme = ttheme(&quot;lBlack&quot;)) 5.3.5 Pièges et astuces ub &lt;- read(&quot;urchin_bio&quot;, package = &quot;data.io&quot;, lang = &quot;fr&quot;) Lors de l’analyse de vos jeux de données, vous serez amené à réaliser plusieurs de ces étapes de remaniement des données. La solution est d’employer le pipe1 `%&gt;.% qui permet de réaliser une suite d’intructions. Vous pouvez calculer de nouvelles variables puis filtrer les lignes et enfin sélectionner des colonnes. Etape par étape, vous allez utiliser la fonction mutate(), puis filter() et enfin `select() ub &lt;- mutate(ub, v1 = lantern + spines + test, v2 = v1/skeleton, v3 = skeleton^2, v1_log = log(skeleton), v2_sqrt = sqrt(skeleton), v3_sin = sin(skeleton)) ub &lt;- filter(ub, height &gt; 20 &amp; origin == &quot;Farm&quot;) ub &lt;- select(ub, origin, solid_parts, test, v2_sqrt) ggtexttable(head(ub, n = 6), theme = ttheme(&quot;lBlack&quot;)) ub1 &lt;- read(&quot;urchin_bio&quot;, package = &quot;data.io&quot;, lang = &quot;fr&quot;) Le pipe permet d’éviter certaine répétion afin de réaliser en cascade la suite des opérations. Vous devez être vigilant à la structure du pipe qui comprend le pipe %&gt;.%et le point au début des fonctions .. Le pipe fait le lien entre les différentes fonctions et le point renvoit au jeu de données passant de fonction en fonction. ub1 %&gt;.% mutate(., v1 = lantern + spines + test, v2 = v1/skeleton, v3 = skeleton^2, v1_log = log(skeleton), v2_sqrt = sqrt(skeleton), v3_sin = sin(skeleton)) %&gt;.% filter(., height &gt; 20 &amp; origin == &quot;Farm&quot;) %&gt;.% select(., origin, solid_parts, test, v2_sqrt) -&gt; ub1 # fonction pour afficher ggtexttable(head(ub1, n = 6), theme = ttheme(&quot;lBlack&quot;)) Le pipe est un outil très intéressant lors du résumé de données par une ou plusieurs variables facteurs. tg &lt;- group_by(tg, supp, dose) a &lt;- summarise(tg, &quot;moyenne&quot; = mean(len), &quot;minimum&quot; = min(len), &quot;médiane&quot; = median(len), &quot;maximum&quot; = max(len)) ggtexttable(a, theme = ttheme(&quot;lBlack&quot;)) tg %&gt;.% group_by(., supp, dose) %&gt;.% summarise(., &quot;moyenne&quot; = mean(len), &quot;minimum&quot; = min(len), &quot;médiane&quot; = median(len), &quot;maximum&quot; = max(len)) %&gt;.% ggtexttable(., theme = ttheme( colnames.style = colnames_style(fill = &quot;white&quot;), tbody.style = tbody_style(fill = get_palette(&quot;RdBu&quot;, 6)) ), rows = NULL, cols = c(&quot;Supplément&quot;, &quot;Dose&quot;, &quot;Moyenne&quot;, &quot;Minimum&quot;, &quot;Médiane&quot;, &quot;Maximum&quot;)) 5.3.5.1 Pour en savoir plus Customisation de tableau TODO↩ "],
["a-vous-de-jouer-6.html", "5.4 A vous de jouer !", " 5.4 A vous de jouer ! Un squelette de projet RStudio vous a été fournit dans un dépôt Github Classroom, y compris organisation des fichiers et jeux de données types. Votre objectif est de : Importer les données provenant du ToothGrowth Comprendre les données proposées, en utilisant des visualisations graphiques appropriées Reproduire de plus le graphique ci-dessous tg &lt;- read(&quot;ToothGrowth&quot;, package = &quot;datasets&quot;) tg$dose &lt;- as.factor(tg$dose) chart(tg, formula = len ~ dose %fill=% dose) + geom_violin(alpha = 0.3, position = &quot;dodge&quot;, trim = FALSE) + geom_boxplot(position = &quot;dodge&quot;, width = 0.2) + labs( y = &quot;Longueur des dents \\n de cochone d&#39;Inde [mm/j]&quot;, x = &quot;Dose administrée&quot;) + theme( text = element_text(size = 14), axis.text = element_text(size = 14)) Documenter le fruit de votre étude dans un rapport R Notebook. "]
]
