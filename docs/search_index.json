[
["import.html", "Module 5 Traitement des données I", " Module 5 Traitement des données I Objectifs Savoir importer différents formats de données dans R via la fonction read(). Appréhender les types de variables et l’importance d’encoder convenablement les variables. Savoir remanier des données afin d’extraire l’information importante d’un jeu de données. Prérequis Le contenu du module 1 doit être parfaitement maîtrisé. Il est également souhaitable, mais pas indispensable, de comprendre comment réaliser des graphiques dans R. "],
["importation-des-donnees.html", "5.1 Importation des données", " 5.1 Importation des données Il est possible d’encoder des très petits jeux de données dans R. La fonction tribble() permet de le faire facilement. Notez que les noms des colonnes du tableau sont à rentrer sous forme de formules (~var), que chaque entrée est séparée par une virgule, et que les chaines de caractères sont entourées de guillements. Les espaces sont optionnels et peuvent ête utilisés pour aligner les données afin que le tout soit plus lisible. Des commentaires peuvent être utilisés éventuellement en fin de ligne (un dièse # suivi du commentaire). small_dataset &lt;- tribble( ~treatment, ~dose, ~response, &quot;control&quot;, 0.5, 18.35, &quot;control&quot;, 1.0, 26.43, # This value needs to be double-checked &quot;control&quot;, 2.0, 51.08, &quot;test&quot; , 0.5, 10.29, &quot;test&quot; , 1.0, 19.92, &quot;test&quot; , 2.0, 41.06) # Print the table small_dataset # # A tibble: 6 x 3 # treatment dose response # &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 control 0.5 18.4 # 2 control 1 26.4 # 3 control 2 51.1 # 4 test 0.5 10.3 # 5 test 1 19.9 # 6 test 2 41.1 Dans la plupart des cas, vous utiliserez ou collecterez des données stockées dans des formats divers : feuilles Excel, fichiers CSV (“comma-separated-values”, un format standard d’encodage d’un tableau de données sous forme textuelle), formats spécifiques à divers logiciels statistiques comme SAS, Stata ou Systat, … Ces données peuvent être sur un disque local ou disponibles depuis un lien URL sur le net1. De nombreuses fonctions existent dans R pour importer toutes ces données. La fonction read() du package data.io est l’une des plus simples et conviviales d’entre-elles. Vous l’avez déjà utilisée, mais reprenons un exemple pour en discuter les détails. (biometry &lt;- read(&quot;biometry&quot;, package = &quot;BioDataScience&quot;, lang = &quot;fr&quot;)) # # A tibble: 395 x 7 # gender day_birth weight height wrist year_measure age # &lt;fct&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 M 1995-03-11 69 182 15 2013 18 # 2 M 1998-04-03 74 190 16 2013 15 # 3 M 1967-04-04 83 185 17.5 2013 46 # 4 M 1994-02-10 60 175 15 2013 19 # 5 W 1990-12-02 48 167 14 2013 23 # 6 W 1994-07-15 52 179 14 2013 19 # 7 W 1971-03-03 72 167 15.5 2013 42 # 8 W 1997-06-24 74 180 16 2013 16 # 9 M 1972-10-26 110 189 19 2013 41 # 10 M 1945-03-15 82 160 18 2013 68 # # ... with 385 more rows Le jeu de données biometry est disponible dans le package R BioDataScience. Dans ce cas, il ne faut pas spécifier de chemin d’accès au fichier : R sait où le trouver tout seul. Il est également spécifié ici que la langue souhaitée est le français avec l’argument lang = &quot;fr&quot;. Le résultat de l’importation est assigné à la variable biometry(mais elle pourrait tout aussi bien porter un autre nom). Pour finir, le tout est entouré, de manière optionnelle, de parenthèses afin de forcer l’impression du résultat. Visualisez toujours votre tableau de données juste après l’importation. Vérifiez que les différentes colonnes ont été importées au bon format. En particulier, Les données numériques sont-elle bien comprises par R comme des nombres (&lt;dbl&gt; ou &lt;int&gt;) ? Les variables qualitatives ou semi-quantitatives sont importées comme chaines de caractères (&lt;chr&gt;) et doivent éventuellement être converties en variables de type facteur à l’aide de as.factor() ou facteur ordonné avec as.ordered(), voir plus loin. L’impression du tableau de données est une façon de voir cela, mais il y en a bien d’autres : essayez View(biometry), str(biometry), ou cliquez sur la petite icône bleue avec une flèche devant biometry dans l’onglet Environnement. Avant d’importer vos données dans R, vous devez vous poser les deux questions suivantes : Où ces données sont stockées ? Vous venez d’importer des données depuis un package R. Vous pouvez également les lire depuis un fichier sur le disque ou via une URL depuis le Web. Tous ces cas sont gérés par read() qui unifie donc de manière simple vos accès aux données. Quels est le format de vos données ? Souvent ce format est renseigné par l’extension du fichier. Par exemple .xlsx pour un Microsoft Excel ou .csv pour du “comma-separated-value”. Attention ! L’extension du fichier est cachée sous Windows, et parfois sous MacOS. Visualisez vos fichiers dans l’onglet Files dans RStudio pour voir leur nom complet, avec l’extension. Pour l’instant, read() supporte 32 formats de fichiers différents, mais cette liste est amenée à s’agrandir à l’avenir. Pour découvrir les formats supportés, et les fonctions d’importation spécifiques appelées à chaque fois, utilisez : getOption(&quot;read_write&quot;) # # A tibble: 32 x 5 # type read_fun read_header write_fun comment # &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; # 1 csv readr::read_… data.io::hrea… readr::write_… comma separated valu… # 2 csv2 readr::read_… data.io::hrea… &lt;NA&gt; semicolon separated … # 3 xlcsv readr::read_… data.io::hrea… readr::write_… write a CSV file mor… # 4 tsv readr::read_… data.io::hrea… readr::write_… tab separated values # 5 fwf readr::read_… data.io::hrea… &lt;NA&gt; fixed width file # 6 log readr::read_… &lt;NA&gt; &lt;NA&gt; standard log file # 7 rds readr::read_… &lt;NA&gt; readr::write_… R data file (no comp… # 8 txt readr::read_… &lt;NA&gt; readr::write_… text file (as length… # 9 raw readr::read_… &lt;NA&gt; &lt;NA&gt; binary file (read as… # 10 ssv readr::read_… data.io::hrea… &lt;NA&gt; space separated valu… # # ... with 22 more rows Par la suite, vous allez apprendre à importer vos données depuis différentes sources. 5.1.1 Données sur le disque Lorsque l’extension du fichier reflète le format des données, il vous suffit juste d’indiquer le chemin d’accès au fichier à read(). La plupart du temps, cela suffira pour importer correctement les données. N’oubliez pas que le chemin d’accès à votre fichier peut s’écrire de manière absolue ou bien de manière relative. Vous devez autant que possible employer des chemins relatifs pour que votre projet soit portable. Si vous avez du mal à déterminer le chemin relatif par rapport à vos données, le snippet filerelchoose vous sera très utile : Assurez-vous que le chemin actif dans la fenêtre Console est le même que le répertoire contenant le fichier édité. Pour cela, utilisez l’entrée de menu RStudio Session -&gt; Set Working Directory -&gt; To Source File Location. Utilisez le snippet filerelchoose que vous activez dans une zone de code R (dans un script R, ou à l’intérieur d’un chunk dans un document R Markdown/R Notebook). Entrez file, attendez que le menu contextuel de complétion apparaisse, sélectionnez filerelchoose dans la liste et tapez Entrée. Une boite de dialogue de sélection de fichier apparait. Sélectionnez le fichier qui vous intéresse et … file est remplacé par le chemin relatif vers votre fichier dans l’éditeur. Les explications détaillées concernant l’organisation de vos projets dans RStudio pour qu’ils soient portables, la gestion des chemins d’accès aux fichiers et les chemins relatifs sont détaillés dans l’annexe B, à la section B.1.1. C’est le moment de vérifier que vous avez bien compris et assimilé son contenu. 5.1.1.1 Pièges et astuces Si l’extension est incorrecte, vous pouvez forcer un format de fichier particulier à l’importation en l’indiquant dans l’appel à read() comme read$&lt;ext&gt;(). Par exemple, pour forcer l’importation d’un fichier de type “comma-separated-values” pour un fichier qui se nommerait my_data.txt, vous écrirez read$csv(my_data.txt). Si les données ne sont pas importées correctement, cela signifie que les arguments d’importation par défaut ne sont pas adaptés. Les arguments à spécifier sont différents d’un format à l’autre. Voyez d’abord la fonction appelée en interne par read()dans le tableau obtenu via getOption(&quot;read_write&quot;). Par exemple, pour un fichier xlsx, il s’agit de la fonction readxl::read_excel() qui est utilisée. Ensuite, voyez l’aide de cette dernière fonction pour en découvrir les différents arguments (?readxl::read_excel). Là, vous pourrez découvrir les arguments sheet =qui indiquent la feuille à importer depuis le fichier (première feuille par défaut), ou range = qui indique la plage de données dans le feuille à utiliser (par défaut, depuis la cellule A1 en haut à gauche jusqu’à la fin du tableau). Donc, si votre fichier my_data.xlsx contient les feuilles sheet1, sheet2 et sheet3, et que les données qui vous intéressent sont dans la plage C5:E34 de sheet2, vous pourrez écrire: read(&quot;my_data.xlsx&quot;, sheet = &quot;sheet2&quot;, range = &quot;C5:E34&quot;). 5.1.2 Données depuis Internet Il existe différents logiciels qui permettent d’éditer des tableaux de données en ligne et de les partager sur le Net. Google Sheet est l’un d’entre eux, tout comme Excel Online. Des stockages spécifiques pour les données scientifiques existent aussi comme figshare ou Zenodo. Ces sites permettent de partager facilement des jeux de données sur le Net. La science est de plus en plus ouverte, et les pratiques d’“Open Data” de plus en plus fréquentes et même imposée par des programmes de recherche comme les programmes européens ou le FNRS en Belgique. Vous serez donc certainement amenés à accéder à des données depuis Internet. Voici un exemple de feuille de données Google Sheet: https://docs.google.com/spreadsheets/d/1iEuGrMk4IcCkq7gMNzy04DkSaPeWH35Psb0E56KEQMw. Il est possible d’importer ce genre de données directement depuis R, mais il faut d’abord déterminer l’URL à utiliser pour obtenir les données dans un format reconnu. Dans le cas de Google Sheet, il suffit d’indiquer à la fin de cette URL que l’on souhaite exporter les données au format CSV en rajoutant /export?format=csv à la fin de l’URL. N’oubliez pas non plus de spécifier à read() que les données sont également à lire au format CSV en utilisant read$csv() : (coral &lt;- read$csv(&quot;https://docs.google.com/spreadsheets/d/1iEuGrMk4IcCkq7gMNzy04DkSaPeWH35Psb0E56KEQMw/export?format=csv&quot;)) # Parsed with column specification: # cols( # localisation = col_character(), # species = col_character(), # id = col_integer(), # salinity = col_double(), # temperature = col_double(), # date = col_datetime(format = &quot;&quot;), # time = col_integer(), # gain = col_double(), # gain_std = col_double() # ) # # A tibble: 98 x 9 # localisation species id salinity temperature date # &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dttm&gt; # 1 A0 s.hyst… 1 34.7 24.5 2018-04-24 09:10:00 # 2 A0 s.hyst… 2 34.7 24.5 2018-04-24 09:10:00 # 3 A0 s.hyst… 3 34.7 24.5 2018-04-24 09:10:00 # 4 A0 s.hyst… 4 34.7 24.5 2018-04-24 09:10:00 # 5 A0 s.hyst… 5 34.7 24.5 2018-04-24 09:10:00 # 6 A0 s.hyst… 6 34.7 24.5 2018-04-24 09:10:00 # 7 A0 s.hyst… 7 34.7 24.5 2018-04-24 09:10:00 # 8 A0 s.hyst… 8 34.7 24.5 2018-04-24 09:10:00 # 9 A0 s.hyst… 9 34.7 24.5 2018-04-24 09:10:00 # 10 A0 s.hyst… 10 34.7 24.5 2018-04-24 09:10:00 # # ... with 88 more rows, and 3 more variables: time &lt;int&gt;, gain &lt;dbl&gt;, # # gain_std &lt;dbl&gt; Lorsque vous travaillez sur des données provenant d’url et donc qui sont susceptible d’être modifié. Il est préférable d’enregistrer une copie de ces données. Ensuite vous pouvez travailler à partir de ces données suavegardées. # write(coral, file = &quot;data/coral.rds&quot;, type = &quot;rds&quot; ) # coral &lt;- read(&quot;data/coral.rds&quot;) Attention, ne supprimez jamais l’instruction permettant de retrouver vos données sur Internet. Utilisez la dièse pour ne plus exécuter l’instruction dans R. 5.1.3 Données depuis un package Les packages comme data.io, chart ou encore flow, fournissent une série de fonctions supplémentaires. Certains d’entre eux proposent également des jeux de données. Ici aussi, read() permet de les récupérer, même si c’est la fonction data() qui est souvent utilisée à cet effet. Comparons read() et data() dans le cas des données issues de packages R. Avec data(), vous n’assignez pas le jeu de données à un nom. Ce nom vous est imposé comme le nom initial du jeu de données : data(&quot;urchin_bio&quot;, package = &quot;data.io&quot;) # package = optionnel si package déjà chargé Le jeu de données urchin_bio n’est pas véritablement chargé dans l’environnement utilisateur avec data(). Seulement une “promesse” de chargement (Promise) est enregistrée. Voyez dans l’onglet Environnement ce qui apparait. Ce n’est qu’à la première utilisation du jeu de données que le tableau est véritablement chargé. Par exemple : head(urchin_bio) # origin diameter1 diameter2 height buoyant_weight weight solid_parts # 1 Fishery 9.9 10.2 5.0 NA 0.5215 0.4777 # 2 Fishery 10.5 10.6 5.7 NA 0.6418 0.5891 # 3 Fishery 10.8 10.8 5.2 NA 0.7336 0.6770 # 4 Fishery 9.6 9.3 4.6 NA 0.3697 0.3438 # 5 Fishery 10.4 10.7 4.8 NA 0.6097 0.5587 # 6 Fishery 10.5 11.1 5.0 NA 0.6096 0.5509 # integuments dry_integuments digestive_tract dry_digestive_tract gonads # 1 0.3658 NA 0.0525 0.0079 0 # 2 0.4447 NA 0.0482 0.0090 0 # 3 0.5326 NA 0.0758 0.0134 0 # 4 0.2661 NA 0.0442 0.0064 0 # 5 0.4058 NA 0.0743 0.0117 0 # 6 0.4269 NA 0.0492 0.0097 0 # dry_gonads skeleton lantern test spines maturity sex # 1 0 0.1793 0.0211 0.0587 0.0995 0 &lt;NA&gt; # 2 0 0.1880 0.0205 0.0622 0.1053 0 &lt;NA&gt; # 3 0 0.2354 0.0254 0.0836 0.1263 0 &lt;NA&gt; # 4 0 0.0630 0.0167 0.0180 0.0283 0 &lt;NA&gt; # 5 0 NA NA NA NA 0 &lt;NA&gt; # 6 0 NA NA NA NA 0 &lt;NA&gt; Regardez à nouveau dans l’onglet Environnement. Ce coup-ci urchin_bio apparait bien dans la section Data et l’icône en forme de petit tableau à la droite qui permet de le visualiser est enfin accessible. La fonction read() permet de choisir librement le nom que nous souhaitons donner à notre jeu de données. Si nous voulons l’appeler urchin au lieu de urchin_bio, pas de problèmes. De plus, il est directement chargé et accessible dans l’onglet Environnement (en effet, si on utilise une instruction qui charge un jeu de données, c’est très vraissemblablement parce que l’on souhaite ensuite le manipuler depuis R, non ?). urchin &lt;- read(&quot;urchin_bio&quot;, package = &quot;data.io&quot;) Nous avons déjà vu que read() donne accès également dans certains cas à des métadonnées (par exemple le label et les unités des jeux de données) dans différentes langues, ce que ne permet pas data(). Enfin, la syntaxe et la fonction utilisée sont pratiquement identiques pour charger des données depuis un fichier, depuis Internet ou depuis un package avec read(). C’est logique et facile à retenir. data() ne permet que de récupérer des données liées à un package R, et c’est tout ! Pour toutes ces raisons, nous préférons utiliser read() à data(). 5.1.3.1 Langue du jeu de données La fonction read() a l’avantage de pouvoir employer un fichier annexe pour rajouter des métadonnées (données complémentaires) à notre tableau, comme les labels et les unités des variables en différentes langues. Lorsque l’on importe le jeu de données avec la fonction data(), les métadonnées ne sont pas employées. data(&quot;urchin_bio&quot;, package = &quot;data.io&quot;) # Visualisation des données chart(urchin_bio, height ~ weight %col=% origin) + geom_point() Comparez ceci avec le même graphique, mais obtenu à partir de différentes versions du jeu de données urchin_bio importé à l’aide de read() avec des valeurs différentes pour l’argument lang =. urchin &lt;- read(&quot;urchin_bio&quot;, package = &quot;data.io&quot;) urchin_en &lt;- read(&quot;urchin_bio&quot;, package = &quot;data.io&quot;, lang = &quot;en&quot;) urchin_fr &lt;- read(&quot;urchin_bio&quot;, package = &quot;data.io&quot;, lang = &quot;fr&quot;) urchin_FR &lt;- read(&quot;urchin_bio&quot;, package = &quot;data.io&quot;, lang = &quot;FR&quot;) Les différences dans les labels sont observables sur le graphique ci-dessous. a &lt;- chart(urchin, height ~ weight %col=% origin) + geom_point() b &lt;- chart(urchin_en, height ~ weight %col=% origin) + geom_point() c &lt;- chart(urchin_fr, height ~ weight %col=% origin) + geom_point() d &lt;- chart(urchin_FR, height ~ weight %col=% origin) + geom_point() combine_charts(list(a, b, c, d)) A &amp; B: l’argument lang par défaut est lang = &quot;en&quot;. Il utilise les labels et unités en anglais avec les unités dans le système international. C : l’argument lang = &quot;fr&quot; utilise les labels et unités en français. Il laisse cependant les niveaux des variables facteurs en anglais (Farm et Fishery) afin d’éviter de devoir changer les instructions de manipulation des données qui feraient référence à ces niveaux. D : l’argument lang = &quot;FR&quot; ajoute les labels et unités en français. De plus, il traduit également les niveaux des variables facteurs (Culture et Pêcherie). Il vous est conseillé d’employé l’argument lang = &quot;fr&quot; lors de vos différents travaux. La langues internationale en science est l’anglais et vous serez très certainement amené dans votre carrière scientifique à produire des documents en français et en anglais. L’utilisation de lang = &quot;fr&quot;rend le même code réutilisable sur la version française ou anglaise, contrairement à lang = &quot;FR&quot;. Observez les exemples ci-dessous. urchin_en %&gt;.% filter(., origin == &quot;Farm&quot;) %&gt;.% head(.) # # A tibble: 6 x 19 # origin diameter1 diameter2 height buoyant_weight weight solid_parts # &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 Farm 53.1 54.5 26.3 9.57 60.2 41.7 # 2 Farm 52.7 52.7 25.9 10.8 63.2 46.6 # 3 Farm 54 54.2 24.5 10.7 64.4 44.3 # 4 Farm 51.1 51.3 28.8 11.2 62.4 45.0 # 5 Farm 52.1 53.6 31.2 11.1 63.7 44.0 # 6 Farm 52.3 51.4 28.6 12.4 68.6 53.9 # # ... with 12 more variables: integuments &lt;dbl&gt;, dry_integuments &lt;dbl&gt;, # # digestive_tract &lt;dbl&gt;, dry_digestive_tract &lt;dbl&gt;, gonads &lt;dbl&gt;, # # dry_gonads &lt;dbl&gt;, skeleton &lt;dbl&gt;, lantern &lt;dbl&gt;, test &lt;dbl&gt;, # # spines &lt;dbl&gt;, maturity &lt;int&gt;, sex &lt;fct&gt; urchin_fr %&gt;.% filter(., origin == &quot;Farm&quot;) %&gt;.% head(.) # # A tibble: 6 x 19 # origin diameter1 diameter2 height buoyant_weight weight solid_parts # &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 Farm 53.1 54.5 26.3 9.57 60.2 41.7 # 2 Farm 52.7 52.7 25.9 10.8 63.2 46.6 # 3 Farm 54 54.2 24.5 10.7 64.4 44.3 # 4 Farm 51.1 51.3 28.8 11.2 62.4 45.0 # 5 Farm 52.1 53.6 31.2 11.1 63.7 44.0 # 6 Farm 52.3 51.4 28.6 12.4 68.6 53.9 # # ... with 12 more variables: integuments &lt;dbl&gt;, dry_integuments &lt;dbl&gt;, # # digestive_tract &lt;dbl&gt;, dry_digestive_tract &lt;dbl&gt;, gonads &lt;dbl&gt;, # # dry_gonads &lt;dbl&gt;, skeleton &lt;dbl&gt;, lantern &lt;dbl&gt;, test &lt;dbl&gt;, # # spines &lt;dbl&gt;, maturity &lt;int&gt;, sex &lt;fct&gt; urchin_FR %&gt;.% filter(., origin == &quot;Pêcherie&quot;) %&gt;.% head(.) # # A tibble: 6 x 19 # origin diameter1 diameter2 height buoyant_weight weight solid_parts # &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 Pêche… 9.9 10.2 5 NA 0.522 0.478 # 2 Pêche… 10.5 10.6 5.7 NA 0.642 0.589 # 3 Pêche… 10.8 10.8 5.2 NA 0.734 0.677 # 4 Pêche… 9.6 9.3 4.6 NA 0.370 0.344 # 5 Pêche… 10.4 10.7 4.8 NA 0.610 0.559 # 6 Pêche… 10.5 11.1 5 NA 0.610 0.551 # # ... with 12 more variables: integuments &lt;dbl&gt;, dry_integuments &lt;dbl&gt;, # # digestive_tract &lt;dbl&gt;, dry_digestive_tract &lt;dbl&gt;, gonads &lt;dbl&gt;, # # dry_gonads &lt;dbl&gt;, skeleton &lt;dbl&gt;, lantern &lt;dbl&gt;, test &lt;dbl&gt;, # # spines &lt;dbl&gt;, maturity &lt;int&gt;, sex &lt;fct&gt; R permet également d’interroger des bases de données spécialisées, mais nous n’aborderons ce sujet spécifique qu’au cours de Science des Données Biologique 5 en Master 2.↩ "],
["types-de-variables.html", "5.2 Types de variables", " 5.2 Types de variables Lors de la réalisation de graphiques dans les modules précédents vous avez compris que toutes les variables ne sont pas équivalentes. Certains graphiques sont plutôt destinés à des variables qualitatives (par exemple, graphique en barres), alors que d’autres représentent des données quantitatives comme le nuage de points. (biometry &lt;- read(&quot;biometry&quot;, package = &quot;BioDataScience&quot;, lang = &quot;fr&quot;)) # # A tibble: 395 x 7 # gender day_birth weight height wrist year_measure age # &lt;fct&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 M 1995-03-11 69 182 15 2013 18 # 2 M 1998-04-03 74 190 16 2013 15 # 3 M 1967-04-04 83 185 17.5 2013 46 # 4 M 1994-02-10 60 175 15 2013 19 # 5 W 1990-12-02 48 167 14 2013 23 # 6 W 1994-07-15 52 179 14 2013 19 # 7 W 1971-03-03 72 167 15.5 2013 42 # 8 W 1997-06-24 74 180 16 2013 16 # 9 M 1972-10-26 110 189 19 2013 41 # 10 M 1945-03-15 82 160 18 2013 68 # # ... with 385 more rows La Figure 5.1 montre deux boites de dispersion parallèles différentes. Laquelle de ces deux représentations est incorrecte et pourquoi ? a &lt;- chart(biometry, height ~ gender %fill=% gender) + geom_boxplot() b &lt;- chart(biometry, height ~ weight %fill=% gender) + geom_boxplot() combine_charts(list(a, b), common.legend = TRUE) Figure 5.1: Boites de dispersion parallèles de la taille (height) en fonction de A. une variable qualitative (gender) et B. une variable quantitative (weight) et couleur en fonction de `gender. C’est la figure 5.1B qui tente de représenter une variable quantitative numérique heightsous forme de boites de dispersion parallèles (correct), mais en fonction d’une variable de découpage en sous-ensemble (weight) qui est elle-même une variable quantitative, … alors qu’une variable qualitative telle que gender aurait dû être utilisée (comme dans la Fig. 5.1A). Dans le cas présent, R a bien voulu réaliser le graphique (avec juste une petit warning), mais comment l’interpréter ? Dans d’autres situations, il vous renverra purement et simplement un message d’erreur. Les jeux de données, lorsqu’ils sont bien encodés (tableaux “cas par variables”, en anglais on parlera de tidy data) sont en fait un ensemble de variables en colonnes mesurées sur un ensemble d’individus en lignes. Vous avez à votre disposition plusieurs types de variables pour personnaliser le jeu de données. Deux catégories principales de variables existent, chacune avec deux sous-catégories : Les variables quantitatives sont issues de mesures quantitatives ou de dénombrements Les variables quantitatives continues sont représentées par des valeurs réelles (double dans R) Les variables quantitatives discrètes sont typiquement représentées par des entiers (integer dans R) Les variables qualitatives sont constituées d’un petit nombre de valeurs possibles (on parle des niveaux de la variables ou de leurs modalités) Les variables qualitatives ordonnées on des niveaux qui penvent être classés dans un ordre du plus petit au plus grand. elles sont typiquement représentées dans R par des objets ordered. Les variables qualitatives non ordonnées ont des niveaux qui ne peuvent être rangés et sont typiquement représentées par des objets factor en R R essaye de gommer autant que possible la distinction entre nombres integer et double tous deux rassemblés en numeric. Si besoin, la conversion se fait automatiquement. En pratique, concentrez-vous essentiellement sur les objets numeric pour tout ce qui est quantitatif. Concernant les données qualitatives, elles sont souvent représentées par du texte (nom d’une couleur par exemple) et importées en chaines de caractère (character) dans R. Vous devez les convertir de manière explicite à l’aide de as.factor() ou as.ordered() par la suite. Il existe naturellement encore d’autres types de variables. Les dates sont représentées, par exemple, par des objets Date, les nombres complexes par complex, les données binaires par raw, etc. La fonction skim() du package skimr permet de visualiser la classe de la variable et bien plus encore. Elle fournit un résumé différent en fonction du type de la variable et propose, par exemple, un histogramme stylisé pour les variables numériques comme le montre le tableau ci-dessous. #skimr::skim(biometry) Avec une seule instruction, on obtient une quantité d’information sur notre jeu de données comme le nombre d’observations, le nombre de variables et un traitement spécifique pour chaque type de variable. Cette instruction permet de visualiser et d’appréhender le jeu de données mais ne doit généralement pas figurer tel quel dans un rapport d’analyse. 5.2.0.1 Pièges et astuces Voici un jeu de données qui étudie l’alongement des dents chez le cobaye en fonction du susbstitut alimentaire. tooth &lt;- read(&quot;ToothGrowth&quot;, package = &quot;datasets&quot;, lang = &quot;fr&quot;) Le jeu de données comprend 60 observations. Ces derniers reçoivent deux types de suppléments soit du jus d’orange (OC) ou de la vitamine C (VC). Ils recoivent trois doses 0.5, 1, 2 mg/j. Vous pouvez observer les données avec la fonction skim(). #skimr::skim(tooth) La variable dose est encodée sous forme de variable numérique alors que cette dernière ne contient que trois niveaux différents et devra être le plus souvent traitée comme une variable qualitative ordonnée à 3 niveaux . Vous devrez donc recoder cette variable en variable facteur. tooth$dose &lt;- as.factor(tooth$dose) # Visualisation des données #skimr::skim(tooth) Vous pouvez cependant aller encore plus loin car la variable est une variable facteur et plus précisement une variable facteur ordonnée. Il y a une progression dans les doses administrées. Prenez la variable dose du jeu de données tooth. Etant donné qu’il s’agit de doses croissantes administrées à des cochons d’Inde, cette variable doit donc être un facteur ordonné. tooth$dose &lt;- ordered(tooth$dose, levels = c(0.5, 1, 2)) # Visualisation des données #skimr::skim(tooth) Les fonctions as.factor() ou factor() et as.ordered() ou ordered() effectuent cette conversion de character vers objects factor ou ordered. Attention que l'*ordre* des niveaux par défaut est l'ordre alphabétique. Il ne convient pas toujours, et dans ce cas, il faut fournir l'argumentlevels =` dans un ordre bien défini comme ci-dessus. La variable facteur ordonnée est reconnue par une ensemble de fonction dans R. Elle ne sera de ce fait pas traitée de la même manière qu’une variable facteur non ordonnée. "],
["remaniement-des-donnees.html", "5.3 Remaniement des données", " 5.3 Remaniement des données Lors du module IV, vous avez réalisé votre premier remaniement de données afin de réaliser un graphique en barre résumant une variable numérique en fonction d’une variable facteur. Le principale remaniement des données peut être réalisé en 4 grands piliers : sélectionner des colonnes au sein d’un jeu de données select() filtrer des lignes dans un jeu de données filter() calculer de nouvelles variables dans un jeu de donées mutate() Résumer de colonnes d’un jeu de données initiale summarise() Ces grands piliers ont été défini dans le chapitre 5 de R for Datascience 5.3.1 select() Lors de l’utilisation vos jeux de données, vous serez amené à réduire vos jeux de données en sous tableau. urchin &lt;- read(&quot;urchin_bio&quot;, package = &quot;data.io&quot;, lang = &quot;fr&quot;) rmarkdown::paged_table(urchin) Vous vous intéressez dans votre analyse uniquement à certaines variables. La fonction select() et les fonctions d’aide à la selection (?select_helpers) vous apportent la solution à vos besoins. urchin1 &lt;- select(urchin, origin, solid_parts, test) rmarkdown::paged_table(urchin1) urchin2 &lt;- select(urchin, c(1,4,14)) rmarkdown::paged_table(urchin2) urchin3 &lt;- select(urchin, origin, contains(&quot;weight&quot;)) rmarkdown::paged_table(urchin3) urchin4 &lt;- select(urchin, ends_with(&quot;ht&quot;)) rmarkdown::paged_table(urchin4) 5.3.2 filter() Lors de l’analyse de vos jeux de données, vous serez amené à filtrer les lignes de vos tableaux de données. La fonction filter() est l’un des outils pouvant vous apporter la solution. Repartez du jeu de données portant sur la croissance des oursins simplifié à 3 variables (urchin2). rmarkdown::paged_table(urchin2) Vous pouvez utiliser une variable facteur pour sélectionner uniquement un niveau d’une variable. égal à : == tout sauf : != urchin_sub1 &lt;- filter(urchin2, origin != &quot;Fishery&quot;) # tous les origines sauf ceux provenant de Fishery rmarkdown::paged_table(urchin_sub1) Vous pouvez utiliser une variable numérique pour filtrer les données. supérieur à : &gt; inférieur à : &lt; supérieur ou égal à : &gt;= inférieur ou égal à : &lt;= urchin_sub2 &lt;- filter(urchin2, height &gt; 20) # hauteur supérieur à 20 rmarkdown::paged_table(urchin_sub2) Vous pouvez combiner différents filtres : &amp; : et : ou urchin_sub3 &lt;- filter(urchin2, height &gt; 20 &amp; origin == &quot;Farm&quot;) # hauteur supérieur à 20 et origine contenant uniquement les oursins venant du niveau `Farm` rmarkdown::paged_table(urchin_sub3) Avec des variables facteurs composé des nombreux niveaux comme on peut le retrouver dans le jeu de données zooplankton du package BioDataScience, vous pouvez être amené à en sélectionner plusieurs niveaux au sein de cette variable. zooplankton &lt;- read(&quot;zooplankton&quot;, package = &quot;data.io&quot;, lang = &quot;fr&quot;) rmarkdown::paged_table(zooplankton) %in% copepoda &lt;- filter(zooplankton, class %in% c(&quot;Calanoid&quot;, &quot;Cyclopoid&quot;, &quot;Harpacticoid&quot;, &quot;Poecilostomatoid&quot;)) rmarkdown::paged_table(copepoda) 5.3.3 mutate() Lors de l’analyse de vos jeux de données, vous serez amené à calculer de nouvelles variables. La fonction mutate() est l’un des outils pouvant vous apporter la solution. Repartez du jeu de données portant sur la croisance des oursins. Vous pouvez tout d’abord employer les - les opérateurs arithmétiques + addition : + + soustraction : - + multiplication : * + division : / + exposant : ^ ou ** + modulo (reste lors d’une division) : %% + division entière : %/% urchin &lt;- mutate(urchin, weight_tot = lantern + spines + test, ratio = weight_tot/skeleton, skeleton2 = skeleton^2) les fonctions mathématiques log sqrt sin, cos, tan urchin &lt;- mutate(urchin, skeleton_log = log(skeleton), skeleton_sqrt = sqrt(skeleton), skeleton_sin = sin(skeleton)) La fonction mutate() permet de calculer de nouvelles variables. Cependant, la fonction transmute() permet de retirer les anciennes variables employées dans le calcule de la nouvelle. 5.3.4 summarise() tooth &lt;- read(&quot;ToothGrowth&quot;, package = &quot;datasets&quot;, lang = &quot;fr&quot;) rmarkdown::paged_table(tooth) Lors de l’analyse de vos jeux de données, vous serez amené à résumer vos données. tooth_tab &lt;- summarise(tooth, &quot;moyenne&quot; = mean(len), &quot;minimum&quot; = min(len), &quot;médiane&quot; = median(len), &quot;maximum&quot; = max(len)) knitr::kable(tooth_tab) moyenne minimum médiane maximum 18.81333 4.2 19.25 33.9 Cette fonction n’a de véritable intêrét que couplée avec la fonction `group_by() qui va permettre de grouper un jeu de données en fonction d’une ou plusieurs variable de type facteur. tooth &lt;- group_by(tooth, supp) tooth_tab &lt;- summarise(tooth, &quot;moyenne&quot; = mean(len), &quot;minimum&quot; = min(len), &quot;médiane&quot; = median(len), &quot;maximum&quot; = max(len)) knitr::kable(tooth_tab) supp moyenne minimum médiane maximum OJ 20.66333 8.2 22.7 30.9 VC 16.96333 4.2 16.5 33.9 5.3.4.1 Pièges et astuces Tout comme lors de réalisation d’une boite de dispersion, vous devez être particulièrement vigilant ou nombre d’observation par sous groupe. Ajoutez à chaque tableau résumé des données, le nombre d’observation par sous-groupe. tooth_tab &lt;- summarise(tooth, &quot;moyenne&quot; = mean(len), &quot;minimum&quot; = min(len), &quot;médiane&quot; = median(len), &quot;maximum&quot; = max(len), &quot;observation&quot; = n()) knitr::kable(tooth_tab) supp moyenne minimum médiane maximum observation OJ 20.66333 8.2 22.7 30.9 30 VC 16.96333 4.2 16.5 33.9 30 "],
["chainage.html", "5.4 Chainage", " 5.4 Chainage Le chainage (ou le pipe en anglais) permet de combiner une suite de fonction à appliquer sur un jeu de données par exemple comme lorsque vous souhaitez réaliser plusieurs étapes de remaniement des données. Différents pipes existent et nous avons décidé de vous présenter le pipe du package flow. Le jeu de données sur la biométrie humaine est employé pour cette démonstration qui va comparer le remaniement d’un tableau de données avec et sans l’utilisation du chainage. biometry &lt;- read(&quot;biometry&quot;, package = &quot;BioDataScience&quot;, lang = &quot;fr&quot;) biometry1 &lt;- read(&quot;biometry&quot;, package = &quot;BioDataScience&quot;, lang = &quot;fr&quot;) L’opérateur qui permet de chainer les fonctions est %&gt;.% Sur le jeu biometry, vous vous interessez aux IMC (bmi en anglais) des individus de moins de 25 ans. Vous souhaitez représenter la moyenne, la médiane et le nombre d’observations des hommes et des femmes de cette population dans un tableau. Pour obtenir ces données vous devez : calculer le imc filter le tableau pour n’obtenir que le individus de moins de 25 ans résumer les données afin d’obtenir la moyenne et la médiane par genre. afficher un tableau de données avec ces résultats # Sans chainage biometry &lt;- mutate(biometry, bmi = weight/((height/100))^2) biometry_sub &lt;- filter(biometry, age &lt;=25) biometry_sub &lt;- group_by(biometry_sub, gender) biometry_tab &lt;- summarise(biometry_sub, mean = mean(bmi), median = median(bmi), number = n()) knitr::kable(biometry_tab, rows = NULL, col = c(&quot;Genre&quot;, &quot;Moyenne&quot;, &quot;Médiane&quot;, &quot;Observations&quot;)) Genre Moyenne Médiane Observations M 22.33636 22.09681 97 W 21.80113 21.02974 94 # avec le chainage biometry1 %&gt;.% mutate(., bmi = weight/((height/100))^2) %&gt;.% filter(., age &lt;= 25) %&gt;.% group_by(., gender) %&gt;.% summarise(., mean = mean(bmi), median = median(bmi), number = n()) %&gt;.% knitr::kable(., rows = NULL, col = c(&quot;Genre&quot;, &quot;Moyenne&quot;, &quot;Médiane&quot;, &quot;Observations&quot;)) Genre Moyenne Médiane Observations M 22.33636 22.09681 97 W 21.80113 21.02974 94 Le pipe permet d’éviter certaine répétion afin de réaliser en cascade la suite des opérations. Il permet également de faciliter la lecture du code. Vous devez être vigilant à la structure du pipe qui comprend le pipe %&gt;.%et le point au début des fonctions .. Le pipe fait le lien entre les différentes fonctions et le point renvoit au jeu de données passant de fonction en fonction. "],
["a-vous-de-jouer-6.html", "5.5 A vous de jouer !", " 5.5 A vous de jouer ! Une tâche individuelle vous est assignée via l’url suivant : https://classroom.github.com/a/WfxTmH4b "]
]
