[
["import.html", "Module 5 Traitement des données I", " Module 5 Traitement des données I Objectifs Savoir importer des données dans différents formats et différentes sources via la fonction read(). Appréhender les types de variables et l’importance d’encoder convenablement les variables. Savoir remanier des données afin d’extraire l’information importante d’un jeu de données. Prérequis Le contenu du module 1 doit être parfaitement maîtrisé. Il est également souhaitable, mais pas indispensable, de comprendre comment réaliser des graphiques dans R pour pouvoir comprendre le contenu de ce module. "],
["importation-des-donnees.html", "5.1 Importation des données", " 5.1 Importation des données Il est possible d’encoder des très petits jeux de données dans R. La fonction tribble() permet de le faire facilement. Notez que les noms des colonnes du tableau sont à rentrer sous forme de formules (~var), que chaque entrée est séparée par une virgule, et que les chaines de caractères sont entourées de guillements. Les espaces sont optionnels et peuvent ête utilisés pour aligner les données afin que le tout soit plus lisible. Des commentaires peuvent être utilisés éventuellement en fin de ligne (un dièse # suivi du commentaire). small_dataset &lt;- tribble( ~treatment, ~dose, ~response, &quot;control&quot;, 0.5, 18.35, &quot;control&quot;, 1.0, 26.43, # This value needs to be double-checked &quot;control&quot;, 2.0, 51.08, &quot;test&quot; , 0.5, 10.29, &quot;test&quot; , 1.0, 19.92, &quot;test&quot; , 2.0, 41.06) # Print the table small_dataset # # A tibble: 6 x 3 # treatment dose response # &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 control 0.5 18.4 # 2 control 1 26.4 # 3 control 2 51.1 # 4 test 0.5 10.3 # 5 test 1 19.9 # 6 test 2 41.1 Dans la plupart des cas, vous utiliserez ou collecterez des données stockées dans des formats divers : feuilles Excel, fichiers CSV (“comma-separated-values”, un format standard d’encodage d’un tableau de données sous forme textuelle), formats spécifiques à divers logiciels statistiques comme SAS, Stata ou Systat, … Ces données peuvent être sur un disque local ou disponibles depuis un lien URL sur le net1. De nombreuses fonctions existent dans R pour importer toutes ces données. La fonction read() du package data.io est l’une des plus simples et conviviales d’entre-elles. Vous l’avez déjà utilisée, mais reprenons un exemple pour en discuter les détails. (biometry &lt;- read(&quot;biometry&quot;, package = &quot;BioDataScience&quot;, lang = &quot;fr&quot;)) # # A tibble: 395 x 7 # gender day_birth weight height wrist year_measure age # &lt;fct&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 M 1995-03-11 69 182 15 2013 18 # 2 M 1998-04-03 74 190 16 2013 15 # 3 M 1967-04-04 83 185 17.5 2013 46 # 4 M 1994-02-10 60 175 15 2013 19 # 5 W 1990-12-02 48 167 14 2013 23 # 6 W 1994-07-15 52 179 14 2013 19 # 7 W 1971-03-03 72 167 15.5 2013 42 # 8 W 1997-06-24 74 180 16 2013 16 # 9 M 1972-10-26 110 189 19 2013 41 # 10 M 1945-03-15 82 160 18 2013 68 # # ... with 385 more rows Le jeu de données biometry est disponible dans le package R BioDataScience. Dans ce cas, il ne faut pas spécifier de chemin d’accès au fichier : R sait où le trouver tout seul. Il est également spécifié ici que la langue souhaitée est le français avec l’argument lang = &quot;fr&quot;. Le résultat de l’importation est assigné à la variable biometry(mais elle pourrait tout aussi bien porter un autre nom). Pour finir, le tout est entouré, de manière optionnelle, de parenthèses afin de forcer l’impression du résultat. Visualisez toujours votre tableau de données juste après l’importation. Vérifiez que les différentes colonnes ont été importées au bon format. En particulier, Les données numériques sont-elle bien comprises par R comme des nombres (&lt;dbl&gt; ou &lt;int&gt;) ? Les variables qualitatives ou semi-quantitatives sont importées comme chaines de caractères (&lt;chr&gt;) et doivent éventuellement être converties en variables de type facteur à l’aide de as.factor() ou facteur ordonné avec as.ordered(), voir plus loin. L’impression du tableau de données est une façon de voir cela, mais il y en a bien d’autres : essayez View(biometry), str(biometry), ou cliquez sur la petite icône bleue avec une flèche devant biometry dans l’onglet Environnement. Avant d’importer vos données dans R, vous devez vous poser les deux questions suivantes : Où ces données sont stockées ? Vous venez d’importer des données depuis un package R. Vous pouvez également les lire depuis un fichier sur le disque ou via une URL depuis le Web. Tous ces cas sont gérés par read() qui unifie donc de manière simple vos accès aux données. Quels est le format de vos données ? Souvent ce format est renseigné par l’extension du fichier. Par exemple .xlsx pour un Microsoft Excel ou .csv pour du “comma-separated-value”. Attention ! L’extension du fichier est cachée sous Windows, et parfois sous MacOS. Visualisez vos fichiers dans l’onglet Files dans RStudio pour voir leurs noms complets, avec les extensions. Pour l’instant, read() supporte 32 formats de fichiers différents, mais cette liste est amenée à s’agrandir à l’avenir. Pour découvrir les formats supportés, et les fonctions d’importation spécifiques appelées à chaque fois, utilisez : getOption(&quot;read_write&quot;) # # A tibble: 32 x 5 # type read_fun read_header write_fun comment # &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; # 1 csv readr::read_… data.io::hrea… readr::write_… comma separated valu… # 2 csv2 readr::read_… data.io::hrea… &lt;NA&gt; semicolon separated … # 3 xlcsv readr::read_… data.io::hrea… readr::write_… write a CSV file mor… # 4 tsv readr::read_… data.io::hrea… readr::write_… tab separated values # 5 fwf readr::read_… data.io::hrea… &lt;NA&gt; fixed width file # 6 log readr::read_… &lt;NA&gt; &lt;NA&gt; standard log file # 7 rds readr::read_… &lt;NA&gt; readr::write_… R data file (no comp… # 8 txt readr::read_… &lt;NA&gt; readr::write_… text file (as length… # 9 raw readr::read_… &lt;NA&gt; &lt;NA&gt; binary file (read as… # 10 ssv readr::read_… data.io::hrea… &lt;NA&gt; space separated valu… # # ... with 22 more rows Par la suite, vous allez apprendre à importer vos données depuis différentes sources. 5.1.1 Données sur le disque Lorsque l’extension du fichier reflète le format des données, il vous suffit juste d’indiquer le chemin d’accès au fichier à read(). La plupart du temps, cela suffira pour importer correctement les données. N’oubliez pas que le chemin d’accès à votre fichier peut s’écrire de manière absolue ou bien de manière relative. Vous devez autant que possible employer des chemins relatifs pour que votre projet soit portable. Si vous avez du mal à déterminer le chemin relatif par rapport à vos données, le snippet filerelchoose vous sera très utile : Assurez-vous que le chemin actif dans la fenêtre Console est le même que le répertoire contenant le fichier édité. Pour cela, utilisez l’entrée de menu RStudio Session -&gt; Set Working Directory -&gt; To Source File Location. Utilisez le snippet filerelchoose que vous activez dans une zone de code R (dans un script R, ou à l’intérieur d’un chunk dans un document R Markdown/R Notebook). Entrez file, attendez que le menu contextuel de complétion apparaisse, sélectionnez filerelchoose dans la liste et tapez Entrée. Une boite de dialogue de sélection de fichier apparait. Sélectionnez le fichier qui vous intéresse et … file est remplacé par le chemin relatif vers votre fichier dans l’éditeur. Les explications détaillées concernant l’organisation de vos projets dans RStudio pour qu’ils soient portables, la gestion des chemins d’accès aux fichiers et les chemins relatifs sont détaillés dans l’annexe B, à la section B.1.1. C’est le moment de vérifier que vous avez bien compris et assimilé son contenu. Pièges et astuces Si l’extension est incorrecte, vous pouvez forcer un format de fichier particulier à l’importation en l’indiquant dans l’appel à read() comme read$&lt;ext&gt;(). Par exemple, pour forcer l’importation d’un fichier de type “comma-separated-values” pour un fichier qui se nommerait my_data.txt, vous écrirez read$csv(my_data.txt). Si les données ne sont pas importées correctement, cela signifie que les arguments d’importation par défaut ne sont pas adaptés. Les arguments à spécifier sont différents d’un format à l’autre. Voyez d’abord la fonction appelée en interne par read()dans le tableau obtenu via getOption(&quot;read_write&quot;). Par exemple, pour un fichier xlsx, il s’agit de la fonction readxl::read_excel() qui est utilisée. Ensuite, voyez l’aide de cette dernière fonction pour en découvrir les différents arguments (?readxl::read_excel). Là, vous pourrez découvrir les arguments sheet =qui indiquent la feuille à importer depuis le fichier (première feuille par défaut), ou range = qui indique la plage de données dans le feuille à utiliser (par défaut, depuis la cellule A1 en haut à gauche jusqu’à la fin du tableau). Donc, si votre fichier my_data.xlsx contient les feuilles sheet1, sheet2 et sheet3, et que les données qui vous intéressent sont dans la plage C5:E34 de sheet2, vous pourrez écrire: read(&quot;my_data.xlsx&quot;, sheet = &quot;sheet2&quot;, range = &quot;C5:E34&quot;). 5.1.2 Données depuis Internet Il existe différents logiciels qui permettent d’éditer des tableaux de données en ligne et de les partager sur le Net. Google Sheets est l’un d’entre eux, tout comme Excel Online. Des stockages spécifiques pour les données scientifiques existent aussi comme Figshare ou Zenodo. Ces sites permettent de partager facilement des jeux de données sur le Net. La science est de plus en plus ouverte, et les pratiques d’Open Data de plus en plus fréquentes et même imposées par des programmes de recherche comme les programmes européens ou le FNRS en Belgique. Vous serez donc certainement amenés à accéder à des données depuis des dépôts spécialisés sur Internet. Concentrez-vous sur les outils spécifiques à la gestion de ce type de données. il s’agit, en effet, d’une compétence clé qu’un bon scientifique des données se doit de maîtriser parfaitement. En recherchant à chaque fois la meilleure façon d’accéder à des données sur le Net, vous développerez cette compétence progressivement par la pratique… et vous pourrez faire valoir un atout encore rare mais apprécié lors d’un entretien d’embaûche plus tard. Voici un exemple de feuille de données Google Sheets : https://docs.google.com/spreadsheets/d/1iEuGrMk4IcCkq7gMNzy04DkSaPeWH35Psb0E56KEQMw. Il est possible d’importer ce genre de données directement depuis R, mais il faut d’abord déterminer l’URL à utiliser pour obtenir les données dans un format reconnu. Dans le cas de Google Sheets, il suffit d’indiquer à la fin de cette URL que l’on souhaite exporter les données au format CSV en rajoutant /export?format=csv à la fin de l’URL. Cette URL est très longue. Elle est peu pratique et par ailleurs, elle a toujours la même structure : &quot;https://docs.google.com/spreadsheets/d/{id}/export?format=csv&quot; avec {id} qui est l’identifiant unique de la feuille Google Sheets (ici 1iEuGrMk4IcCkq7gMNzy04DkSaPeWH35Psb0E56KEQMw). Vous pouvez indiquer explicitement ceci dans votre code et profiter des capacités de remplacement de texte dans des chaînes de caractères de la fonction glue::glue() pour effectuer un travail impeccable. googlesheets_as_csv &lt;- &quot;https://docs.google.com/spreadsheets/d/{id}/export?format=csv&quot; coral_id &lt;- &quot;1iEuGrMk4IcCkq7gMNzy04DkSaPeWH35Psb0E56KEQMw&quot; (coral_url &lt;- glue::glue(googlesheets_as_csv, id = coral_id)) # https://docs.google.com/spreadsheets/d/1iEuGrMk4IcCkq7gMNzy04DkSaPeWH35Psb0E56KEQMw/export?format=csv Vous n’aurez alors plus qu’à lire les données depuis cette URL. N’oubliez pas non plus de spécifier à read() que les données sont à lire au format CSV en utilisant read$csv() : (coral &lt;- read$csv(coral_url)) # Parsed with column specification: # cols( # localisation = col_character(), # species = col_character(), # id = col_integer(), # salinity = col_double(), # temperature = col_double(), # date = col_datetime(format = &quot;&quot;), # time = col_integer(), # gain = col_double(), # gain_std = col_double() # ) # # A tibble: 98 x 9 # localisation species id salinity temperature date # &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dttm&gt; # 1 A0 s.hyst… 1 34.7 24.5 2018-04-24 09:10:00 # 2 A0 s.hyst… 2 34.7 24.5 2018-04-24 09:10:00 # 3 A0 s.hyst… 3 34.7 24.5 2018-04-24 09:10:00 # 4 A0 s.hyst… 4 34.7 24.5 2018-04-24 09:10:00 # 5 A0 s.hyst… 5 34.7 24.5 2018-04-24 09:10:00 # 6 A0 s.hyst… 6 34.7 24.5 2018-04-24 09:10:00 # 7 A0 s.hyst… 7 34.7 24.5 2018-04-24 09:10:00 # 8 A0 s.hyst… 8 34.7 24.5 2018-04-24 09:10:00 # 9 A0 s.hyst… 9 34.7 24.5 2018-04-24 09:10:00 # 10 A0 s.hyst… 10 34.7 24.5 2018-04-24 09:10:00 # # ... with 88 more rows, and 3 more variables: time &lt;int&gt;, gain &lt;dbl&gt;, # # gain_std &lt;dbl&gt; Lorsque vous travaillez sur des données issues d’une source externe, et donc susceptibles d’être modifiées ou même pire, de disparaître. Il est préférable d’enregistrer une copie locale de ces données dans votre projet (dans le sous-dossier data de préférence). Si vous travaillez exclusivement avec R, l’un des meilleurs formats est RDS, un format natif qui conservera toutes les caractéristiques de votre objet, y compris sa classe, et d’éventuels attributs2. Par défault, les données seront stockées non compressées, mais vous pourrez aussi décider de compresser avec les algorithmes &quot;gz&quot; (plus rapide et répandu), &quot;bz2&quot; (intermédaire), ou &quot;xz&quot; (le plus efficace en taux de compression mais aussi le plus lent et gourmand en ressources CPU). Par exemple, pour enregistrer les données avec compression &quot;gz&quot;, vous écrirez : write$rds(coral, file = &quot;../data/coral.rds&quot;, compress = &quot;gz&quot;) Ensuite, vous pourrez simplement charger ces données plus loin depuis la version locale dans votre R Markdown comme ceci : coral &lt;- read(&quot;../data/coral.rds&quot;) Attention, ne supprimez jamais l’instruction permettant de retrouver vos données sur Internet sous prétexte que vous avez maintenant une copie locale à disposition. C’est le lien, le fil conducteur vers les données originales. Vous pouvez soit mettre l’instruction en commentaire en ajoutant un dièse devant, soit soustraire le chunk de l’évaluation en indiquant eval=FALSE dans son entête. Faites-en de même avec l’instruction write(). Ainsi, le traitement de vos données commencera à l’instruction read() et vous partirez de la copie locale. Si jamais vous voulez effectuer une mise à jour depuis la source initiale, il sera toujours possible de décommenter les instructions, ou de passer le chunk à eval=TRUE temporairement (ou encore plus simplement, forcez l’exécution du chunk dans l’éditeur en cliquant sur la petite flèche verte en haut à gauche du chunk). Pièges et astuces Comme il s’agit seulement d’une copie des données originelles, vous pouvez choisir de ne pas inclure le fichier .rds dans le système de gestion de version de Git. C’est très simple : il suffit d’ajouter une entrée .rds dans le fichier .gitignore à la racine de votre dépôt, et tous les fichiers avec cette extension seront ignorés. Notez toutefois que, si vous partagez votre projet sur GitHub, les données locales n’y apparaitront pas non plus. D’une part, cela décharge le système de gestion de version, et d’autre part, les gros fichiers de données n’ont pas vraiment leur place sur GitHub. Cependant, soyez conscient de ce que quelqu’un qui réalise un clone ou un fork de votre dépôt devra d’abord réimporter lui aussi localement les données avant de pouvoir travailler, ce qui implique de bien comprendre le mécanisme que vous avez mis en place. Documentez-le correctement, avec une note explicite dans le fichier README.md, par exemple. Les données originales ne sont peut-être pas présentées de la façon qui vous convient. Cela peut nécessiter un travail important de préparation du tableau de données. Au fur et à mesure que le ou les chunks d’importation/préparation des données augmentent en taille, ils deviennent de plus en plus gênants dans un document consacré à l’analyse de ces données. Si c’est le cas, vous avez deux options possibles : Séparer votre R Markdown en deux. Un premier document dédié à l’importation/préparation des données et un second qui se concentre sur l’analyse. Une bonne pratique consiste à numéroter les fichiers en tête pour qu’ils apparaissent par ordre logique lorsqu’ils sont listés par ordre alphabétique (01_import.Rmd, 02_analysis.Rmd). Effectuer le travail d’importation/préparation du tableau de données dans un script R. Dans le R Markdown, vous pouvez ajouter l’instruction (commentée ou placée dans un chunk eval=FALSE) pour sourcer ce script R afin de réimporter/retraiter vos données : #source(&quot;../R/data-import.R&quot;) Si le travail de préparation des données est lourd (et donc, prend beaucoup de temps) il peut être avantageux d’enregistrer localement la version nettoyée de vos données plutôt que la version originale. Mais alors indiquez-le explicitement. Faites toujours la distinction entre données brutes et données nettoyées. Ne les mélangez jamais et documentez toujours de manière reproductible le processus qui mène des unes aux autres ! C’est tout aussi important que de garder un lien vers la source originale des données dans votre code et d’utiliser toujours des chemins relatifs vers vos fichiers pour une analyse portable et reproductible. 5.1.3 Données depuis un package Les packages R comme data.io, chart ou encore flow, fournissent une série de fonctions supplémentaires. Certains d’entre eux proposent également des jeux de données. Ici aussi, read() permet de les récupérer, même si c’est la fonction data() qui est souvent utilisée à cet effet dans R. Comparons read() et data() dans le cas des données issues de packages R. Avec data(), vous n’assignez pas le jeu de données à un nom. Ce nom vous est imposé comme le nom initial du jeu de données : data(&quot;urchin_bio&quot;, package = &quot;data.io&quot;) # package = optionnel si déjà chargé Le jeu de données urchin_bio n’est pas véritablement chargé dans l’environnement utilisateur avec data(). Seulement une “promesse” de chargement (Promise) est enregistrée. Voyez dans l’onglet Environnement ce qui apparait. Ce n’est qu’à la première utilisation du jeu de données que le tableau est véritablement chargé. Par exemple : head(urchin_bio) # origin diameter1 diameter2 height buoyant_weight weight solid_parts # 1 Fishery 9.9 10.2 5.0 NA 0.5215 0.4777 # 2 Fishery 10.5 10.6 5.7 NA 0.6418 0.5891 # 3 Fishery 10.8 10.8 5.2 NA 0.7336 0.6770 # 4 Fishery 9.6 9.3 4.6 NA 0.3697 0.3438 # 5 Fishery 10.4 10.7 4.8 NA 0.6097 0.5587 # 6 Fishery 10.5 11.1 5.0 NA 0.6096 0.5509 # integuments dry_integuments digestive_tract dry_digestive_tract gonads # 1 0.3658 NA 0.0525 0.0079 0 # 2 0.4447 NA 0.0482 0.0090 0 # 3 0.5326 NA 0.0758 0.0134 0 # 4 0.2661 NA 0.0442 0.0064 0 # 5 0.4058 NA 0.0743 0.0117 0 # 6 0.4269 NA 0.0492 0.0097 0 # dry_gonads skeleton lantern test spines maturity sex # 1 0 0.1793 0.0211 0.0587 0.0995 0 &lt;NA&gt; # 2 0 0.1880 0.0205 0.0622 0.1053 0 &lt;NA&gt; # 3 0 0.2354 0.0254 0.0836 0.1263 0 &lt;NA&gt; # 4 0 0.0630 0.0167 0.0180 0.0283 0 &lt;NA&gt; # 5 0 NA NA NA NA 0 &lt;NA&gt; # 6 0 NA NA NA NA 0 &lt;NA&gt; Regardez à nouveau dans l’onglet Environnement. Ce coup-ci urchin_bio apparait bien dans la section Data et l’icône en forme de petit tableau à la droite qui permet de le visualiser est enfin accessible. La fonction read() permet de choisir librement le nom que nous souhaitons donner à notre jeu de données. Si nous voulons l’appeler urchin au lieu de urchin_bio, pas de problèmes. De plus, il est directement chargé et accessible dans l’onglet Environnement (en effet, si on utilise une instruction qui charge un jeu de données, c’est très vraissemblablement parce que l’on souhaite ensuite le manipuler depuis R, non ?). urchin &lt;- read(&quot;urchin_bio&quot;, package = &quot;data.io&quot;) Nous avons déjà vu que read() donne accès également dans certains cas à des métadonnées (par exemple le label et les unités des jeux de données) dans différentes langues, ce que ne permet pas data(). Enfin, la syntaxe et la fonction utilisée sont pratiquement identiques pour charger des données depuis un fichier, depuis Internet ou depuis un package avec read(). C’est logique et facile à retenir. data() ne permet que de récupérer des données liées à un package R, et c’est tout ! Pour toutes ces raisons, nous préférons utiliser ici read() à data(). 5.1.3.1 Langue du jeu de données La fonction read() est également capable de lire un fichier annexe permettant de rajouter des métadonnées (données complémentaires) à notre tableau, comme les labels et les unités des variables en différentes langues. Lorsque l’on importe le jeu de données avec la fonction data(), ces métadonnées ne sont pas employées. data(&quot;urchin_bio&quot;, package = &quot;data.io&quot;) # Visualisation des données chart(urchin_bio, height ~ weight %col=% origin) + geom_point() Comparez ceci avec le même graphique, mais obtenu à partir de différentes versions du jeu de données urchin_bio importé à l’aide de read() avec des valeurs différentes pour l’argument lang =. urchin &lt;- read(&quot;urchin_bio&quot;, package = &quot;data.io&quot;) urchin_en &lt;- read(&quot;urchin_bio&quot;, package = &quot;data.io&quot;, lang = &quot;en&quot;) urchin_fr &lt;- read(&quot;urchin_bio&quot;, package = &quot;data.io&quot;, lang = &quot;fr&quot;) urchin_FR &lt;- read(&quot;urchin_bio&quot;, package = &quot;data.io&quot;, lang = &quot;FR&quot;) Les différences dans les labels sont observables sur le graphique ci-dessous. a &lt;- chart(urchin, height ~ weight %col=% origin) + geom_point() b &lt;- chart(urchin_en, height ~ weight %col=% origin) + geom_point() c &lt;- chart(urchin_fr, height ~ weight %col=% origin) + geom_point() d &lt;- chart(urchin_FR, height ~ weight %col=% origin) + geom_point() combine_charts(list(a, b, c, d)) A &amp; B: l’argument lang par défaut est lang = &quot;en&quot;. Il utilise les labels et unités en anglais avec les unités dans le système international. C : l’argument lang = &quot;fr&quot; utilise les labels et unités en français. Il laisse cependant les niveaux des variables facteurs en anglais (Farm et Fishery) afin d’éviter de devoir changer les instructions de manipulation des données qui feraient référence à ces niveaux. D : l’argument lang = &quot;FR&quot; ajoute les labels et unités en français. De plus, il traduit également les niveaux des variables facteurs (Culture et Pêcherie). Il vous est conseillé d’employé l’argument lang = &quot;fr&quot; lors de vos différents travaux. La langue internationale en science est l’anglais et vous serez très certainement amené dans votre carrière scientifique à produire des documents en français et en anglais. L’utilisation de lang = &quot;fr&quot;rend le même code réutilisable sur la version française ou anglaise, contrairement à lang = &quot;FR&quot;. Observez les exemples ci-dessous. urchin_en %&gt;.% filter(., origin == &quot;Farm&quot;) %&gt;.% head(.) # # A tibble: 6 x 19 # origin diameter1 diameter2 height buoyant_weight weight solid_parts # &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 Farm 53.1 54.5 26.3 9.57 60.2 41.7 # 2 Farm 52.7 52.7 25.9 10.8 63.2 46.6 # 3 Farm 54 54.2 24.5 10.7 64.4 44.3 # 4 Farm 51.1 51.3 28.8 11.2 62.4 45.0 # 5 Farm 52.1 53.6 31.2 11.1 63.7 44.0 # 6 Farm 52.3 51.4 28.6 12.4 68.6 53.9 # # ... with 12 more variables: integuments &lt;dbl&gt;, dry_integuments &lt;dbl&gt;, # # digestive_tract &lt;dbl&gt;, dry_digestive_tract &lt;dbl&gt;, gonads &lt;dbl&gt;, # # dry_gonads &lt;dbl&gt;, skeleton &lt;dbl&gt;, lantern &lt;dbl&gt;, test &lt;dbl&gt;, # # spines &lt;dbl&gt;, maturity &lt;int&gt;, sex &lt;fct&gt; urchin_fr %&gt;.% filter(., origin == &quot;Farm&quot;) %&gt;.% head(.) # # A tibble: 6 x 19 # origin diameter1 diameter2 height buoyant_weight weight solid_parts # &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 Farm 53.1 54.5 26.3 9.57 60.2 41.7 # 2 Farm 52.7 52.7 25.9 10.8 63.2 46.6 # 3 Farm 54 54.2 24.5 10.7 64.4 44.3 # 4 Farm 51.1 51.3 28.8 11.2 62.4 45.0 # 5 Farm 52.1 53.6 31.2 11.1 63.7 44.0 # 6 Farm 52.3 51.4 28.6 12.4 68.6 53.9 # # ... with 12 more variables: integuments &lt;dbl&gt;, dry_integuments &lt;dbl&gt;, # # digestive_tract &lt;dbl&gt;, dry_digestive_tract &lt;dbl&gt;, gonads &lt;dbl&gt;, # # dry_gonads &lt;dbl&gt;, skeleton &lt;dbl&gt;, lantern &lt;dbl&gt;, test &lt;dbl&gt;, # # spines &lt;dbl&gt;, maturity &lt;int&gt;, sex &lt;fct&gt; Pas d’adaptation nécessaire du code pour passer de urchin_en à urchin_fr. urchin_FR %&gt;.% filter(., origin == &quot;Pêcherie&quot;) %&gt;.% head(.) # # A tibble: 6 x 19 # origin diameter1 diameter2 height buoyant_weight weight solid_parts # &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 Pêche… 9.9 10.2 5 NA 0.522 0.478 # 2 Pêche… 10.5 10.6 5.7 NA 0.642 0.589 # 3 Pêche… 10.8 10.8 5.2 NA 0.734 0.677 # 4 Pêche… 9.6 9.3 4.6 NA 0.370 0.344 # 5 Pêche… 10.4 10.7 4.8 NA 0.610 0.559 # 6 Pêche… 10.5 11.1 5 NA 0.610 0.551 # # ... with 12 more variables: integuments &lt;dbl&gt;, dry_integuments &lt;dbl&gt;, # # digestive_tract &lt;dbl&gt;, dry_digestive_tract &lt;dbl&gt;, gonads &lt;dbl&gt;, # # dry_gonads &lt;dbl&gt;, skeleton &lt;dbl&gt;, lantern &lt;dbl&gt;, test &lt;dbl&gt;, # # spines &lt;dbl&gt;, maturity &lt;int&gt;, sex &lt;fct&gt; Le code a dû être modifier dans l’instruction filter() lors du passage à urchin_FR (Farm -&gt; Pêcherie). Bien évidemment, pour un rapport plus formel en français, tout doit être traduit en français et l’option lang = &quot;FR&quot; accompagnée d’une vérification et une adaptation éventuelle du code est à préférer dans ce cas précis. R permet également d’interroger des bases de données spécialisées, mais nous n’aborderons ce sujet spécifique qu’au cours de Science des Données Biologique 5 en Master 2.↩ Si vous devez aussi accéder à vos données à partir d’autres languages comme Python, Java ou C++, utilisez un format commun reconnu par les différents logiciels. Le CSV fonctionne généralement bien, mais des formats binaires plus performants sont également disponibles. Parmi ces formats “inter-languages”, gardez un oeil sur Apache Arrow très prometteur et avec une version pour R qui sera disponible prochainement.↩ "],
["types-de-variables.html", "5.2 Types de variables", " 5.2 Types de variables Lors de la réalisation de graphiques dans les modules précédents vous avez compris que toutes les variables ne sont pas équivalentes. Certains graphiques sont plutôt destinés à des variables qualitatives (par exemple, graphique en barres), alors que d’autres représentent des données quantitatives comme le nuage de points. (biometry &lt;- read(&quot;biometry&quot;, package = &quot;BioDataScience&quot;, lang = &quot;fr&quot;)) # # A tibble: 395 x 7 # gender day_birth weight height wrist year_measure age # &lt;fct&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 M 1995-03-11 69 182 15 2013 18 # 2 M 1998-04-03 74 190 16 2013 15 # 3 M 1967-04-04 83 185 17.5 2013 46 # 4 M 1994-02-10 60 175 15 2013 19 # 5 W 1990-12-02 48 167 14 2013 23 # 6 W 1994-07-15 52 179 14 2013 19 # 7 W 1971-03-03 72 167 15.5 2013 42 # 8 W 1997-06-24 74 180 16 2013 16 # 9 M 1972-10-26 110 189 19 2013 41 # 10 M 1945-03-15 82 160 18 2013 68 # # ... with 385 more rows La Figure 5.1 montre deux boites de dispersion parallèles différentes. Laquelle de ces deux représentations est incorrecte et pourquoi ? a &lt;- chart(biometry, height ~ gender %fill=% gender) + geom_boxplot() b &lt;- chart(biometry, height ~ weight %fill=% gender) + geom_boxplot() combine_charts(list(a, b), common.legend = TRUE) # Warning: position_dodge requires non-overlapping x intervals Figure 5.1: Boites de dispersion parallèles de la taille (height) en fonction de A. une variable qualitative (gender) et B. une variable quantitative (weight) et couleur en fonction de gender` C’est la figure 5.1B qui tente de représenter une variable quantitative numérique heightsous forme de boites de dispersion parallèles (correct), mais en fonction d’une variable de découpage en sous-ensemble (weight) qui est elle-même une variable quantitative, … alors qu’une variable qualitative telle que gender aurait dû être utilisée (comme dans la Fig. 5.1A). Dans le cas présent, R a bien voulu réaliser le graphique (avec juste une petit warning), mais comment l’interpréter ? Dans d’autres situations, il vous renverra purement et simplement un message d’erreur. Les jeux de données, lorsqu’ils sont bien encodés (tableaux “cas par variables”, en anglais on parlera de tidy data) sont en fait un ensemble de variables en colonnes mesurées sur un ensemble d’individus en lignes. Vous avez à votre disposition plusieurs types de variables pour personnaliser le jeu de données. Deux catégories principales de variables existent, chacune avec deux sous-catégories : Les variables quantitatives sont issues de mesures quantitatives ou de dénombrements Les variables quantitatives continues sont représentées par des valeurs réelles (double dans R) Les variables quantitatives discrètes sont typiquement représentées par des entiers (integer dans R) Les variables qualitatives sont constituées d’un petit nombre de valeurs possibles (on parle des niveaux de la variables ou de leurs modalités) Les variables qualitatives ordonnées ont des niveaux qui penvent être classés dans un ordre du plus petit au plus grand. elles sont typiquement représentées dans R par des objets ordered. Les variables qualitatives non ordonnées ont des niveaux qui ne peuvent être rangés et sont typiquement représentées par des objets factor en R R essaye de gommer autant que possible la distinction entre nombres integer et double tous deux rassemblés en numeric. Si besoin, la conversion se fait automatiquement. En pratique, concentrez-vous essentiellement sur les objets numeric pour tout ce qui est quantitatif. Un nombre tel que 1 est considéré par R comme un double par défaut. Si vous vouliez expressément spécifier que c’est un entier, vous pouvez le faire en ajoutant un L majuscule derrière le nombre. Ainsi, 1L est compris par R comme l’entier 1. Encore une fois, cette distinction explicite est rarement nécessaire dans R. Concernant les données qualitatives, elles sont souvent représentées par du texte (nom d’une couleur par exemple) et importées en chaines de caractère (character) par défaut dans R à partir de la fonction read(). Vous devez les convertir de manière explicite à l’aide de as.factor(), factor(), as.ordered() ou `ordered() par la suite. Il existe naturellement encore d’autres types de variables. Les dates sont représentées, par exemple, par des objets Date, les nombres complexes par complex, les données binaires par raw, etc. La fonction skim() du package skimr permet de visualiser la classe de la variable et bien plus encore. Elle fournit un résumé différent en fonction du type de la variable et propose, par exemple, un histogramme stylisé pour les variables numériques comme le montre le tableau ci-dessous. skimr::skim(biometry) # Skim summary statistics # n obs: 395 # n variables: 7 # # ── Variable type:Date ──────────────────────────────────────────────────────────────────────────────────────────────────────────── # variable missing complete n min max median n_unique # day_birth 0 395 395 1927-08-29 2000-08-11 1988-10-05 210 # # ── Variable type:factor ────────────────────────────────────────────────────────────────────────────────────────────────────────── # variable missing complete n n_unique top_counts ordered # gender 0 395 395 2 M: 198, W: 197, NA: 0 FALSE # # ── Variable type:numeric ───────────────────────────────────────────────────────────────────────────────────────────────────────── # variable missing complete n mean sd p0 p25 p50 p75 # age 0 395 395 35.34 17.32 15 19 27 50 # height 0 395 395 170.71 9.07 146 164 171 177 # weight 0 395 395 71.2 15.45 41.5 59 69.3 80 # wrist 2 393 395 16.65 1.67 10 15.5 16.5 18 # year_measure 0 395 395 2015.32 1.61 2013 2014 2016 2017 # p100 hist # 89 ▇▂▁▅▂▁▁▁ # 193 ▁▂▆▆▇▅▃▁ # 131 ▂▇▇▆▂▁▁▁ # 23 ▁▁▂▇▇▂▁▁ # 2017 ▅▅▁▁▁▅▁▇ Avec une seule instruction, on obtient une quantité d’information sur notre jeu de données comme le nombre d’observations, le nombre de variables et un traitement spécifique pour chaque type de variable. Cette instruction permet de visualiser et d’appréhender le jeu de données mais ne doit généralement pas figurer tel quel dans un rapport d’analyse. Pièges et astuces Voici un jeu de données qui étudie l’allongement des dents chez le cobaye en fonction du susbstitut alimentaire. tooth &lt;- read(&quot;ToothGrowth&quot;, package = &quot;datasets&quot;, lang = &quot;fr&quot;) Le jeu de données comprend 60 observations effectuées sur des cochons d’Inde. Ces derniers reçoivent deux types de suppléments alimentaires : soit du jus d’orange (OJ), soit de la vitamine C (VC). Des lots différents recoivent des doses différentes d’acide ascorbique via ces suppléments, soit 0.5, 1, ou 2 mg/j. Vous pouvez inspecter ces données rapidement avec la fonction skim(). skimr::skim(tooth) # Skim summary statistics # n obs: 60 # n variables: 3 # # ── Variable type:factor ────────────────────────────────────────────────────────────────────────────────────────────────────────── # variable missing complete n n_unique top_counts ordered # supp 0 60 60 2 OJ: 30, VC: 30, NA: 0 FALSE # # ── Variable type:numeric ───────────────────────────────────────────────────────────────────────────────────────────────────────── # variable missing complete n mean sd p0 p25 p50 p75 p100 # dose 0 60 60 1.17 0.63 0.5 0.5 1 2 2 # len 0 60 60 18.81 7.65 4.2 13.07 19.25 25.27 33.9 # hist # ▇▁▇▁▁▁▁▇ # ▃▅▃▅▃▇▂▂ La variable dose est encodée sous forme numérique alors que cette dernière ne contient que trois niveaux différents et devra être le plus souvent traitée comme une variable qualitative ordonnée à trois niveaux . Vous devrez donc probablement recoder cette variable en variable facteur. Ce n’est pas le caractère quantitatif ou qualitatif du mécanisme sous-jacent qui est mesuré qui détermine si la variable est quantitative ou qualitative, mais d’autres critères comme la précision avec laquelle la mesure a été effectuée. Par exemple, un anémomètre mesure la vitesse du vent sous forme de variable quantitative alors qu’une échelle approximative de type vent nul, vent faible, vent moyen, vent fort ou tempête basée sur l’observation des rides ou des vagues à la surface de la mer pourrait éventuellement convenir pour mesurer le même phénomène si une grande précision n’est pas nécessaire. Mais dans ce cas, la variable devra être traitée comme une variable qualitative. De même, un plan expérimental qui réduit volontairement les valeurs fixées dans une expérience, comme ici les doses journalières d’acide ascorbique, fera aussi basculer la variable en qualitative, et ce, quelle que soit la précision avec laquelle les valeurs sont mesurées par ailleurs. Un découpage en classes aura aussi le même effet de transformer une variable quantitative en variable qualitative ordonnée. Indiquons à présent explicitement à R que la variable dose doit être considérée comme qualitative : tooth$dose &lt;- as.factor(tooth$dose) # Visualisation des données skimr::skim(tooth) # Skim summary statistics # n obs: 60 # n variables: 3 # # ── Variable type:factor ────────────────────────────────────────────────────────────────────────────────────────────────────────── # variable missing complete n n_unique # dose 0 60 60 3 # supp 0 60 60 2 # top_counts ordered # 0.5: 20, 1: 20, 2: 20, NA: 0 FALSE # OJ: 30, VC: 30, NA: 0 FALSE # # ── Variable type:numeric ───────────────────────────────────────────────────────────────────────────────────────────────────────── # variable missing complete n mean sd p0 p25 p50 p75 p100 # len 0 60 60 18.81 7.65 4.2 13.07 19.25 25.27 33.9 # hist # ▃▅▃▅▃▇▂▂ Vous pouvez (et devez !) cependant aller encore plus loin car la variable est en réalité qualitative ordonnée, et doit être représentée par un objet “facteur ordonné” (ordered) plutôt que factor. Il y a en effet, une progression dans les doses administrées. Lors de la conversion, R considère les différents niveaux par ordre alphabéthique par défaut. Ici cela convient, mais ce n’est pas toujours le cas. Il vaut donc mieux spécifier explicitement l’ordre des niveaux dans l’argument optionnel levels =. Cela donne : tooth$dose &lt;- ordered(tooth$dose, levels = c(0.5, 1, 2)) # Visualisation des données skimr::skim(tooth) # Skim summary statistics # n obs: 60 # n variables: 3 # # ── Variable type:factor ────────────────────────────────────────────────────────────────────────────────────────────────────────── # variable missing complete n n_unique # dose 0 60 60 3 # supp 0 60 60 2 # top_counts ordered # 0.5: 20, 1: 20, 2: 20, NA: 0 TRUE # OJ: 30, VC: 30, NA: 0 FALSE # # ── Variable type:numeric ───────────────────────────────────────────────────────────────────────────────────────────────────────── # variable missing complete n mean sd p0 p25 p50 p75 p100 # len 0 60 60 18.81 7.65 4.2 13.07 19.25 25.27 33.9 # hist # ▃▅▃▅▃▇▂▂ Les fonctions as.factor() ou factor() et as.ordered() ou ordered() effectuent cette conversion de character ou numeric vers objets factor ou ordered. Une variable facteur ordonnée sera alors reconnue comme telle par un ensemble de fonction dans R. Elle ne sera, de ce fait, pas traitée de la même manière qu’une variable facteur non ordonnée, ni même qu’une variable numérique. Soyez bien attentif à l’encodage correct des données dans R avant d’effectuer vos graphiques et vos analyses. "],
["remaniement-des-donnees.html", "5.3 Remaniement des données", " 5.3 Remaniement des données Lors du module IV, vous avez réalisé votre premier remaniement de données afin de réaliser un graphique en barre résumant une variable numérique en fonction d’une variable facteur. Le principale remaniement des données peut être réalisé en 4 grands piliers : sélectionner des colonnes au sein d’un jeu de données select() filtrer des lignes dans un jeu de données filter() calculer de nouvelles variables dans un jeu de donées mutate() Résumer de colonnes d’un jeu de données initiale summarise() Ces grands piliers ont été défini dans le chapitre 5 de R for Datascience 5.3.1 select() Lors de l’utilisation vos jeux de données, vous serez amené à réduire vos jeux de données en sous tableau. urchin &lt;- read(&quot;urchin_bio&quot;, package = &quot;data.io&quot;, lang = &quot;fr&quot;) rmarkdown::paged_table(urchin) Vous vous intéressez dans votre analyse uniquement à certaines variables. La fonction select() et les fonctions d’aide à la selection (?select_helpers) vous apportent la solution à vos besoins. urchin1 &lt;- select(urchin, origin, solid_parts, test) rmarkdown::paged_table(urchin1) urchin2 &lt;- select(urchin, c(1,4,14)) rmarkdown::paged_table(urchin2) urchin3 &lt;- select(urchin, origin, contains(&quot;weight&quot;)) rmarkdown::paged_table(urchin3) urchin4 &lt;- select(urchin, ends_with(&quot;ht&quot;)) rmarkdown::paged_table(urchin4) 5.3.2 filter() Lors de l’analyse de vos jeux de données, vous serez amené à filtrer les lignes de vos tableaux de données. La fonction filter() est l’un des outils pouvant vous apporter la solution. Repartez du jeu de données portant sur la croissance des oursins simplifié à 3 variables (urchin2). rmarkdown::paged_table(urchin2) Vous pouvez utiliser une variable facteur pour sélectionner uniquement un niveau d’une variable. égal à : == tout sauf : != urchin_sub1 &lt;- filter(urchin2, origin != &quot;Fishery&quot;) # tous les origines sauf ceux provenant de Fishery rmarkdown::paged_table(urchin_sub1) Vous pouvez utiliser une variable numérique pour filtrer les données. supérieur à : &gt; inférieur à : &lt; supérieur ou égal à : &gt;= inférieur ou égal à : &lt;= urchin_sub2 &lt;- filter(urchin2, height &gt; 20) # hauteur supérieur à 20 rmarkdown::paged_table(urchin_sub2) Vous pouvez combiner différents filtres : &amp; : et : ou urchin_sub3 &lt;- filter(urchin2, height &gt; 20 &amp; origin == &quot;Farm&quot;) # hauteur supérieur à 20 et origine contenant uniquement les oursins venant du niveau `Farm` rmarkdown::paged_table(urchin_sub3) Avec des variables facteurs composé des nombreux niveaux comme on peut le retrouver dans le jeu de données zooplankton du package BioDataScience, vous pouvez être amené à en sélectionner plusieurs niveaux au sein de cette variable. zooplankton &lt;- read(&quot;zooplankton&quot;, package = &quot;data.io&quot;, lang = &quot;fr&quot;) rmarkdown::paged_table(zooplankton) %in% copepoda &lt;- filter(zooplankton, class %in% c(&quot;Calanoid&quot;, &quot;Cyclopoid&quot;, &quot;Harpacticoid&quot;, &quot;Poecilostomatoid&quot;)) rmarkdown::paged_table(copepoda) 5.3.3 mutate() Lors de l’analyse de vos jeux de données, vous serez amené à calculer de nouvelles variables. La fonction mutate() est l’un des outils pouvant vous apporter la solution. Repartez du jeu de données portant sur la croisance des oursins. Vous pouvez tout d’abord employer les - les opérateurs arithmétiques + addition : + + soustraction : - + multiplication : * + division : / + exposant : ^ ou ** + modulo (reste lors d’une division) : %% + division entière : %/% urchin &lt;- mutate(urchin, weight_tot = lantern + spines + test, ratio = weight_tot/skeleton, skeleton2 = skeleton^2) les fonctions mathématiques log sqrt sin, cos, tan urchin &lt;- mutate(urchin, skeleton_log = log(skeleton), skeleton_sqrt = sqrt(skeleton), skeleton_sin = sin(skeleton)) La fonction mutate() permet de calculer de nouvelles variables. Cependant, la fonction transmute() permet de retirer les anciennes variables employées dans le calcule de la nouvelle. 5.3.4 summarise() tooth &lt;- read(&quot;ToothGrowth&quot;, package = &quot;datasets&quot;, lang = &quot;fr&quot;) rmarkdown::paged_table(tooth) Lors de l’analyse de vos jeux de données, vous serez amené à résumer vos données. tooth_tab &lt;- summarise(tooth, &quot;moyenne&quot; = mean(len), &quot;minimum&quot; = min(len), &quot;médiane&quot; = median(len), &quot;maximum&quot; = max(len)) knitr::kable(tooth_tab) moyenne minimum médiane maximum 18.81333 4.2 19.25 33.9 Cette fonction n’a de véritable intêrét que couplée avec la fonction `group_by() qui va permettre de grouper un jeu de données en fonction d’une ou plusieurs variable de type facteur. tooth &lt;- group_by(tooth, supp) tooth_tab &lt;- summarise(tooth, &quot;moyenne&quot; = mean(len), &quot;minimum&quot; = min(len), &quot;médiane&quot; = median(len), &quot;maximum&quot; = max(len)) knitr::kable(tooth_tab) supp moyenne minimum médiane maximum OJ 20.66333 8.2 22.7 30.9 VC 16.96333 4.2 16.5 33.9 Pièges et astuces Tout comme lors de réalisation d’une boite de dispersion, vous devez être particulièrement vigilant ou nombre d’observation par sous groupe. Ajoutez à chaque tableau résumé des données, le nombre d’observation par sous-groupe. tooth_tab &lt;- summarise(tooth, &quot;moyenne&quot; = mean(len), &quot;minimum&quot; = min(len), &quot;médiane&quot; = median(len), &quot;maximum&quot; = max(len), &quot;observation&quot; = n()) knitr::kable(tooth_tab) supp moyenne minimum médiane maximum observation OJ 20.66333 8.2 22.7 30.9 30 VC 16.96333 4.2 16.5 33.9 30 "],
["chainage-des-instructions.html", "5.4 Chainage des instructions", " 5.4 Chainage des instructions Le chainage (ou “pipe” en anglais) permet de combiner une suite d’instructions R. Il permet une représentation facilement lisible et compréhensible d’un traitement décomposé en plusieurs étapes simples de remaniement des données. Différents opérateurs de chainage existent dans R. Le Tidyverse et RStudio sont en faveur de l’adoption d’un opérateur de chainage %&gt;% issu du package magrittr. Si nous sommes sensibles au clin d’oeil fait ici à un artiste belge bien connu (“ceci n’est pas un pipe”), nous n’adhérons pas à ce choix pour des raisons multiples et plutôt techniques qui n’ont pas leur place dans ce document3. Nous vous présentons ici l’un des opérateurs de chainage du package flow : %&gt;.%. Le jeu de données sur la biométrie humaine est employé pour cette démonstration qui va comparer le remaniement d’un tableau de données avec et sans l’utilisation du chainage. biometry &lt;- read(&quot;biometry&quot;, package = &quot;BioDataScience&quot;, lang = &quot;fr&quot;) Vous vous intéressez à l’indice de masse corporelle ou IMC (BMI en anglais) des individus de moins de 25 ans. Vous souhaitez représenter la moyenne, la médiane et le nombre d’observations de manière séparée pour les hommes et les femmes. Pour obtenir ces résultats vous devez : calculer le bmi, filter le tableau pour ne retenir que les individus de moins de 25 ans, résumer les données afin d’obtenir la moyenne et la médiane par genre, afficher un tableau de données avec ces résultats. Il est très clair ici que le traitement peut être décomposé en étapes plus simples. Cela apparait naturellement rien que dans la description de ce qui doit être fait. Sans l’utilisation de l’opérateur de chainage, deux approches sont possibles : Imbriquer les instructions les unes dans les autres (très difficile à lire et à débogger) : knitr::kable( summarise( group_by( filter( mutate(biometry, bmi = weight / (height/100)^2), age &lt;= 25), gender), mean = mean(bmi), median = median(bmi), number = n()), rows = NULL, digits = 1, col = c(&quot;Genre&quot;, &quot;Moyenne&quot;, &quot;Médiane&quot;, &quot;Observations&quot;) ) Genre Moyenne Médiane Observations M 22.3 22.1 97 W 21.8 21.0 94 Passer par des variables intermédiaires (biometry_25 et biometry_tab). Les instructions sont plus lisibles, mais les variables intermédiaires “polluent” inutilement l’environnement de travail (en tout cas, si elles ne servent plus par après) : biometry &lt;- mutate(biometry, bmi = weight / (height/100)^2) biometry_25 &lt;- filter(biometry, age &lt;= 25) biometry_25 &lt;- group_by(biometry_25, gender) biometry_tab &lt;- summarise(biometry_25, mean = mean(bmi), median = median(bmi), number = n()) knitr::kable(biometry_tab, rows = NULL, digits = 1, col = c(&quot;Genre&quot;, &quot;Moyenne&quot;, &quot;Médiane&quot;, &quot;Observations&quot;)) Genre Moyenne Médiane Observations M 22.3 22.1 97 W 21.8 21.0 94 Des trois approches, la version ci-dessous ave chainage des opérations est la plus lisible et la plus pratique4. biometry %&gt;.% mutate(., bmi = weight / (height/100)^2) %&gt;.% filter(., age &lt;= 25) %&gt;.% group_by(., gender) %&gt;.% summarise(., mean = mean(bmi), median = median(bmi), number = n()) %&gt;.% knitr::kable(., rows = NULL, digits = 1, col = c(&quot;Genre&quot;, &quot;Moyenne&quot;, &quot;Médiane&quot;, &quot;Observations&quot;)) Genre Moyenne Médiane Observations M 22.3 22.1 97 W 21.8 21.0 94 Le pipe %&gt;.% injecte le résultat précédent dans l’instruction suivante à travers l’objet . Ainsi, en seconde ligne mutate(.), . se réfère à biometry. A la ligne suivante, filter(.), le . se réfère au résultat issu de l’opération mutate(), et ainsi de suite. La logique d’enchainement des opérations sur le résultat, à chaque fois, du calcul précédent est donc le fondement de cet opérateur “pipe”. Le pipe permet d’éviter de répéter le nom des objets (version avec variables intermédiaires), ce qui alourdit inutilement le code et le rend moins agréable à la lecture. L’imbrication des fonctions dans la première version est catastrophique pour la compréhension du code car les arguments des fonctions de plus haut niveau sont repoussés loin. Par exemple, l’argument de l’appel à group_by() (gender) se retrouve quatre lignes plus loin. Et encore, nous avons pris soin d’indenter le code pour repérer sur un plan vertical qui appartient à qui, mais imaginez ce que cela donne si l’instruction est mise à plat sur une seule ligne ! Le code le plus clair à la lecture est définitivement celui avec chainage des opérations. Or, un code plus lisible est plus compréhensible… et donc, moins boggé. A vous de jouer Maintenant que vous venez d’apprendre à importer correctement vos données, à les remanier avec quelques-uns des opérateurs les plus fréquents, et que vous savez chainer vos instructions, il est temps de vous exercer sur un cas concret. Une tâche individuelle vous est assignée via l’URL suivante : https://classroom.github.com/a/WfxTmH4b Créez un rapport et effectuez les différents exercices en suivant les instructions qui sont dans le fichier README.md de ce dépôt GitHub Classroom. Pour en savoir plus Présentation en détail du “dot-pipe” assez proche fonctionnellement de %&gt;.% du package flow. Section sur le pipe dans “R for Data Science” expliquant l’utilisation du pipe de magrittr (et aussi quand ne pas l’utiliser !) Le lecteur intéressé pourra lire les différents articles suivants : more pipes in R, y compris les liens qui s’y trouvent, permet de se faire une idée de la diversité des opérateurs de chainage dans R et de leur historique. Dot pipe présente l’opérateur %.&gt;% du package wrapr très proche du nôtre et in praise of syntactic sugar explique ses avantages. Nous partageons l’idée que le “pipe de base” ne devrait pas modifier l’instruction de droite contrairement à ce que fait %&gt;% de magrittr, et notre opérateur %&gt;.% va en outre plus loin encore que %.&gt;% dans la facilité de déboggage du code chainé.↩ Le chainage n’est cependant pas forcément plus facile à débogger que la version avec variables intermédiaires. Le package flow propose la fonction debug_flow() à appeler directement après un plantage pour inspecter la dernière instruction qui a causé l’erreur, voir ?debug_flow.↩ "]
]
