# Importation/transformation des données {#import}

Importation, tranformation, "cook", `dplyr`, `tidyr`. Type de variables et façon de les représenter dans R. Expression de condition. Chemins relatifs. Challenges: faire tel type de graphe étant donné tel jeu de données (avec étape de transformation nécessaire).

```{r setup}
knitr::opts_chunk$set(echo=FALSE, results= 'hide', message=FALSE)
library(knitr)
library(chart)
library(ggpubr)
SciViews::R
nf <- data::read("flights", package = "nycflights13")
iris <- data::read("iris", package = "datasets")
ub <-data::read("urchin_bio", package = "data")
```

Un exemple de jeu de données est présenté à la Table \@ref(tab:exemple-tab).

```{r exemple-tab, tidy = FALSE, echo = FALSE}
knitr::kable(
  head(iris, 20), caption = 'Un exemple de tableau.',
  booktabs = TRUE
)
```



Vos objectifs pour ce module sont :

- Savoir importer des données via la fonction read(), ainsi qu'appréhender ses arguments.

- Appréhender les type de variables et l'importance d'encoder convenablement les variables.

- Savoir remanier des données afin d'extraire l'information importante d'un jeu de données.

## Prérequis

Si ce n'est déjà fait, vous devez avoir réaliser le module 1 ainsi que les modules liés à la visualisation des données.


## Importation des données

>TODO chapitre du module portant sur l'utilisation de la fonction read

## Type de variables



## Transformation des données

Lors du module IV, vous avez réalisé votre premier remaniement de données afin de réaliser un graphique en barre résumant une variable numérique en fonction d'une variable facteur. 

Le principale remaniement des données peut être réalisé en 5 grands piliers :

- sélectionner des colonnes au sein d'un jeu de données `select()`

- filtrer des lignes dans un jeu de données `filter()`

- réordonner les lignes dans un jeu de données `arrange()`

- calculer de nouvelles variables dans un jeu de donées `mutate()`

- Résumer de colonnes d'un jeu de données initiale `summarise()`

### `select()`

Lors de l'uilisation vos jeux de données, vous serez amené à réduire vos jeu de données en sous tableau.

Partez du jeu de données portant sur la croissance des oursins, ce dernier contient pas moins de 19 variables étudiées sur 421 individus. 

```{r}
ub
```

Vous vous intéressez dans votre analyse uniquement à certaines variables. La fonction `select()` et les fonctions d'aide à la selection (`?select_helpers`) peut vous apporter la solution à votre demande.

```{r, echo = TRUE}
ub1 <- select(ub, origin, solid_parts, test)
  
ub2 <- select(ub, c(1,4,14))

ub3 <-  select(ub, origin, contains("weight"))

ub4 <- select(ub, ends_with("ht"))
```



```{r, fig.cap= "a) Résumé de la sélection effectué ub1, b) Résumé de la sélection effectué ub2, c) Résumé de la sélection effectué ub3, d) Résumé de la sélection effectué ub4"}
u1 <- ggtexttable(head(ub1, n = 4), theme = ttheme("lBlack"))
u2 <- ggtexttable(head(ub2, n = 4), theme = ttheme("classic"))
u3 <- ggtexttable(head(ub3, n = 4), theme = ttheme("lRed"))
u4 <- ggtexttable(head(ub4, n = 4), theme = ttheme("mGreen"))


ggpubr::ggarrange(u1, u2, u3, u4, labels = "auto")
```




### `filter()`

Lors de l'analyse de vos jeux de données, vous serez amené à filtrer les lignes de vos tableaux de données. La fonction `filter()` est l'un des outils pouvant vous apporter la solution. 

Repartez du jeu de données portant sur la croissance des oursins simplifié à 3 variables (l'origine, la hauteur et la masse du squelette).

```{r, fig.cap= "a) Nuage de points montrant la variation de la hauteur du test des oursins en fonction du poids du squelette. b) Tableau de données résumé de la croissance des oursins."}
a <- chart(ub2, formula = height ~ skeleton %col=% origin) +
  geom_point(na.rm = TRUE)
ggarrange(a,u2, labels = "auto", widths = c(2, 1))
```

Vous pouvez utiliser une variable facteur pour sélectionner uniquement un niveau. 

- égal à : ==

- tout sauf : !=

```{r, echo = TRUE}
u <- filter(ub2, origin != "Fishery") # tous les origines sauf ceux provenant de Fishery 
```


```{r, fig.cap= "a) Nuage de points montrant la variation de la hauteur du test des oursins en fonction du poids du squelette. b) Tableau de données résumé de la croissance des oursins suite à l'application d'un filtre sur l'orgine des oursins."}
u2 <- ggtexttable(head(u, n = 4), theme = ttheme("classic"))
a <- chart(u, formula = height ~ skeleton %col=% origin ) +
  geom_point(na.rm = TRUE)
ggarrange(a,u2,labels = "auto", widths = c(2, 1))
```

Vous pouvez utiliser une variable numérique pour filtrer les données. 

- supérieur à : >

- inférieur à : <

- supérieur ou égal à : >=

- inférieur ou égal à : <=

```{r}
u <- filter(ub2, height > 20) # hauteur supérieur à 20 
```


```{r, fig.cap= "a) Nuage de points montrant la variation de la hauteur du test des oursins en fonction du poids du squelette. b) Tableau de données résumé de la croissance des oursins suite à l'application d'un filtre sur les tailles des individus."}
u2 <- ggtexttable(head(u, n = 4), theme = ttheme("classic"))
a <- chart(u, formula = height ~ skeleton %col=% origin) +
  geom_point(na.rm = TRUE)
ggarrange(a,u2,labels = "auto", widths = c(2, 1))
```

Vous pouvez combiner différents filtres :  

- & : et 

- | : ou


```{r}
u <- filter(ub2, height > 20 & origin == "Farm") # hauteur supérieur à 20  et origine contenant uniquement les oursins venant du niveau `Farm`
```


```{r, fig.cap= "a) Nuage de points montrant la variation de la hauteur du test des oursins en fonction du poids du squelette. b) Tableau de données résumé de la croissance des oursins suite à l'application d'un filtre sur l'orgine des oursins et sur les tailles des individus."}
u2 <- ggtexttable(head(u, n = 4), theme = ttheme("classic"))
a <- chart(u, formula = height ~ skeleton %col=% origin) +
  geom_point(na.rm = TRUE)
ggarrange(a, u2,labels = "auto", widths = c(2, 1))
```


#### Pièges et astuces

Avec des variables facteurs composé des nombreux niveaux, on peut être amené à en sélectionné plusieurs

```
is <- filter(iris, Species == "virginica"| "setosa") ## erreur

is <- filter(iris, Species %in% c("setosa", "virginica"))
```


### `mutate()`

Lors de l'analyse de vos jeux de données, vous serez amené à calculer de nouvelles variables. La fonction `mutate()` est l'un des outils pouvant vous apporter la solution. 

Repartez du jeu de données portant sur la croisance des oursins.

Vous pouvez tout d'abord employer les 
- les opérateurs arithmétiques
      + addition : `+`
      + soustraction : `-`
      + multiplication :  `*`
      + division : `/`
      + exposant : `^` ou `**`
      + modulo (reste lors d'une division) : `%%`
      + division entière :  `%/%` 


```{r, echo= TRUE}
ub <- mutate(ub, v1 =  lantern + spines + test, 
             v2 = v1/skeleton,
             v3 = skeleton^2)
```

- les fonctions mathématiques
    + log
    + sqrt
    + sin, cos, tan
    

```{r, echo = TRUE}
ub <- mutate(ub, v1 =  lantern + spines + test, 
             v2 = v1/skeleton,
             v3 = skeleton^2)
```

```
e.g. : x / sum(x)
```


-log 

```
e.g. : log(x)
```

- 
```{r}
x <- 1:20
lag(x, 2)
lead(x, 4)

#cumsum(iris$Sepal.Length) # cumulative sum
#cummean(iris$Sepal.Length) # cumulative mean  ?
#cumprod(iris$Sepal.Length) # cumulative products
# this function can be use in this case x - lag(x)
```


#### Pièges et astuces

La fonction `mutate()` permet de calculer de nouvelles variables. Cependant, la fonction `transmute()` permet de retirer les anciennes variables employées dans le calcule de la nouvelle. 

