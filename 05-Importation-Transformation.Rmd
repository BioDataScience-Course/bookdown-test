# Importation/transformation des données {#import}

```{r setup, include=FALSE, echo=FALSE, message=FALSE, results='hide'}
knitr::opts_chunk$set(comment = '#', fig.align = "center")
SciViews::R
library(ggpubr)
nf <- read("flights", package = "nycflights13", lang = "fr")
iris <- read("iris", package = "datasets", lang = "fr")
#ub <- read("urchin_bio", package = "data.io", lang = "fr")
urchin <- read("urchin_bio", package = "data.io")
```

#### Objectifs {-}

- Savoir importer des données via la fonction `read()`, ainsi qu'appréhender ses arguments.

- Appréhender les types de variables et l'importance d'encoder convenablement les variables.

- Savoir remanier des données afin d'extraire l'information importante d'un jeu de données.

#### Prérequis {-}

Si ce n'est déjà fait, vous devez avoir réaliser le module 1 ainsi que les modules liés à la visualisation des données.

## Importation des données

Afin de réaliser l'analyse de vos résultats vous devez commencer par importer correctement vos données. Il existe une multitude de fonction pour réaliser l'importation de divers formats de fichiers. La fonction `read()` du package `data.io` est l'une d'entre-elles. 

Durant les précédents modules, vous avez employé cette fonction pour importer vos jeux de données. Reprennons un exemple pour détailler cette fonction.

```{r}
(biometry <- read("biometry", package = "BioDataScience", lang = "fr"))
```

La fonction `read()` du package `data.io` assigne à **biometry** le jeu de données **biometry** présent dans le package **BioDataScience**. Il est également spécifié que la langue souhaitée est le français avec l'argument **lang = "fr"**. 

Lorsque vous vous retrouvez confrontés à devoir importer de nouvelles données dans R, vous devez vous poser les deux questions suivantes :

- Où ces données sont stockées ? 

Les données peuvent provenir de multiples endroits. Vous avez pu vous observer dans les modules précédents que les données peuvaientt être dans un package (par exemple le jeu de données **biometry** dans le package **BioDataScience**). Vous avez également pu observer que les données pouvait se retrouver sur votre disque, dans un dossier de votre ordinateur (par exemple, le jeu de données biometry_2014.xlsx lors de la comparaison des workflow entre Excell-Word et R-Rmarkdown). Les données peuvent également provenir d'un lien url (par exemple lors d'encodage de données collaboratives sur Google Sheets) ou d'une base de données.

La fonction read() permet d'importer des données sur votre disque, depuis un URL ou encore depuis un package. Elle unifie donc 3 méthodes bien distinctes.

- Quels est le format de vos données ? 

Les données peuvent être sauvegardées avec différents formats comme csv, xlsx ou encore txt. Une multitude de formats existe avec des avantages et inconvénients que nous ne developperons pas dans cette section.

La fonction **read()** supporte néanmoins 32 formats de fichier différents en utilisant en interne des fonctions provenant de différents packages dans R. Elle permet donc d'unifier ces différents outils d'importations des données :

```{r}
getOption("read_write")
```


### Données sur le disque 

La fonction read() vous permet d'importer de nombreux formats de fichiers comme expliqué précédement toute la difficulté va donc être dans la localisation de votre fichier sur votre ordinateur. Vous allez devoir spécifier le chemin d'accès de vos données.

Le chemin d'accès à votre fichier peut s'écrire de manière absolue ou bien de manière relative. **Vous devez tant que possible employer des chemins relatifs.** Les projets dans RStudio définissent un environnement de travail comme vu dans le module 1. Ces projets sont amenés à être employé par différents collaborateurs. Il est donc indispensable que votre projet soit **portable**.

Un projet RStudio pourra être qualifié de **portable** s'il est possible de déplacer le répertoire de base du projet et tout ce qu'il contient (ou le renommer) sans que les analyses effectuées dans R n'en soient affectées. Ceci est utile pour copier, par exemple, le projet d'un PC à un autre, ou si vous décidez de restructurer vos fichiers sur le disque dur.

La démonstration va être effectuée sur base du projet sdd1_biometry qui vous avez traité lors de la comparaison des workflows.

Votre projet s'organise comme ceci et se trouve dans le dossier project du dossier shared :

```
/home
  /sv
    /shared
      /projects
        /sdd1_biometry                 # Le répertoire de base du projet
          sdd1_biometry.Rproj          # Fichier de configuration du projet créé par RStudio
          /data                      # Le dossier avec les données de départ
            biometry_2014.xlsx       # Un jeu de données au format xlsx sur la biométrie humaine
          /analysis                  # Un dossier pour les rapports d'analyse
            biometry.nb.html  # Vue HTML du rapport générée automatiquement
            biometry.Rmd      # Un premier rapport au format R Notebook 
```

Afin de définir la position de votre fichiers `biometry_2014.xlsx`, vous devez simplement lister l'ensemble de dossier. Il s'agit du chemin absolu , de la position de votre fichier sur votre ordinateur. Ce format n'est pas du tout portable

```
/home/sv/shared/projects/sdd1_biometry/data/biometry_2014.xlsx 
```

Ce chemin est plus portable que le précédent et le tild représente le dossier utilisateur. 

```
~/shared/projects/sdd1_biometry/data/biometry_2014.xlsx
```
Comme rapellez ci-dessus, les projets dans RStudio définissent un environnement de travail. Vous devez déterminer le chemin relatif en fonction du répertoire actif dans un projet R studio, c'est le projet lui même qui est le répertoire actif. 

```
data/biometry_2014.xlsx
```

Afin de passer d'un chemin absolu à un chemin relatif vous devez :

- connaitre le répertoire actif 
- utiliser le `/` pour rentrer dans un dossier 
- utiliser le `../` pour sortir d'un dossier

Pour obtenir une explication complète et détaillée sur l'utilisation des chemins relatifs dans l'organisation d'un projet Rstudio, lisez le tutoriel : **"Tutoriel SDD-UMONS : La gestion des fichiers dans un projet et les chemins relatifs"**

#### Pièges et astuces

L'utilisation des chemins relatifs est indispensable comme expliqués ci-dessus. Lors de vos travaux organisé en plusieurs projets cohérents vous serez amené à travailler principalement dans des fichiers de type **Rscript** ou des fichiers **R notebook** ou encore **R markdown**.

**Notez ceci**

- Le **Rscript** utilise comme référence afin de définir la position d'un jeu de données (ou tous autres fichiers) dans un projet, la position de projet R studio. 

```
data/biometry_2014.xlsx
```

- Le **R notebook** ou R markdown utilise comme référence afin de définir le chemin d'accès d'un jeu de données (ou tous autres fichiers) dans un projet, sa propre position.

```
../data/biometry_2014.xlsx
```

L'utilisation des chemins d'accès relatifs respecte les mêmes principes pour l'insertion d'une image par exemple.

### Données provenant d'un url

Il existe différents programmes qui permettent d'éditer des tableaux de données en ligne et de les transmettre simplement. [Google Sheet](https://www.google.com/intl/fr_BE/sheets/about/) est l'un de ces programmes. 


Partez de l'url suivant :

- <https://docs.google.com/spreadsheets/d/1iEuGrMk4IcCkq7gMNzy04DkSaPeWH35Psb0E56KEQMw/edit?usp=sharing>

Il s'agit d'un tableau de données portant sur la croissance de différentes espèces de coraux. Ce tableau de données peut être transmis sous la forme d'un tableau csv que la fonction **read()** peut importer. 

remarque : le lien founit ne permet pas de modifier les données fournie, ce paramètre peut très simplement être modifié.

```{r}
coral <- read("https://docs.google.com/spreadsheets/d/e/2PACX-1vSxqegwJVjO0PxIs7mObr0syeYwNdpvd25AWUoWkwocQexYUqQUK0hC57NwsypQQUDnsJLiR-hxzSFA/pub?gid=0&single=true&output=csv", type = "csv")
# Visualisation des premières ligne du tableau de données
head(coral)
```

### Données provenant d'un package

Les packages que l'on peut assimiler à des boites à outils dans R que vous employer à chaque utilisation sur le programme comme **data.io**, **chart** ou encore **flow**, sont pour certains composés de jeux de données. La fonction `read()` permet également de les importer.

Précédement, une seule fonction était employé pour importer ces données. Il s'agissait de la fonction `data()`.

```{r}
# Chargement de package
library(data.io)
# Appel du jeu de données
data(urchin_bio)
# Visualisation des premières ligne du jeu de données
head(urchin_bio)
```

La fonction read() est capable d'importer ces données en une seule instruction. 

```{r}
# Importation de données provenant d'un package
urchin <- read("urchin_bio", package = "data.io")
# Visualisation des premières ligne du jeu de données
head(urchin)
```

La fonction `read()` requiert comme premier argument le nom du jeu de données (e.g. `"iris"` ou `"urchin_bio"`), suivi de l'argument `package=` (e.g. `"datasets"`, ou `"data.io"`), suivi de l'argument `lang=` (e.g. `"fr"`) qui définit la langue d'intérêt.  

L'instruction ci-dessous permet d'obtenir une liste de l'ensemble des jeux de données présent dans un package.

```{r}
read(package = "data.io")
```


### Pièges et astuces

#### Langue du jeu de données

La fonction **read()** a l'avantage de pouvoir employer un fichier annexe pour ajouter simplement les labels et les unités en différentes langues. Certains jeux de données comme le jeu de données de **urchin_bio** du package **data.io** possèdent ces fichiers annexes.

Lorsque l'on importe le jeu de données avec la fonction data(), les fichiers annexes ne sont pas employé.

```{r}
# Chargement des données
data("urchin_bio")
# Visualisation des données
chart(urchin_bio, height ~ weight %col=% origin) +
  geom_point()
```

Ces fichiers annexes sont par contre employé par la fonction **read()** pour ajouter les labels et unités au tableau de données. Certaines fonctions comme **chart()** sont capables d'employer ces labels et unités. 

```{r}
# Importation du tableau de données avec l'argument lang qui varie.
urchin <- read("urchin_bio", package = "data.io")
urchin_en <- read("urchin_bio", package = "data.io", lang = "en")
urchin_fr <- read("urchin_bio", package = "data.io", lang = "fr")
urchin_FR <- read("urchin_bio", package = "data.io", lang = "FR")
```

L'arguement lang permet de spécifier la langue souhaitée. Les différences dans les labels sont observables sur le graphique ci-dessous.

```{r}
# Réalisation graphique
a <- chart(urchin, height ~ weight %col=% origin) +
  geom_point()
b <- chart(urchin_en, height ~ weight %col=% origin) +
  geom_point()
c <- chart(urchin_fr, height ~ weight %col=% origin) +
  geom_point()
d <- chart(urchin_FR, height ~ weight %col=% origin) +
  geom_point()
# Combinaison des graphiques
combine_charts(chartlist = list(a, b, c, d))
```

 
- A & B: l'argument lang par défaut est **lang = "en"**. Il ajoute les lables et unités en  anglais avec les unités dans le système international.
- C : l'argument **lang = "fr"** ajoute les labels et unités en français. Il laisse cependant les niveaux des variables facteurs en anglais (Farm et Fishery).
- D : l'argument **lang= "FR"** ajoute les lables et unités en français. Dr plus, il traduit également les niveaux des variables facteurs.

Il vous est conseillé d'employé l'argument **lang="fr"** lors de vos différents travaux. La langues international en science est l'anglais et vous serez très certainement amené dans votre carrière scientifique de produire des documents en français et en anglais. L'utilisation de **lang= "FR"** rend le code uniquement utilisable dans ces conditions. Observez les exemples proposés ci-dessous.

```{r}
urchin_en %>.%
  filter(., origin == "Farm") %>.%
  head(.)
```

```{r}
urchin_fr %>.%
  filter(., origin == "Farm") %>.%
  head(.)
```

```{r}
urchin_FR %>.%
  filter(., origin == "Pêcherie") %>.%
  head(.)
```

## Type de variables

Lors de la réalisation de graphiques dans les modules précédents vous avez compris que toutes les variables ne se valait pas dans R. 

```{r}
(biometry <- read("biometry", package = "BioDataScience", lang = "fr"))
```

Ce graphique combiné ci-dessous montre de boites de dispersion. 

```{r}
a <- chart(biometry, height ~ gender %fill=% gender) +
  geom_boxplot() 

b <- chart(biometry, height ~ weight %fill=% gender) +
  geom_boxplot()

combine_charts(chartlist = list(a,b), common.legend = TRUE)
```

Les jeux de données sont une suite de variables mises côte à côte. Vous avez à votre disposition plusieurs type de variables pour personnaliser le jeu de données : 

- nombre :
    + numérique (continu) : `numeric`
    + entiers (discret) : `integer`
    + valeur arrondie : `double`
    + nombre complexe : `complex`

Il s'agit des valeurs numériques qui vont composer une variable du jeux de données. Si une variable numérique ne l'est pas vous pouvez la tranformer avec l'instruction suivante :

- caractères : `character`

Il s'agit de chaine de charactères qui vont composer une variable du jeux de données. Les chaines de caractères vont avoir 2 but. Soit il s'agit d'une information ayant pour objectif d'être employé comme variable facteur ou bien il s'agit d'une information complémentaire sur les observations qui ne sera pas employer dans l'analyse des données. Cependant, vous pouvez être amené à transformer une variable en caractère avec l'instruction suivante :

- facteur : `factor`

Il s'agit d'une variable permettant de discriminer des observations avec un ensemble de niveau dans un jeu de données comme la variable portant sur l'origine du tableau de donnés urchin.

- Date : `date`

Le date dans un jeu de données sont proposé sous le format date.

La fonction `skim()` du package `skimr` permet de visualiser le type de la variable et bien plus encore. Il fournit une visualisation différentes en fonction du type de la variable. Il propose par exemple un histogramme pour les variables numériques comme le montre le tableau ci-dessous

```{r, echo = TRUE}
skimr::skim(biometry)
```
Avec une seule instruction, on obtient une quantité d'information sur notr jeu de données comme le nombre d'observation, le nombre de variables et un traitement spécifique pour chaque type de variable. 

Cet instruction permet de visualiser et d'appréhender le jeu de données mais ne doit pas figurer tel quel dans un rapport d'analyse. 

#### Pièges et astuces

```{r}
tooth <- read("ToothGrowth", package = "datasets", lang = "fr")
```

Le jeu de données comprend 60 observations sur la croissance de dents de cochons d'inde. Ces derniers reçoivent 2 types de suppléments soit du jus d'orange (OC) ou de la vitamine C (VC). Ils recoivent trois doses 0.5, 1, 2 mg/jour. VOus pouvez observer les données avec la fonction **skim()**.

```{r}
skimr::skim(tooth)
```

La variable dose est encodée sous la forme de variable numérique alors que cette dernière doit être sous la forme de facteur. **Vous devez recoder cette variable.**

```{r}
tooth$dose <- as.factor(tooth$dose)
# Visualisation des données
skimr::skim(tooth)
```

Vous pouvez cependant aller encore plus loin car la variable est une variable facteur et plus précisement une variable facteur ordonée. Il y a une progression dans les doses administrées.  Prenez la variable dose du jeu de données `tooth`. Etant donné qu'il s'agit de doses croissantes administrées à des cochons d'Inde, cette variable doit donc être une variable ordonnée.

```{r}
tooth$dose <- as.ordered(tooth$dose)
# Visualisation des données
skimr::skim(tooth)
```

La fonction **as.factor()** et la fonction **as.ordered** dérive de la fonction **factor()**.

La variable facteur ordonnée est reconnue par une ensemble de fonction dans R. Elle ne sera de ce fait pas traitée de la même manière qu'une variable facteur non ordonnée. 

## Remaniement des données

Lors du module IV, vous avez réalisé votre premier remaniement de données afin de réaliser un graphique en barre résumant une variable numérique en fonction d'une variable facteur. 

Le principale remaniement des données peut être réalisé en 4 grands piliers :

- sélectionner des colonnes au sein d'un jeu de données `select()`

- filtrer des lignes dans un jeu de données `filter()`

- calculer de nouvelles variables dans un jeu de donées `mutate()`

- Résumer de colonnes d'un jeu de données initiale `summarise()`

Ces grands piliers ont été défini dans le [chapitre 5 de  R for Datascience](http://r4ds.had.co.nz/transform.html)

### `select()`

Lors de l'utilisation vos jeux de données, vous serez amené à réduire vos jeux de données en sous tableau.

```{r}
urchin <- read("urchin_bio", package = "data.io", lang = "fr")
rmarkdown::paged_table(urchin)
```

Vous vous intéressez dans votre analyse uniquement à certaines variables. La fonction `select()` et les fonctions d'aide à la selection (`?select_helpers`) vous apportent la solution à vos besoins.

```{r}
urchin1 <- select(urchin, origin, solid_parts, test)
rmarkdown::paged_table(urchin1)
```

```{r}
urchin2 <- select(urchin, c(1,4,14))
rmarkdown::paged_table(urchin2)

```

```{r}
urchin3 <-  select(urchin, origin, contains("weight"))
rmarkdown::paged_table(urchin3)
```

```{r}
urchin4 <- select(urchin, ends_with("ht"))
rmarkdown::paged_table(urchin4)
```

### `filter()`

Lors de l'analyse de vos jeux de données, vous serez amené à filtrer les lignes de vos tableaux de données. La fonction `filter()` est l'un des outils pouvant vous apporter la solution. Repartez du jeu de données portant sur la croissance des oursins simplifié à 3 variables (**urchin2**).

```{r}
rmarkdown::paged_table(urchin2)
```


Vous pouvez utiliser une variable facteur pour sélectionner uniquement un niveau d'une variable. 

- égal à : ==

- tout sauf : !=

```{r, echo = TRUE}
urchin_sub1 <- filter(urchin2, origin != "Fishery") # tous les origines sauf ceux provenant de Fishery 
rmarkdown::paged_table(urchin_sub1)
```

Vous pouvez utiliser une variable numérique pour filtrer les données. 

- supérieur à : >

- inférieur à : <

- supérieur ou égal à : >=

- inférieur ou égal à : <=

```{r}
urchin_sub2 <- filter(urchin2, height > 20) # hauteur supérieur à 20 
rmarkdown::paged_table(urchin_sub2)
```

Vous pouvez combiner différents filtres :  

- & : et 

- | : ou

```{r}
urchin_sub3 <- filter(urchin2, height > 20 & origin == "Farm") # hauteur supérieur à 20  et origine contenant uniquement les oursins venant du niveau `Farm`
rmarkdown::paged_table(urchin_sub3)
```


Avec des variables facteurs composé des nombreux niveaux comme on peut le retrouver dans le jeu de données **zooplankton** du package **BioDataScience**, vous pouvez être amené à en sélectionner plusieurs niveaux au sein de cette variable.

```{r}
zooplankton <- read("zooplankton", package = "data.io", lang  = "fr")
rmarkdown::paged_table(zooplankton)
```

- %in%

```{r}
copepoda <- filter(zooplankton,
  class %in% c("Calanoid", "Cyclopoid",  "Harpacticoid", "Poecilostomatoid"))
rmarkdown::paged_table(copepoda)
```

### `mutate()`

Lors de l'analyse de vos jeux de données, vous serez amené à calculer de nouvelles variables. La fonction `mutate()` est l'un des outils pouvant vous apporter la solution. 

Repartez du jeu de données portant sur la croisance des oursins.

Vous pouvez tout d'abord employer les 
- les opérateurs arithmétiques
      + addition : `+`
      + soustraction : `-`
      + multiplication :  `*`
      + division : `/`
      + exposant : `^` ou `**`
      + modulo (reste lors d'une division) : `%%`
      + division entière :  `%/%` 


```{r, echo= TRUE}
urchin <- mutate(urchin, 
             weight_tot =  lantern + spines + test, 
             ratio = weight_tot/skeleton,
             skeleton2 = skeleton^2)
```

- les fonctions mathématiques
    + log
    + sqrt
    + sin, cos, tan
    

```{r, echo = TRUE}
urchin <- mutate(urchin, skeleton_log =  log(skeleton), 
             skeleton_sqrt = sqrt(skeleton),
             skeleton_sin = sin(skeleton))
```

La fonction `mutate()` permet de calculer de nouvelles variables. Cependant, la fonction `transmute()` permet de retirer les anciennes variables employées dans le calcule de la nouvelle. 

### `summarise()`

```{r}
tooth <- read("ToothGrowth", package = "datasets", lang = "fr")
rmarkdown::paged_table(tooth)
```
Lors de l'analyse de vos jeux de données, vous serez amené à résumer vos données. 

```{r}
tooth_tab <- summarise(tooth, "moyenne" = mean(len), 
               "minimum" = min(len), 
               "médiane" = median(len), 
               "maximum" = max(len))
knitr::kable(tooth_tab)
```

Cette fonction n'a de véritable intêrét que couplée avec la fonction `group_by() qui va permettre de grouper un jeu de données en fonction d'une ou plusieurs variable de type facteur.

```{r}
tooth <- group_by(tooth, supp)

tooth_tab <- summarise(tooth, "moyenne" = mean(len), 
               "minimum" = min(len), 
               "médiane" = median(len), 
               "maximum" = max(len))
knitr::kable(tooth_tab)
```

#### Pièges et astuces

Tout comme lors de réalisation d'une boite de dispersion, vous devez être particulièrement vigilant ou nombre d'observation par sous groupe. Ajoutez à chaque tableau résumé des données, le nombre d'observation par sous-groupe.

```{r}
tooth_tab <- summarise(tooth, "moyenne" = mean(len), 
               "minimum" = min(len), 
               "médiane" = median(len), 
               "maximum" = max(len),
               "observation" = n())
knitr::kable(tooth_tab)
```


## Chainage 

Le chainage (ou le pipe en anglais) permet de combiner une suite de fonction à appliquer sur un jeu de données par exemple comme lorsque vous souhaitez réaliser plusieurs étapes de remaniement des données.

Différents pipes existent et nous avons décidé de vous présenter le pipe du package **flow**. Le jeu de données sur la biométrie humaine est employé pour cette démonstration qui va comparer le remaniement d'un tableau de données avec et sans l'utilisation du chainage. 

```{r}
biometry <- read("biometry", package = "BioDataScience", lang = "fr")
biometry1 <- read("biometry", package = "BioDataScience", lang = "fr")
```

L'opérateur qui permet de chainer les fonctions est **%>.%**

Sur le jeu biometry, vous vous interessez aux IMC (bmi en anglais) des individus de moins de 25 ans. Vous souhaitez représenter la moyenne, la médiane et le nombre d'observations des hommes et des femmes de cette population dans un tableau. 

Pour obtenir ces données vous devez : 

- calculer le imc
- filter le tableau pour n'obtenir que le individus de moins de 25 ans
- résumer les données afin d'obtenir la moyenne et la médiane par genre.
- afficher un tableau de données avec ces résultats

```{r}
# Sans chainage 
biometry <- mutate(biometry, bmi = weight/((height/100))^2)
biometry_sub <- filter(biometry, age <=25)
biometry_sub <- group_by(biometry_sub, gender)
biometry_tab <- summarise(biometry_sub, mean = mean(bmi), 
                          median = median(bmi), number = n())
knitr::kable(biometry_tab, rows = NULL, 
            col = c("Genre", "Moyenne", "Médiane", "Observations"))
```


```{r}
# avec le chainage 
biometry1 %>.%
  mutate(., bmi = weight/((height/100))^2) %>.%
  filter(., age <= 25) %>.%
  group_by(., gender) %>.%
  summarise(.,  mean = mean(bmi), median = median(bmi), number = n()) %>.%
  knitr::kable(., rows = NULL, 
            col = c("Genre", "Moyenne", "Médiane", "Observations"))

```

Le pipe permet d'éviter certaine répétion afin de réaliser en cascade la suite des opérations. Il permet également de faciliter la lecture du code. Vous devez être vigilant à la structure du pipe qui comprend le pipe `%>.%`et le point au début des fonctions `.`. Le pipe fait le lien entre les différentes fonctions et le point renvoit au jeu de données passant de fonction en fonction. 

#### Pour en savoir plus 

- [Customisation de tableau](http://www.sthda.com/english/rpkgs/ggpubr/reference/ggtexttable.html)

## A vous de jouer !

Un squelette de projet RStudio vous a été fournit dans un dépôt Github Classroom, y compris organisation des fichiers et jeux de données types. Votre objectif est de : 

- Importer les données provenant du `ToothGrowth`

- Comprendre les données proposées, en utilisant des visualisations graphiques appropriées 

- Reproduire de plus le graphique ci-dessous 

- Documenter  le fruit de votre étude dans un rapport R Notebook.
