# Traitement des données II {#qualit}

```{r setup, include=FALSE, echo=FALSE, message=FALSE, results='hide'}
knitr::opts_chunk$set(comment = '#', fig.align = "center")
SciViews::R
```

##### Objectifs {-}

- Comprendre les principaux tableaux de données utilisés en science des données

- Savoir réaliser des tableaux de contingences

- Acquérir des données et les encoder correctement et de manière à ce que les analyses soient reproductibles

- Etre capable de remanier des tableaux de données et de fusionner plusieurs tableaux


##### Prérequis {-}

Ce module est la continuation du module \@ref(import) dont le contenu doit être bien compris et maîtrisé avant de poursuivre ici.


## Tableaux de données

Les tableaux de données sont principalement représentés sous deux formes : les tableaux **cas par variables** et les tableaux de **contingence**.


### Tableaux cas par variables

Chaque individus est représenté en ligne et chaque variable en colonne par convention. En anglais, on parlera de [tidy data](https://www.jstatsoft.org/article/view/v059i10).

Nous nous efforcerons de toujours créer un tableau de ce type pour les données brutes. La question à se poser est la suivante : est-ce que j'ai un seul et même individu représenté sur *chaque* ligne du tableau\ ? Si la réponse est non, le tableau de données n'est **pas** correctement encodé.

TODO : exemple et solution

Les tableaux de données que vous avez traités jusqu'à présent étaient tous des tableaux **cas par variables**. Chaque ligne représentait un _individu_ sur qui une ou plusieurs _variables_ (en colonnes) étaient mesurées.

```{r}
biometry <- read("biometry", package = "BioDataScience", lang = "fr")
head(biometry)
```

L'encodage d'un petit tableau cas par variables directement dans R est facile. Cela peut se faire de plusieurs façons différentes. En voici deux utilisant les fonctions `tibble()` (spécification colonne par colonne, utilisez le snippet `.dmtibble` pour vous aider) et `tribble()` (spécification ligne par ligne, utilisez le snippet `.dmtribble`) :

```{r}
# Spécification colonne par colonne avec tibble()
(DF <- as_dataframe(tibble(
  x = c(1, 2),
  y = c(3, 4)
)))
```

```{r}
# Spécification ligne par ligne avec tribble()
(DF1 <- as_dataframe(tribble(
  ~x, ~y,
   1,  3,
   2,  4
)))
```

La seconde approche est plus naturelle, mais la première permet d'utiliser diverses fonctions de R pour faciliter l'encodage, par exemple :

- Séquence d'entiers successifs :

```{r}
1:10
```

- Répétition d'un vecteur 5 fois :

```{r}
rep(c("a", "b", "c"), 5)
```

- Répétition de chaque item d'un vecteur 5 fois :

```{r}
rep(c("a", "b", "c"), each = 5)
```

Pour de plus gros tableaux, il vaut mieux utiliser un tableur tel que Excel ou LibreOffice Calc pour l'encodage. Les tableurs en ligne comme Google Sheets ou Excel Online conviennent très bien également et facilitent un travail collaboratif ainsi que la mise à disposition sut le Net, comme nous avons vu au module \@ref(import).


### Tableaux de contingence

C'est le dénombrement de l'occurence de chaque niveau d'une (tableau à une entrée) ou de deux variables **qualitatives** (tableau à double entrée). La fonction `table()` crée ces deux types de tableaux de contingence à partir de données encodées en tableau cas par variables :

```{r}
biometry$age_rec <- cut(biometry$age, include.lowest = FALSE, right = TRUE,
  breaks = c(14, 27, 90))
(bio_tab <- table(biometry$gender, biometry$age_rec))
```

Le tableau de contingence peut toujours être calculé à partir d'un tableau cas par variable, mais il peut également être encodé directement si nécessaire. Voic un petit tableau de contingence à simple entrée encodé directement comme tel (vecteur nommé transformé en objet `table` à l'aide de la fonction `as.table()`) :

```{r}
anthirrhinum <- as.table(c(
  "fleur rouge"   = 54,
  "fleur rose"    = 122,
  "fleur blanche" = 58)
)
anthirrhinum
```

Une troisième possibilité est d'utiliser un tableau indiquant les **fréquences d'occurence** dans une colonne (`freq` ci-dessus). Ce n'est **pas** un tableau cas par variable, mais une forme bien plus concise et pratique pour préencoder les données qui devront être ensuite transformées en tableau de contingence à l'aide de la fonction `xtabs()`. Voici un exemple pour un tableau de contingence à double entrée. Notez que le tableau cas par variable correspondant devrait contenir 44 + 116 + 19 + 128 = 307 lignes et serait plus fastidieux à construire et à manipuler (même en utilisant la fonction `rep()`).

```{r}
timolol <- tibble(
  traitement = c("timolol", "timolol", "placebo", "placebo"),
  patient    = c("sain",    "malade",  "sain",    "malade"),
  freq       = c(44,        116,       19,        128)
)
# Creation du tableau de contingence 
timolol_table <- xtabs(data = timolol, freq ~ patient + traitement)
timolol_table
```

La sortie par défaut d'un tableau de contingence n'est pas très esthétique, mais plusieurs options existent pour le formatter d'une façon agréable. En voici deux exemples :

```{r}
pander::pander(timolol_table,
  caption = "Exemple de table de contingence à double entrée.")
```

```{r}
knitr::kable(timolol_table,
  caption = "Exemple de table de contingence à double entrée.")
```

Il est même possible de représenter *graphiquement* un tableau de contingence pour l'inclure dans une figure composée, éventuellement en le mélangeant avec des graphiques^[Utilisez cette option avec parcimonie : il vaut toujours mieux représenter un tableau comme ... un tableau plutôt que comme une figure !].

```{r}
tab1 <- ggpubr::ggtexttable(head(biometry), rows = NULL)
tab2 <- ggpubr::ggtexttable(table(biometry$gender, biometry$age_rec))

combine_charts(list(tab1, tab2), nrow = 2)
```

Différentes fonctions dans R existent également pour convertir un tableau de contingence en tableau cas par variables (ou en tous cas, en un tableau similaire). Par exemple, `as_dataframe()` renvoie un tableau indiquant les fréquences d'occurences :

```{r}
(timolol2 <- as_dataframe(timolol_table, n = "freq"))
```

Si vous insistez, vous pouvez aussi obtenir un tableau cas par variables (mais celui-ci est très long et peu pratique à manipuler) à l'aide de la fonction `uncount()`^[Notez également que passer d'un tableau cas par variables à un tableau des fréquences d'occurences se fait à l'aide de `count()`.] :

```{r}
uncount(timolol2, freq)
```


### Métadonnées

Les données dans un tableau de données doivent **impérativement** être associées à un ensemble de métadonnées. Les métadonnées (metadata en anglais) apportent des informations complémentaires nécessaires pour une interprétation corrrecte des données. Elles permettent donc de replacer les données dans leur contexte et de spécifier des caractéristiques liées aux pesures réalisées comme les unités de mesure par exemple.

$$Donn\acute{e}es \ de \ qualit\acute{e} \ = \ tableau \ de \ donn\acute{e}es + \ m\acute{e}tadonn\acute{e}es$$

Les données correctement qualifiées et documentée sont les seules qui penvent être utilisées par un collaborateur externe. C'est à dire qu'une personne externe à l'expérience ne peut interpréter le tableau de données que si les métadonnées sont complètes et explicites. 

Exemple de métadonnées :

- Unités de mesure (exemple : 3,5 mL, 21,2 °C)
- Précision de la mesure (21,2 +/- 0,2 dans le cas d’un thermomètre gradué tous les 0,2 °C)
- Méthode de mesure utilisée (thermomètre à mercure, ou électronique, ou ...)
- Type d’instrument employé (marque et modèle du thermomètre par exemple)
- Date de la mesure
- Nom du projet lié à la prise de mesure
- Nom de l’opérateur en charge de la mesure
- ...

Vous avez pu vous aperçevoir que la fonction `read()` permet d'ajouter certaine métadonnées comme les unités aux variables d'un jeu de données. Cependant, il n’est pas toujours possible de rajouter les métadonnées dans un tableau sous forme électronique, mais il faut toujours les consigner dans un **cahier de laboratoire**, et ensuite les **retranscrire dans le rapport**.


## Population et échantillonnage

...

```{r}
DT::datatable(iris)
```


## Acquisition de données

Dans le module \@ref(import), vous avez pris connaissance des types de variable et venez d'apprendre comment encoder différents types de tableaux de données et de leurs associer les indispensables métadonnées. Cependant, la première étape avant d'acquérir des données est de planifier correctement son expérience. La Science des Données est intimement liée à la démarche scientifique et intervient dans toutes les étapes depuis la caractérisation de la question et le planning de l'expérience jusqu'à la diffusion des résultats. Plus en détails, cela correspond à :

- Définir une question (objectif)
- Réaliser une recherche bibliographique sur la thématique
- Définir le protocole de l'expérience à partir de l'objectif
    + Définir la population étudiée et l'échantillonnage
    + Définir les variables à mesurer 
        + Définir les unité des mesures
        + Définir la précision des mesures 
        + Définir les instruments de mesure nécessaires 
- Définir les conventions d'encodage
    + Codifier l'identification des individus
    + Définir les niveaux des variables facteurs et leurs labels
- Acquérir et encoder les données
- Traiter les données
    + Importer des données
    + Remanier des données
    + Visualiser et décrire des données 
    + Analyser les données (traitements statistiques, modélisation,...).
- Produire des supports de présentation pour répondant à la question de départ et diffuser l'information dans la communauté scientifique

Nous trtaitons ici des premières étapes qui visent à acquérir les données.


### Précision et exactitude

Les erreurs de mesures sont inévitables lors de l'acquisition de nos données. Cependant, il est possible de les minimiser en choisissant un instrument plus précis (precise en anglais) et plus exact (accurate en anglais). La figure ci-dessous illustre de manière visuelle la différence qu'il y a entre précision et exactitude.

![](images/sdd1_06/targets.png)


### Codification des données

Afin d'éviter que divers collaborateurs encodent différemment la même information, vous allez devoir préciser très clairement comment encoder les différentes variables de votre jeu de données. Par exemple pour une variable `genre`, est-ce que vous indiquez `homme` ou `femme`, ou `h` / `f`, ou encore `H` / `F` ?

De même, vous allez devoir attribuer un code **unique** à chaque individu mesuré. Enfin, vous devez vous assurer que toutes les mesures sont réalisées de la même manière et avec des instruments qui, s'ils sont différents, seront cependant **intercalibrés**. Comment faire ? Réfléchissez à cette question sur base d'une mesure de la masse des individus à l'aide de pèse-personnes différents ! 


#### Respect de la vie privée

Lors d'expérience sur des personnes, le respect de la vie privée **doit** être pris en compte. Le nom et le prénom, ou toute autre information permettant de retrouver les individus étudiés (adresse mail, numéro de sécurité sociale, etc.) ne *peut pas* apparaître dans la base de données consolidée. En outre, il vous faudra un accord explicite des personnes que vous voulez mesurer, et il faudra leur expliquer *ce que* vous faites, et *comment* les données seront ensuite utilisées. Une question se pose : comment pouvoir revenir vers les enregistrements liés à un individu en particulier (en cas d'erreur d'encodage, par exemple) si les informations relatives directement à ces individus ne sont pas consignées dans le tableau final ? Réfléchissez à la façon dont vous vous y prendriez avant de lire la suite...

Voici un petit tableau qui correspond à ce que vous ne pourrez **pas** faire (nom et prénom explicitement mentionnés dans le tableau) :

```{r}
(biometry_marvel <- as_dataframe(tribble(
  ~id,                 ~sex ,~weight, ~height,
   "Banner Bruce",     "M",  95,      1.91,
   "Stark Tonny",      "M",  80,      1.79,
   "Fury Nicholas",    "M",  82,      1.93,
   "Romanoff Natasha", "F",  53,      1.70
)))
```

Vous devez fournir une code permettant de garder l'anonymat des sondés à l'ensemble des personnes étudiées vis à vis des analystes qui vont utiliser ces données. Cependant, le code doit permettre au chercheur ayant pris ces mesures de les retrouver dans son cahier de laboratoire, si besoin. Une façon de procéder consiste à attributer un numéro au hasard par tirage dans une urne à chacune des personnes chargées des mesures. Ensuite, chaque expérimentateur attribue lui-même un second numéro aux différentes personnes qu'il mesure. Prenons par exemple le scientifique n°24 (seul lui sait qu'il porte ce numéro). Il attribue un code de 1 à n à chaque personne étudiée. En combinant le code secret de l'expérimentateur et le code individu, cela donne un identifiant unique de la forme `24_1`, `24_2`, etc. Il pourra alors encoder sa partie comme suit : 

```{r}
(biometry_marvel1 <- as_dataframe(tribble(
  ~id,     ~sex , ~weight, ~height,
   "24_1",  "M",  95,      1.91,
   "24_2",  "M",  80,      1.79,
   "24_3",  "M",  82,      1.93,
   "24_4",  "F",  53,      1.70
)))
```

Il garde néanmoins les correspondances dans son carnet de laboratoire, au cas où il faudrait faire des vérifications ou revenir à la donnée originale.

```{r}
(biometrie_correspondance <- data_frame(
  name = biometry_marvel$id,
  id   = biometry_marvel1$id
))
```

A partir des données du tableau général consolidé, personne à part lui ne peut revenir sur ces données d'origine et mettre un nom sur les individus mesurés. Et lui-même n'a pas la possibilité de déterminer *qui* se cache derrière les autres identifiants tels `3_1`, `12_4`, `21_2`, etc.


##### A vous de jouer {-}

Votre objectif est d'acquérir des données pour étudier la prévalence de l'obésité dans la population. En classe, vous allez réfléchir par équipes aux données qu'il vous faudra mesurer : *quoi ?* *pourquoi ?* *comment ?* Les résultats de votre réflexion seront ensuite consolidées pour arriver à un *consensus*  général. Ensuite, le fruit de cette réflexion ainsi que l'analyse que vous réaliserez seront à ajouter dans le projet **sdd1_biometry**. Une feuille Google Sheets sera mise à disposition pour encoder vos données de manière collaborative sur base des spécifications que vous aurez formulées.

**Attention, veuillez à respectez les conventions** que vous aurez édifiées ensemble lors de l'encodage... et n'oubliez pas de préciser également les métadonnées !

## Recombinaison de tableaux

### `gather()` & `spread()`

Encoder correctement un tableau de données n'es pas une chose simple. Il peut y avoir plusieurs manières de le représenter en fonction du type de représentation que l'on souhaite, du type d'analyse,...Quoi qu'il en soit, il est important de connaitre les fonctions permettant de recombiner simplement un tableau de données. 

L'aide-mémoire [Data Import::CHEAT SHEET](https://github.com/rstudio/cheatsheets/blob/master/data-import.pdf) est l'outil pour vous aider dans cette tache. Vous y trouverez des explication dans la section Reshape Data. 

Ces outils provenant du package **tidyr** sont décrits en détails dans  ["R for Data Science"](https://r4ds.had.co.nz/tidy-data.html#spreading-and-gathering). 


Prenons l'exemple de ce tableau de contingence provenant des données relatée dans l'article suivant : [Paleomicrobiology to investigate copper resistance in bacteria : isolation and description of Cupriavidus necator B9 in the soil of a medieval foundry](http://di.umons.ac.be/details.aspx?pub=0a0de102-c145-403f-9e1c-8ad4fdc1fc39). 

L'article est basé sur l'analyse métagénomique de type shotgun pour 4 communautés microbiennes. Comme ces analyses coûtent très cher, il est souvent impossible de faire des réplicats. Un seul échantillon d'ADN a donc été séquencé par communauté. Il en résulte une longue liste de sequences que l'on peut attribuer à des règnes. 

```{r}
shot_gun <- data.frame(kingdom = c("Archaea", "Bacteria", "Eukaryota", "Viruses", 
                                    "other sequences", "unassigned", 
                                    "unclassified sequences"),
                        c1 = c( 98379, 6665903, 81593, 1245, 757, 1320419, 15508),
                        c4 = c( 217985, 9739134, 101834, 4867, 1406, 2311326, 21572),
                        c7 = c( 143314, 7103244, 71111, 5181, 907, 1600886, 14423),
                        c10 = c(272541, 15966053, 150918, 15303, 2688, 3268646, 35024))

rmarkdown::paged_table(shot_gun)
```

Ce tableau dénombre les séquences appartenant à chaque règne. Ce tableau de contingence est pratique afin de reprensenter les données mais il ne l'est pas autant pour réaliser des graphiques (par exemple). Les colonnes C1, C4, C7 et C10 sont d'une certaine manière une variable facteur qui a été employé en colonne que l'on peut aisement retransformé comme telle. 

```{r}
 shot_gun1 <- gather(shot_gun, c1, c4, c7, c10, key = "batch" ,value = "sequences")
rmarkdown::paged_table(shot_gun1)
```
Vous en conviendrez que le tableau nommé shot_gun1 est moins aisée à lire comparé à tableau shot_gun. Cependant, il permet de produire facilement des graphique. 

```{r}
chart(shot_gun1, formula = sequences ~ batch %fill=% kingdom) +
  geom_col(position = "fill")
```

La fonction opposée à `gather()` est la fonction `spread()` qui permet de retourner vers le tableau d'origine. 

```{r}
shot_gun2 <- spread(shot_gun1, key = batch, value = sequences) 
# visualisation du tableau de données 
rmarkdown::paged_table(shot_gun2)
```


### `separate` & `unite()`

Lors de vos analyses vous serez confronté à devoir combiner ou séparer des colonnes de votre tableau de données. 

L'aide-mémoire [Data Import::CHEAT SHEET](https://github.com/rstudio/cheatsheets/blob/master/data-import.pdf) est l'outil pour vous aider dans cette tache. Vous y trouverez des explication dans la section Split Cells. 

Ces outils provenant du package **tidyr** sont décrits en détails dans  ["R for Data Science"](https://r4ds.had.co.nz/tidy-data.html#separating-and-uniting). 


Partez donc du jeu de données sur la biométrie des crabes du package **MASS**

```{r}
crabs <- read("crabs", package = "MASS", lang = "fr")
rmarkdown::paged_table(crabs)
```

La fonction qui permet de combiner facilement les colonnes sex et species est la fonction `unite()` comme montré dans l'exemple ci-dessous. N'hésitez pas à faire appel à la fonction d'aide pour connaitre les arguments de la fonction. 

```{r}
crabs <- unite(crabs, col = "sp_sex",sex, species, sep = "_")
rmarkdown::paged_table(crabs)
```

La fonction opposée à `unite()` est la fonction `separate()` qui permet de retourner vers le tableau d'origine.

```{r}
crabs <- separate(crabs, col = "sp_sex", into = c("sex", "species"), sep = "_")
rmarkdown::paged_table(crabs)
```

## Multi-tableaux

Durant vos analyses, vous serez confronté à devoir gérer plusieurs tableaux que vous allez vouloir rassembler en un seul tableau.

L'aide-mémoire [Data Import::CHEAT SHEET](https://github.com/rstudio/cheatsheets/blob/master/data-transformation.pdf) est l'outil pour vous aider dans cette tache. Vous y trouverez des explications dans la section Combine Tables. 

Ces outils provenant du package **dplyr** sont décrits en détails dans ["R for Data Science"](https://r4ds.had.co.nz/relational-data.html). 

Pour combiner deux tableaux de données par les lignes, la fonction la plus simple est `bind_rows()`.

Partons de données mesurée dans les mésoscosmes de notre laboratoire les différents paramètres suivants : 
- la temperature, le ph, la salinté, l'oxygène dissous à l'aide d'instruments tels qu'un pHmètre, un conductimètre ou encore un oxymètre
- la concentration en orthophosphate et en nitrate dissous  dans l'eau à l'aide d'un autoanalyseur employant la colorimétrie

Ils ont obtenu 3 fichiers qu'ils ont du par la suite recombiner.

Le groupe A a encodé le tableau suivant : 

```{r}
param_physico_A <- as_dataframe(tibble(sample = c("A0", "B0", "A0", "B0", "A0", 
                                                "B0", "A0", "B0"), 
                                     ph = c(7.94, 7.94, 7.94, 7.99, 7.94, 7.99,
                                            7.94, 7.99),
                                     salinity = c(34.0, 35.3, 33.9, 35.1, 34.0,
                                                  35.2, 33.9, 35.1),
                                     oxygen = c(7.98, 8.00, 7.98, 7.98, 7.99, 
                                                7.86, 7.89, 7.98),
                                     temperature = c(24.6, 24.4, 25.1, 24.7, 
                                                     24.9, 24.7, 25.0, 24.6),
                                     student = c("st1", "st1", "st2", "st2", 
                                                 "st3", "st3", "st4", "st4" )
                                     ))
rmarkdown::paged_table(param_physico_A)
```

Le groupe B a encodé le tableau suivant :

```{r}
param_physico_B <- as_dataframe(tibble(sample = c("A0", "B0", "A0", "B0"), 
                                      ph = c(7.94, 7.99, 7.93, 7.99),
                                      salinity = c(33.8, 35.0, 33.9, 35.1),
                                      oxygen = c(7.96, 8.01, 7.90, 8.00),
                                      temperature = c(25.0, 24.6, 24.0, 24.0),
                                      student = c( "st5", "st5", "st6", "st6")
                                      ))
rmarkdown::paged_table(param_physico_A)
```


La combinaison des deux tableaux de données se fait via la fonction bind_rows()

```{r}
param_physico <- bind_rows(param_physico_A, param_physico_B)
rmarkdown::paged_table(param_physico)
```

Les deux groupes ont également réalisés des prélèvements d'eau qui ont été dosé par colorimétrie avec un autoanalyseur. Les échantillons des deux groupes ont été analysé dans la même série.

```{r}
nutrient <- as_dataframe(tibble(sample = rep(c("A0", "B0"), times = 6),
                                student = c("st4", "st4", "st6", "st6", 
                                            "st5", "st5", "st2", "st2",
                                            "st1", "st1", "st3", "st3"),
                                po4_conc = c(2.445, 0.374, 2.446, 0.394, 2.433,
                                             0.361, 2.441, 0.372, 2.438, 0.388,
                                             2.445, 0.390),
                                no3_conc = c(1.145, 0.104, 0.447, 0.066, 0.439,
                                             0.093, 0.477, 0.167, 0.443, 0.593,
                                             0.450, 0.125)
                                     ))
rmarkdown::paged_table(nutrient)
```

Pour combiner deux tableaux de données par les colonnes, la fonction la plus simple est `bind_cols()`.

Vous devez être très vigilant lors de l'utilisation de cette fonction car cette dernière combine vos tableaux sans s'assurer que vos lignes soient alignées convenablement. 



```{r}
param <- bind_cols(param_physico, nutrient)
# Visualisation du tableau de données
rmarkdown::paged_table(param)
```

Qu'observez vous ? 

Effectivement nos deux tableaux de données n'ont pas les lignes dans le même ordre. Il faut être vigilant lors de ce genre de combinaison de tableaux. IL est préférable d'employer des fonctions comme left_joint() qui vont employer un ou plusieurs colonnes similaire sur les deux tableaux de donnée.

```{r}
param <- left_join(param_physico, nutrient, by = c("student", "sample"))
# Visualisation du tableau de données
rmarkdown::paged_table(param)
```

##### A vous de jouer {-}

TODO
