# Visualisation II {#visu2}

```{r setup, include=FALSE, echo=FALSE, message=FALSE, results='hide'}
knitr::opts_chunk$set(comment = '#', fig.align = "center")
SciViews::R
library(viridis)
iris <- read(file = "iris", package = "datasets", lang = "fr")
zooplankton <- read( file = "zooplankton", package = "data.io", lang = "fr")
toothgrowth <- read(file = "ToothGrowth", package = "datasets", lang = "fr")
```

#### Objectifs : {-}

- Savoir réaliser différentes variantes de différents graphiques tel que les histogrammes, les graphes de densité ou encore les diagramme en violon dans R avec la fonction `chart()`

- Intégrer ensuite des graphiques dans un rapport et y décrire ce que que vous observez

- Gérer des conflits dans GitHub

#### Prérequis : {-}

Si ce n'est déjà fait, vous devez avoir réaliser les modules précédents.

## Histogramme

Lors d'une expérience vous souhaitez visualiser la façon dont vos données s'étale sur un axe (On parle de **distribution**^[TODO] en statistique) pour l'une des vairables étudiées. L'histogramme est l'un des outils pouvant vous apporter cette information. Ce graphique va découper en plusieurs **classes**^[TODO] la variable étudiée.


```{r, fig.cap= "Histogramme montrant la distribution de la taille d'un échantillon de zooplancton analysé par analyse d'image.", echo=FALSE, message=FALSE, warning=FALSE}
chart(zooplankton, formula = ~ size) +
  geom_histogram(bins = 50) +
  ylab("Nombre d'occurence") +
  theme(axis.text.x = element_text(colour = "#a80039", size = 15), 
        axis.title.x = element_text(colour = "#029687", size = 15), 
        axis.text.y = element_text(colour = "#a80039", size  = 15), 
        axis.title.y = element_text(colour = "#029687", size = 15),
        axis.line.x = element_line(colour = "#a80039"),
        axis.line.y = element_line(colour = "#a80039"))
```
 Les éléments indispensables à la compréhension d'un histogramme sont (ici mis en évidence en couleur)

- Les axes avec les graduations (en rouge)
- les labels et unité des axes (en bleu)


Les instructions de base afin de produire un histogramme :

```{r, fig.cap="Instructions pour obtenir un histogramme."}
# Importation du jeu de données
(zooplankton <- read( file = "zooplankton", package = "data.io", lang = "fr"))
# Réalisation du graphique
chart(zooplankton, formula = ~ size) +
  geom_histogram(bins = 50) 
# bins permet de préciser le nombre de classes souhaitées

```


 La fonction `chart()` requiert comme argument le jeu de donnée (`zooplankton`, c'est un objet `dataframe` ou `tibble` dans le langage de R), ainsi que la formule à employer dans laquelle vous avez indiqué le nom de la variable que vous voulez sur l'axe des abscisses à droite de la formule. Vous voyez que le jeu de données contient beaucoup de variables (les titres des colonnes du tableau en sortie). Parmi toutes ces variables, nous avons choisi ici de représenter `size`, Jusqu'ici, nous avons spécifié _ce que_ nous voulons représenter, mais pas encore _comment_ (sous quelle apparence), nous voulons les matérialiser sur le graphique. Pour un histogramme, nous devons ajouter la fonction `geom_histogram()` pour indiquer cela. L'argument `bins` dans cette fonction permet de préciser le nombre de classes souhaitées.


Vous pouvez décripter votre histogramme sur base des **modes**^[todo] et de la **symétrie**^[TODO] de ces derniers. Les modes les plus fréquents sont unimodal, bimodal ou multimodal. 

```{r, fig.cap = "Histogrammes montrant les modes et symétries : A. histogramme unimodal et symétrique, B. histogramme bimodal et asymétrique, C. histogramme unimodal et asymétrique, D. histogramme multimodal et symétrique.", echo=FALSE, message=FALSE, warning=FALSE}
set.seed(1000)
c <- rnorm(5000,35,5)
c1 <- as.data.frame(c)
g1 <- chart(c1, formula = ~ c) +
  geom_histogram() +
  labs( x = "Unimodal & symétrique", 
        y = "Nbre d'occurence") +
  theme(axis.text.x = element_text(colour = "#a80039", size = 15), 
        axis.title.x = element_text(colour = "#029687", size = 15), 
        axis.text.y = element_text(colour = "#a80039", size  = 5), 
        axis.title.y = element_text(colour = "#029687", size = 15),
        axis.line.x = element_line(colour = "#a80039"),
        axis.line.y = element_line(colour = "#a80039"))


d <- rnorm(7000,60,5)
e <- c(c,d)
g <- e
d1 <- as.data.frame(e)

g2 <- chart(d1, formula = ~ e) +
  geom_histogram() +
  labs( x = "Bimodal & symétrique", 
        y = "Nbre d'occurence") +
  theme(axis.text.x = element_text(colour = "#a80039", size = 15), 
        axis.title.x = element_text(colour = "#029687", size = 15), 
        axis.text.y = element_text(colour = "#a80039", size  = 5), 
        axis.title.y = element_text(colour = "#029687", size = 15),
        axis.line.x = element_line(colour = "#a80039"),
        axis.line.y = element_line(colour = "#a80039"))

e <- c1[c1$c > 34 , ]
e1 <- as.data.frame(e)
g3 <- chart(data = e1, formula = ~ e) +
  geom_histogram() +
  labs( x = "Unimodal & asymétrique", 
        y = "Nbre d'occurence") +
  theme(axis.text.x = element_text(colour = "#a80039", size = 15), 
        axis.title.x = element_text(colour = "#029687", size = 15), 
        axis.text.y = element_text(colour = "#a80039", size  = 5), 
        axis.title.y = element_text(colour = "#029687", size = 15),
        axis.line.x = element_line(colour = "#a80039"),
        axis.line.y = element_line(colour = "#a80039"))

f <- rnorm(3000, 80, 5)
c <- c(g,f)
c1 <- as.data.frame(c)

g4 <- chart(c1, formula = ~ c) +
  geom_histogram() +
  labs( x = "Multimodal & symétrique", 
        y = "Nbre d'occurence") +
  theme(axis.text.x = element_text(colour = "#a80039", size = 15), 
        axis.title.x = element_text(colour = "#029687", size = 15), 
        axis.text.y = element_text(colour = "#a80039", size  = 5), 
        axis.title.y = element_text(colour = "#029687", size = 15),
        axis.line.x = element_line(colour = "#a80039"),
        axis.line.y = element_line(colour = "#a80039"))

ggpubr::ggarrange(g1, g2, g3, g4)
rm(g1, g2, g3, g4, c1, c, f, e1, e, d1, g, d)
```


### Pièges et astuces

#### Nombres de classes d'un histogramme

Vous devez être particulièrement vigilant lors de la réalisation d'un histogramme aux classes de ce dernier. 

```{r, fig.cap = "Piège de l'histogramme. A. histogramme initiale montrant la répartition des tailles au sein d'organismes planctoniques. B., C., D. Histogramme A en modifiant le nombres de classes "}
# Réalisation du graphique précédent
a <- chart(zooplankton, formula = ~ size) +
  geom_histogram(bins = 50) 
# modification du nombre de classes
b <- chart(zooplankton, formula = ~ size) +
  geom_histogram(bins = 20)

c <- chart(zooplankton, formula = ~ size) +
  geom_histogram(bins = 10)

d <- chart(zooplankton, formula = ~ size) +
  geom_histogram(bins = 5) 

# Assemblage des graphiques
ggpubr::ggarrange(a,b,c,d,labels = "AUTO", font.label = list(size = 14, align = "hv"))
```

Comme vous pouvez le voir ci-dessus, le changement du nombre de classes peut modifier complètement la perception des données.

#### Utilisation des snippets

RStudio permet de récupérer rapidement des instructions à partir d'une banque de solutions toutes prêtes. Cela s'appelle des **snippets**. Vous avez une série de snippets disponibles dans la SciViews Box. Cela qui vous permet de réaliser un histogramme s'appelle `.cuhist`. Entrez ce code et appuyez ensuite sur la tabulation dans un script R, et vous verrez le code remplacé par ceci :

```
chart(data = DF, ~VARNUM) +
    geom_histogram(binwidth = 30)
```

L'argument `binwidth` permet de préciser la largeur des classes.

Vous avez à votre disposition un ensemble de snippet que vous pouvez retrouvez dans l'aide mémoire sur [**SciViews**](https://github.com/BioDataScience-Course/cheatsheets/blob/master/keynote/sciviews_cheatsheet.pdf).

Vous avez également à votre disposition l'aide-mémoire sur la visualisation des données ([**Data Visualization Cheat Sheet**](https://www.rstudio.com/resources/cheatsheets/)).

#### Histogramme par facteur

Lors de l'analyse de jeux de données , vous serez amené à réaliser un histogramme par facteur.  

```{r, fig.cap= "Histogramme de la longueur des sépales de 3 espèces d'iris."}
# Importation du jeu de données
(iris <- read(file = "iris", package = "datasets", lang = "fr"))
# Réalisation de l'histogramme par facteur
chart(iris, ~ sepal_length %fill=% species) +
  geom_histogram() +
  scale_fill_viridis_d() # palette de couleur harmonieuse
```

 La fonction `chart()` requiert comme argument le jeu de donnée (`iris`, c'est un objet `dataframe` ou `tibble` dans le langage de R), ainsi que la formule à employer dans laquelle vous avez indiqué le nom de la variable que vous voulez sur l'axe des abscisses à droite de la formule. Parmi toutes ces variables, nous avons choisi ici de représenter `sepal_length`, et d'employer la couleur de l'intérieur des classes (`%fill=%`) pour différencier les 3 espèces de ce jeu de données avec la `species` . Jusqu'ici, nous avons spécifié _ce que_ nous voulons représenter, mais pas encore _comment_ (sous quelle apparence), nous voulons les matérialiser sur le graphique. Pour un histogramme, nous devons ajouter la fonction `geom_histogram()` pour indiquer cela. La fonction `scale_fill_viridis_d()` permet d'obtenir des couleurs harmonieuses.
 
Cette opération peut avoir un rendu graphique plutôt décevant dont voici deux astuces pour l'éviter. La premières astuces est d'employer préférentiellement les `facets` au lieu de l'argument `%fill=%`.

```{r , fig.cap= "Histogramme de la longueur des sépales de 3 espèces d'iris en employant les facets comme argument pour discriminer les espèces."}
chart(iris, ~ sepal_length | species) +
  geom_histogram()
```

L'histogramme est maintenant séparé en trois en fonction des niveaux de la variable facteur `species`. Cette procèdure simplifie grandement la visualisation de la distribution de la variable `sepal_length`.

[Simon Jackson](https://drsimonj.svbtle.com/plotting-background-data-for-groups-with-ggplot2) propose une seconde solution combinant les facets et l'argument fill. Il faut ensuite ajouter par derriere un histogramme ne tenant pas compte de la variable facteur comme proposé ci-dessous.

```{r, fig.cap= "Histogramme de la longeur des sépales de 3 espèces d'iris en employant la solution de Simon Jackson."}
chart(iris, formula = ~ sepal_width %fill=% species | species) +
  geom_histogram(data = iris[ , -c(5)] , fill = "grey") + # histogramme ne tenant pas compte de la variable species
  geom_histogram(show.legend = FALSE) + # show.legend = FALSE permet de cacher la légende, si cette denrière n'est pas informative.
  scale_fill_viridis_d()
```

###  A vous de jouer !

Une nouvelle tâche va vous être demandée ci-dessous en utilisant GitHub Classroom \@ref(classroom). Cette tâche est un travail **en équipe**. Une fois votre assignation réalisée, faite un clone de votre dépôt et placer le dans le dossier `project`.

Cette nouvelle tâche qui vous est demandée vous propose d'employer un projet RStudio \@ref(rs_projet)

```{block2, type='bdd'}
Un projet sur la croissance des dents de cochon d'Inde est mis à votre disposition. Sur base du jeux de données `ToothGrowth`, explorez différents graphiques. 

Utilisez l'URL suivant qui va vous donner accès à votre tâche.

- <TODO>

```

## Graphique de densité

L'histogramme n'est pas le seul outil à votre disposition. Vous pouvez également employer le graphique de densité qui se base sur l'histogramme. Il ne s'agit plus de représenter un dénombrement comme l'histogramme le fait mais une **probabilité**^[TODO] d'obtenir une valeur parmi un échantillon aléatoire. Le passage d'un histogramme vers un graphe de densité se base sur une **estimation par noyaux gaussien**^[TODO]

```{r, fig.cap= "A. Histogramme  et B. graphique de densité montrant la distribution de la taille d'un échantillon de zooplancton analysé par analyse d'image.", echo=FALSE, message=FALSE}
a <- chart(zooplankton, formula = ~ size) +
  geom_histogram() +
  labs( y = "Dénombrement") +
  theme(axis.text.x = element_text(colour = "#a80039", size = 15), 
        axis.title.x = element_text(colour = "#029687", size = 15), 
        axis.text.y = element_text(colour = "#a80039", size  = 15), 
        axis.title.y = element_text(colour = "#029687", size = 15),
        axis.line.x = element_line(colour = "#a80039"),
        axis.line.y = element_line(colour = "#a80039"))

  b <- chart(zooplankton, formula = ~ size) +
  geom_density() +
  labs( y = "Densité") +
  theme(axis.text.x = element_text(colour = "#a80039", size = 15), 
        axis.title.x = element_text(colour = "#029687", size = 15), 
        axis.text.y = element_text(colour = "#a80039", size  = 15), 
        axis.title.y = element_text(colour = "#029687", size = 15),
        axis.line.x = element_line(colour = "#a80039"),
        axis.line.y = element_line(colour = "#a80039"))

ggpubr::ggarrange(a,b, labels = "AUTO")
rm(a,b)
```

Les éléments indispensables à la compréhension d'un graphique de densité sont (ici mis en évidence en couleur) : 

- Les axes avec les graduations (en rouge)
- les labels et unité des axes (en bleu)

Les instructions de base afin de produire un histogramme sont :

```{r, fig.cap="Instructions pour obtenir un graphique de densité."}
# Importation du jeu de données
(zooplankton <- read( file = "zooplankton", package = "data.io", lang = "fr"))
# Réalisation du graphique
chart(zooplankton, formula = ~ size) +
  geom_density()
```

La fonction `chart()` requiert comme argument le jeu de donnée ( dataframe, zp), ainsi que la formule à employer  ~ VAR (size). Pour réaliser un graphique de densité vous devez ajouter la seconde fonction `geom_density()`.


## Diagramme en violon

Le graphique de densité peut être représenté via un autre graphique qui sera d'autant plus intéressant que la variable facteur étudiée peut être discriminée par un grand nombre de niveaux différents. Il s'agit également d'une estimation se basant sur un histogramme via la méthode l'estimation par noyau gaussien.

```{r, fig.cap= "Ponts essentiels d'un diagramme en violon portant sur la distribution de la taille d'un échantillon de zooplancton en fonction de leurs classes analysé par analyse d'image.", echo = FALSE, message= FALSE, warning= FALSE }

chart(filter(zooplankton, class %in% c("Annelid", "Calanoid", "Cyclopoid", "Decapod")), formula = size ~ class %fill=% class) +
  geom_violin(show.legend = FALSE)  +
  theme(axis.text.x = element_text(colour = "#a80039", size = 15), 
        axis.title.x = element_text(colour = "#029687", size = 15), 
        axis.text.y = element_text(colour = "#a80039", size  = 15), 
        axis.title.y = element_text(colour = "#029687", size = 15),
        axis.line.x = element_line(colour = "#a80039"),
        axis.line.y = element_line(colour = "#a80039"))
```

Les instructions de base afin de produire un diagramme en violon sont :

```{r, fig.cap="Instructions pour obtenir un diagramme en violon."}
# Importation du jeu de données
zooplankton <- read( file = "zooplankton", package = "data.io", lang = "fr")
# Réduction du jeu de données 
zooplankton_sub <- filter(zooplankton, class %in% c("Annelid", "Calanoid", "Cyclopoid", "Decapod"))
# Réalisation du graphique
chart(zooplankton_sub, formula = size~ class) +
  geom_violin()
```

La fonction `chart()` requiert comme argument le jeu de donnée (dataframe, zp), ainsi que la formule à employer  YVAR (size) ~ XVAR (class). Pour réaliser un graphique de densité vous devez ajouter la seconde fonction `geom_density()`.


### Pièges et astuces

Lors de l'analyse de jeux de données , vous serez amené a réalisé un diagramme en violon pour une variable comprennant un grand nombre de niveaux. Cette opération peut avoir un rendu graphique plutôt décevant dont voici deux astuces pour l'éviter.


```{r, fig.cap="Diagramme en violon montrant la densité de tailles des 17 classes d'organismes planctonique."}
chart(zooplankton, formula = size~ class) +
  geom_violin() 
```

L'ensemble des niveaux de la variable class se chevauche. La fonction `coord_flip()` peut améliorer le rendu du graphique en le faisant basculer de 90°.

```{r, fig.cap="Diagramme en violon montrant la densité de tailles des 17 classes d'organismes planctonique avec l'ajout de la fonction coord_flip."}
chart(zooplankton, formula = size~ class) +
  geom_violin() +
  coord_flip()
```

Le package [ggridges](https://cran.r-project.org/web/packages/ggridges/vignettes/introduction.html) propose une seconde solution basée sur le principe de graphique de densité avec la fonction geom_density_ridges()`. 

```{r, fig.cap="Diagramme en violon montrant la densité de tailles des 17 classes d'organismes planctonique avec la fonction geom_density_ridges.", message=FALSE}
# Importation du packages
library(ggridges)
# réalisation du graphiques
chart(zooplankton, class ~ size) +
  geom_density_ridges()
```

## A vous de jouer !

```{block2, type='bdd'}
Ouvrez RStudio dans votre SciViews Box, puis exécutez l'instruction suivante dans la fenêtre console :

    BioDataScience::run("...")

```

Un squelette de projet RStudio vous a été fournit via une tâche Github Classroom, y compris une organisation des fichiers et des jeux de données types. Votre objectif est de comprendre les données proposées en utilisant des visualisations graphiques appropriées et en documentant le fruit de votre étude dans un rapport R Notebook. Utilisez l'histogramme et le graphique de densité que vous venez d'étudier bien sûr, mais vous êtes aussi encouragés à expérimenter d'autres visualisations graphiques.

