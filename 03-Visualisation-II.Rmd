# Visualisation II {#visu2}

```{r setup, include=FALSE, echo=FALSE, message=FALSE, results='hide'}
knitr::opts_chunk$set(comment = '#', fig.align = "center")
SciViews::R
library(viridis)
iris <- read(file = "iris", package = "datasets", lang = "fr")
zooplankton <- read( file = "zooplankton", package = "data.io", lang = "fr")
toothgrowth <- read(file = "ToothGrowth", package = "datasets", lang = "fr")
```


#### Objectifs {-}

- Savoir réaliser différentes variantes de graphiques tel que les histogrammes, les graphes de densité ou encore les diagrammes en violon dans R avec la fonction `chart()`

- Intégrer ensuite des graphiques dans un rapport et y décrire ce que que vous observez

- Gérer des conflits dans GitHub


####  A vous de jouer ! {-}

Une nouvelle tâche va vous être demandée ci-dessous en utilisant GitHub Classroom \@ref(classroom). Cette tâche est un travail **en équipe**. Une fois votre assignation réalisée, faite un clone de votre dépôt et placer le dans le dossier `projects`. Pour cette tâche, vous démarrerez d'un projet RStudio \@ref(rs_projet)

```{block2, type='bdd'}
Un projet sur le zooplancton provenant de Madagascar est mis à votre dispositon. 
Utilisez l'URL suivant qui va vous donner accès à votre tâche. Cette tâche est un travail individuel. **Cette tache est un travail en binome**

- <TODO>

```

Employez le projet sur la biométrie des oursins et sur le zooplancton pour découvrir les nouveaux outils graphiques décrits dans ce module. 

#### Prérequis {-}

Si ce n'est déjà fait, vous devez avoir réaliser les modules précédents.


## Histogramme

Lors d'une expérience vous souhaitez visualiser la façon dont vos données s'étalent sur un axe (on parle de **distribution**^[TODO] en statistique) pour l'une des variables étudiées. L'histogramme est l'un des outils pouvant vous apporter cette information. Ce graphique va découper en plusieurs **classes**^[TODO] une variable numérique.

```{r, fig.cap= "Histogramme montrant la distribution de la taille d'un échantillon de zooplancton étudié par analyse d'image.", echo=FALSE, message=FALSE, warning=FALSE}
chart(zooplankton, formula = ~ size) +
  geom_histogram(bins = 50) +
  ylab("Nombre d'occurence") +
  theme(axis.text.x = element_text(colour = "#a80039", size = 15), 
        axis.title.x = element_text(colour = "#029687", size = 15), 
        axis.text.y = element_text(colour = "#a80039", size  = 15), 
        axis.title.y = element_text(colour = "#029687", size = 15),
        axis.line.x = element_line(colour = "#a80039"),
        axis.line.y = element_line(colour = "#a80039"))
```

Les éléments indispensables à la compréhension d'un histogramme sont (ici mis en évidence en couleur)

- Les axes avec les graduations (en rouge)
- les labels et unité des axes (en bleu)

Les instructions de base afin de produire un histogramme :

```{r, fig.cap="Instructions pour obtenir un histogramme."}
# Importation du jeu de données
(zooplankton <- read( file = "zooplankton", package = "data.io", lang = "fr"))
# Réalisation du graphique
chart(zooplankton, formula = ~ size) +
  geom_histogram(bins = 50) 
# bins permet de préciser le nombre de classes souhaitées
```

La fonction `chart()` requiert comme argument le jeu de donnée (`zooplankton`, c'est un objet `dataframe` ou `tibble` dans le langage de R), ainsi que la formule à employer dans laquelle vous avez indiqué le nom de la variable que vous voulez sur l'axe des abscisses à droite de la formule. Vous voyez que le jeu de données contient beaucoup de variables (les titres des colonnes du tableau en sortie). Parmi toutes ces variables, nous avons choisi ici de représenter `size`, Jusqu'ici, nous avons spécifié _ce que_ nous voulons représenter, mais pas encore _comment_ (sous quelle apparence), nous voulons matérialiser cela sur le graphique. Pour un histogramme, nous devons ajouter la fonction `geom_histogram()`. L'argument `bins` dans cette fonction permet de préciser le nombre de classes souhaitées.

Vous pouvez décrypter votre histogramme sur base des **modes**^[TODO] et de la **symétrie**^[TODO] de ces derniers. Les modes les plus fréquents sont unimodal, bimodal ou multimodal. 

```{r, fig.cap = "Histogrammes montrant les modes et symétries : A. histogramme unimodal et symétrique, B. histogramme bimodal et asymétrique, C. histogramme unimodal et asymétrique, D. histogramme multimodal et symétrique.", echo=FALSE, message=FALSE, warning=FALSE}
set.seed(1000)
c <- rnorm(5000, 35, 5)
c1 <- as.data.frame(c)
g1 <- chart(c1, formula = ~ c) +
  geom_histogram() +
  labs( x = "Unimodal & symétrique", 
        y = "Nbre d'occurence") +
  theme(axis.text.x = element_text(colour = "#a80039", size = 15), 
        axis.title.x = element_text(colour = "#029687", size = 15), 
        axis.text.y = element_text(colour = "#a80039", size  = 5), 
        axis.title.y = element_text(colour = "#029687", size = 15),
        axis.line.x = element_line(colour = "#a80039"),
        axis.line.y = element_line(colour = "#a80039"))

d <- rnorm(7000, 60, 5)
e <- c(c, d)
g <- e
d1 <- as.data.frame(e)

g2 <- chart(d1, formula = ~ e) +
  geom_histogram() +
  labs( x = "Bimodal & symétrique", 
        y = "Nbre d'occurence") +
  theme(axis.text.x = element_text(colour = "#a80039", size = 15), 
        axis.title.x = element_text(colour = "#029687", size = 15), 
        axis.text.y = element_text(colour = "#a80039", size  = 5), 
        axis.title.y = element_text(colour = "#029687", size = 15),
        axis.line.x = element_line(colour = "#a80039"),
        axis.line.y = element_line(colour = "#a80039"))

e <- c1[c1$c > 34, ]
e1 <- as.data.frame(e)
g3 <- chart(data = e1, formula = ~ e) +
  geom_histogram() +
  labs( x = "Unimodal & asymétrique", 
        y = "Nbre d'occurence") +
  theme(axis.text.x = element_text(colour = "#a80039", size = 15), 
        axis.title.x = element_text(colour = "#029687", size = 15), 
        axis.text.y = element_text(colour = "#a80039", size  = 5), 
        axis.title.y = element_text(colour = "#029687", size = 15),
        axis.line.x = element_line(colour = "#a80039"),
        axis.line.y = element_line(colour = "#a80039"))

f <- rnorm(3000, 80, 5)
c <- c(g, f)
c1 <- as.data.frame(c)

g4 <- chart(c1, formula = ~ c) +
  geom_histogram() +
  labs( x = "Multimodal & symétrique", 
        y = "Nbre d'occurence") +
  theme(axis.text.x = element_text(colour = "#a80039", size = 15), 
        axis.title.x = element_text(colour = "#029687", size = 15), 
        axis.text.y = element_text(colour = "#a80039", size  = 5), 
        axis.title.y = element_text(colour = "#029687", size = 15),
        axis.line.x = element_line(colour = "#a80039"),
        axis.line.y = element_line(colour = "#a80039"))

ggarrange(g1, g2, g3, g4)
rm(g1, g2, g3, g4, c1, c, f, e1, e, d1, g, d)
```

### Pièges et astuces

#### Nombres de classes d'un histogramme

Vous devez être particulièrement vigilant lors de la réalisation d'un histogramme aux classes de ce dernier. 

```{r, fig.cap = "Piège de l'histogramme. A. histogramme initial montrant la répartition des tailles au sein d'organismes planctoniques. B., C., D. Histogramme A en modifiant le nombres de classes."}

# Réalisation du graphique précédent
a <- chart(zooplankton, formula = ~ size) +
  geom_histogram(bins = 50) 

# Modification du nombre de classes
b <- chart(zooplankton, formula = ~ size) +
  geom_histogram(bins = 20)

c <- chart(zooplankton, formula = ~ size) +
  geom_histogram(bins = 10)

d <- chart(zooplankton, formula = ~ size) +
  geom_histogram(bins = 5) 

# Assemblage des graphiques
ggarrange(a, b, c, d, labels = "AUTO", font.label = list(size = 14, align = "hv"))
```

Comme vous pouvez le voir ci-dessus, le changement du nombre de classes peut modifier complètement la perception des données via l'histogramme.


#### Utilisation des snippets

RStudio permet de récupérer rapidement des instructions à partir d'une banque de solutions toutes prêtes. Cela s'appelle des **snippets**. Vous avez une série de snippets disponibles dans la SciViews Box. Celui qui vous permet de réaliser un histogramme s'appelle `.cuhist` (pour **c**hart -> **u**nivariate -> **hist**ogram). Entrez ce label dans une zone d'édition de code R et appuyez ensuite sur la tabulation, et vous verrez le code remplacé par ceci :

```
chart(data = DF, ~VARNUM) +
    geom_histogram(binwidth = 30)
```

L'argument `binwidth =` permet de préciser la largeur des classes.

Vous avez à votre disposition un ensemble de snippets que vous pouvez retrouver dans l'aide-mémoire sur [**SciViews**](https://github.com/BioDataScience-Course/cheatsheets/blob/master/keynote/sciviews_cheatsheet.pdf).

Vous avez également à votre disposition l'aide-mémoire sur la visualisation des données ([**Data Visualization Cheat Sheet**](https://www.rstudio.com/resources/cheatsheets/)).


#### Histogramme par facteur

Lors de l'analyse de jeux de données, vous serez amené à réaliser un histogramme par facteur (c'est-à-dire, en fonction de différents niveau d'une variable représentant des groupes).

```{r, fig.cap= "Histogramme de la longueur des sépales de 3 espèces d'iris."}
# Importation du jeu de données
(iris <- read(file = "iris", package = "datasets", lang = "fr"))

# Réalisation de l'histogramme par facteur
chart(iris, ~ sepal_length %fill=% species) +
  geom_histogram() +
  scale_fill_viridis_d() # palette de couleur harmonieuse
```

La fonction `chart()` requiert comme argument le jeu de donnée (`iris`, c'est un objet `dataframe` ou `tibble` dans le langage de R), ainsi que la formule à employer dans laquelle vous avez indiqué le nom de la variable que vous voulez sur l'axe des abscisses à droite de la formule. Parmi toutes ces variables, nous avons choisi ici de représenter `sepal_length`. L'intérieur des barres est colorée (`%fill=%`) pour différencier les 3 espèces de ce jeu de données sur base de la variable `species`. Jusqu'ici, nous avons spécifié _ce que_ nous voulons représenter, mais pas encore _comment_ (sous quelle apparence), nous voulons les matérialiser sur le graphique. Pour un histogramme, nous devons ajouter la fonction `geom_histogram()` pour indiquer cela. La fonction `scale_fill_viridis_d()` permet d'obtenir des couleurs harmonieuses.

Le rendu du graphique n'est pas optimal. Voici deux astuces pour l'améliorer. La premières astuces est d'employer préférentiellement les `facets` au lieu de l'argument `%fill=%` an utilisant l'opérateur `|` dans la formule.

```{r , fig.cap= "Histogramme de la longueur des sépales de 3 espèces d'iris en employant les facets pour séparer les espèces."}
chart(iris, ~ sepal_length | species) +
  geom_histogram()
```

L'histogramme est maintenant séparé en trois en fonction des niveaux de la variable facteur `species`.

[Simon Jackson](https://drsimonj.svbtle.com/plotting-background-data-for-groups-with-ggplot2) propose une seconde solution combinant les facets et l'argument `fill =`. Il faut ensuite ajouter par derriere un histogramme grisé ne tenant pas compte de la variable facteur.

```{r, fig.cap= "Histogramme de la longeur des sépales de 3 espèces d'iris en employant la solution de Simon Jackson."}
chart(iris, formula = ~ sepal_width %fill=% species | species) +
  geom_histogram(data = iris[ , -c(5)] , fill = "grey") + # histogramme ne tenant pas compte de la variable species
  geom_histogram(show.legend = FALSE) + # show.legend = FALSE permet de cacher la légende, si cette denrière n'est pas informative.
  scale_fill_viridis_d()
```

## Graphique de densité

L'histogramme n'est pas le seul outil à votre disposition. Vous pouvez également employer le graphique de densité qui se présente un peu comme un histogramme lissé. Le passage d'un histogramme vers un graphe de densité se base sur une **estimation par noyaux gaussien**^[TODO]

```{r, fig.cap= "A. Histogramme et B. graphique de densité montrant la distribution de la taille d'un échantillon de zooplancton étudié par analyse d'image.", echo=FALSE, message=FALSE}
a <- chart(zooplankton, formula = ~ size) +
  geom_histogram() +
  labs( y = "Dénombrement") +
  theme(axis.text.x = element_text(colour = "#a80039", size = 15), 
        axis.title.x = element_text(colour = "#029687", size = 15), 
        axis.text.y = element_text(colour = "#a80039", size  = 15), 
        axis.title.y = element_text(colour = "#029687", size = 15),
        axis.line.x = element_line(colour = "#a80039"),
        axis.line.y = element_line(colour = "#a80039"))

b <- chart(zooplankton, formula = ~ size) +
  geom_density() +
  labs( y = "Densité") +
  theme(axis.text.x = element_text(colour = "#a80039", size = 15), 
        axis.title.x = element_text(colour = "#029687", size = 15), 
        axis.text.y = element_text(colour = "#a80039", size  = 15), 
        axis.title.y = element_text(colour = "#029687", size = 15),
        axis.line.x = element_line(colour = "#a80039"),
        axis.line.y = element_line(colour = "#a80039"))

ggarrange(a, b, labels = "AUTO")
rm(a, b)
```

Les éléments indispensables à la compréhension d'un graphique de densité sont (ici mis en évidence en couleur) : 

- Les axes avec les graduations (en rouge)
- les labels et unité des axes (en bleu)

Les instructions de base afin de produire un graphique de densité sont :

```{r, fig.cap="Instructions pour obtenir un graphique de densité."}
# Importation du jeu de données
(zooplankton <- read( file = "zooplankton", package = "data.io", lang = "fr"))

# Réalisation du graphique
chart(zooplankton, formula = ~ size) +
  geom_density()
```

La fonction `chart()` requiert comme argument le jeu de donnée ( dataframe, `zooplankton`), ainsi que la formule à employer (`~ size`). Pour réaliser un graphique de densité vous devez ensuite ajouter la fonction `geom_density()`.


## Diagramme en violon

Le graphique en violon est constitué de deux graphiques de densité en miroir. LE résultat fait penser à un violon pour une distribution bimodale. Cette représentation est visuellement très convainquante lorsque la variable étudiée contient suffisamment d'onservations pour permettre de déterminer précisément sa distribution (plusieurs dizaines ou centaines d'observations).

```{r, fig.cap="Graphe en violon de la distribution de la taille d'un échantillon de zooplancton étudié par analyse d'image.", echo=FALSE, message=FALSE, warning=FALSE}

zooplankton %>.%
  filter(., class %in% c("Annelid", "Calanoid", "Cyclopoid", "Decapod")) %>.%
chart(., formula = size ~ class %fill=% class) +
  geom_violin(show.legend = FALSE)  +
  theme(axis.text.x = element_text(colour = "#a80039", size = 15), 
        axis.title.x = element_text(colour = "#029687", size = 15), 
        axis.text.y = element_text(colour = "#a80039", size  = 15), 
        axis.title.y = element_text(colour = "#029687", size = 15),
        axis.line.x = element_line(colour = "#a80039"),
        axis.line.y = element_line(colour = "#a80039"))
```

Les instructions pour produire un diagramme en violon sont :

```{r, fig.cap="Instructions pour obtenir un diagramme en violon."}
# Importation du jeu de données
zooplankton <- read( file = "zooplankton", package = "data.io", lang = "fr")

# Réduction du jeu de données 
zooplankton_sub <- filter(zooplankton, class %in% c("Annelid", "Calanoid", "Cyclopoid", "Decapod"))
# Réalisation du graphique
chart(zooplankton_sub, formula = size ~ class) +
  geom_violin()
```

La fonction `chart()` requiert comme argument le jeu de donnée (`dataframe`, `zooplankton`), ainsi que la formule à employer  `YVAR (size) ~ XVAR (class)`. Pour réaliser un graphique de densité vous devez ajouter la fonction `geom_density()`.


### Pièges et astuces

Parfois, un diagramme en violon apparait trop encombré, comme ci-dessous.

```{r, fig.cap="Diagramme en violon montrant la densité de tailles des 17 classes d'organismes planctonique."}
chart(zooplankton, formula = size~ class) +
  geom_violin() 
```

Les libellés des classes sur l'axe X se chevauchent. La fonction `coord_flip()` peut améliorer le rendu du graphique en le faisant basculer de 90°.

```{r, fig.cap="Diagramme en violon montrant la densité de tailles des 17 classes d'organismes planctonique avec l'ajout de la fonction `coord_flip()`."}
chart(zooplankton, formula = size~ class) +
  geom_violin() +
  coord_flip()
```

Le package [ggridges](https://cran.r-project.org/web/packages/ggridges/vignettes/introduction.html) propose une seconde solution basée sur le principe de graphique de densité avec la fonction `geom_density_ridges()`. 

```{r, fig.cap="Diagramme en violon montrant la densité de tailles des 17 classes d'organismes planctonique avec la fonction geom_density_ridges.", message=FALSE}
# Importation du packages
library(ggridges)

# Réalisation du graphique
chart(zooplankton, class ~ size) +
  geom_density_ridges()
```


## A vous de jouer !

```{block2, type='bdd'}

Ouvrez RStudio dans votre SciViews Box, puis exécutez l'instruction suivante dans la fenêtre console :

    BioDataScience::run("...")

```

Un squelette de projet RStudio vous a été fournit via une tâche Github Classroom, y compris une organisation des fichiers et des jeux de données types. Votre objectif est de comprendre les données proposées en utilisant des visualisations graphiques appropriées et en documentant le fruit de votre étude dans un rapport R Notebook. Utilisez l'histogramme et le graphique de densité que vous venez d'étudier bien sûr, mais vous êtes aussi encouragés à expérimenter d'autres formes de visualisations graphiques.
