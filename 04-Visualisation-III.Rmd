# Visualisation III {#visu3}

```{r setup, include=FALSE, echo=FALSE, message=FALSE, results='hide'}
knitr::opts_chunk$set(comment = '#', fig.align = "center")
SciViews::R

e_m <- data_frame(id = 1:345, e_mathaei = c(rep("black", times = 236), rep("purple" , times = 40), rep("brown", times = 35), rep("green", times = 34)))
ToothGrowth <- read("ToothGrowth", package = "datasets", lang = "fr")
PlantGrowth <- read("PlantGrowth", package = "datasets", lang = "fr")
iris <- read("iris", package = "datasets", lang = "fr")
ChickWeight <- read("ChickWeight", package = "datasets", lang = "fr")
urchin <- read("urchin_bio", package = "data.io", lang = "fr")
diamonds <- read("diamonds", package = "ggplot2", lang = "fr")

```


#### Objectifs {-}

- Savoir réaliser différents graphiques pour représenter des variables facteurs comme le graphique en barres, ou le graphique en camembert dans R avec la fonction `chart()`

- Comprendre et utiliser la boîte de dispersion pour _synthétiser_ la distribution de données numériques 

- Arranger différents graphiques dans une figure unique

- Découvrir différents systèmes graphiques (graphiques de base, lattice, ggplot2) et les comparer entre eux


#### Prérequis {-}

Assurez-vous de bien maîtriser les notions relatives à la représentation graphiques vues jusqu'ici dans les modules \@ref(visu1) et \@ref(visu2).


## Graphique en barres

### Dénombrement d'observations par facteur

Le graphique en barres est très similaire à l'histogramme, si ce n'est que l'on ne part pas d'une variable numérique découpée en classes, mais d'une variable facteur dont les observations sont donc déjà réparties en un (petit) nombre de classes distinctes. La question du nombre et/ou de l'intervalle des classes ne se pose donc plus ici. Par défaut, les barres seront séparées les unes des autres par un petit espace vide pour bien indiquer visuellement qu'il n'y a pas continuité entre les classes (dans l'histogramme, les barres sont accolées les unes aux autres pour matérialiser justement cette continuité).

La formule que vous utiliserez, ici encore, ne fait appel qu'à une seule variable et s'écrira donc :

$$\sim variable \ facteur$$

```{r , fig.cap= "Exemple d'un graphique en barre montrant le dénombrement des niveaux d'une variable facteur, avec les éléments importants du graphique mis en évidence en couleurs.", echo = FALSE, message= FALSE}
zooplankton <- read("zooplankton", package = "data.io", lang = "fr")
copepoda <- filter(zooplankton, class %in% c("Calanoid", "Cyclopoid",  "Harpacticoid", "Poecilostomatoid"))
chart(data = copepoda, ~ class) +
  geom_bar() +
  labs(x = "Label de l'axe x  + [Unité]", 
       y = "Dénombrement") +
  theme(axis.text.x = element_text(colour = "#a80039", size = 15), 
        axis.title.x = element_text(colour = "#029687", size = 15), 
        axis.text.y = element_text(colour = "#a80039", size = 15), 
        axis.title.y = element_text(colour = "#029687", size = 15),
        axis.line.x = element_line(colour = "#a80039"),
        axis.line.y = element_line(colour = "#a80039"))
```

Outre les barres elles-mêmes, prêtez toujours attention aux élements suivants du graphique (ici mis en évidence en couleurs) :

- les axes avec les graduations (en rouge)
- les niveaux de la variable facteur (en rouge également)
- le label des axes (en bleu)

Les instructions dans R pour produire un graphique en barres à l'aide de la fonction `chart()` sont :

```{r, fig.cap="Instructions pour obtenir un graphique en barres."}
# Importation du jeu de données
(zooplankton <- read("zooplankton", package = "data.io", lang = "fr"))
# Réduction du jeu de données 
(copepoda <- filter(zooplankton,
  class %in% c("Calanoid", "Cyclopoid",  "Harpacticoid",  "Poecilostomatoid")))
# Réalisation du graphique
chart(data = copepoda, ~ class) +
  geom_bar()
```

La fonction `geom_bar()` se charge d'ajouter les barres verticales dans le graphique. La hauteur de ces barres correspond au nombre d'observations rencontrées dans le jeu de données pour chaque niveau (ou classe, ou groupe) de la variable facteur représentée.


#### Dénombrement par plusieurs facteurs

```{r}
# Importation des données biometry
(biometry <- read("biometry", package = "BioDataScience", lang = "fr"))
# Conversion de la variable year_measure de numérique à facteur
biometry$year_measure <- as.factor(biometry$year_measure)
label(biometry$year_measure) <- "Année de la mesure"
```

Différentes représentations sont possibles pour observer des dénombrements tenant compte de plusieurs variables facteurs. Par défaut, l'argument `position =` a pour valeur par défaut `stack` (donc, lorsque cet argument n'est pas précisé dans `geom_bar()`).

```{r, fig.cap="Dénombrement des hommes et des femmes dans l'étude sur l'obésité en Hainaut en tenant compte des années de mesure.", echo=TRUE}
a <- chart(data = biometry, ~ gender) +
  geom_bar()

b <- chart(data = biometry, ~ gender %fill=% year_measure) +
  geom_bar() +
  scale_fill_viridis_d()

combine_charts(list(a, b), common.legend = TRUE)
```

Il existe d'autres options en utilisant la valeur `dodge` ou `fill` pour l'argument `position =`.

```{r, fig.cap= "Dénombrement des hommes et des femmes dans l'étude sur l'obésité en Hainaut en tenant compte des années de mesure.", echo = TRUE}
a <- chart(data = biometry, ~ gender %fill=% year_measure) +
  geom_bar(position = "stack") +
  scale_fill_viridis_d()
b <- chart(data = biometry, ~ gender %fill=% year_measure) +
  geom_bar(position = "dodge") +
  scale_fill_viridis_d()
c <- chart(data = biometry, ~ gender %fill=% year_measure) +
  geom_bar(position = "fill") +
  scale_fill_viridis_d()
combine_charts(list(a, b, c), common.legend = TRUE)
```

Soyez vigilant à la différence entre l'argument `position = stack` et `position = fill` qui malgré un rendu semblable ont l'axe des ordonnées qui diffère (dans le cas de `fill`, il s'agit de la proportion par rapport au total qui est représentée).


#### Pièges et Astuces

##### Réordonner la variable facteur par fréquence

Vous pouvez avoir le souhait d'ordonner votre variable facteur afin d'améliorer le rendu visuel de votre graphique. Pour cela, vous pouvez employer la fonction `fct_infreq()`. 

```{r, fig.cap="Dénombrement des classes de copépodes du jeu de données zooplankton."}
chart(data = copepoda, ~ fct_infreq(class)) +
  geom_bar()
```

##### Rotation du graphique en barre

Lorsque les niveaux dans la variable étudiée sont trop nombreux, la légende en abscisse risque de se chevaucher, comme dans la Fig. \@ref(fig:barchart1)

```{r barchart1, fig.cap="Dénombrement des classes du jeu de données zooplankton."}
chart(data = zooplankton, ~ class) +
  geom_bar()
```

Avec la fonction `coord_flip()` ajoutée à votre graphique, vous pouvez effectuer une rotation des axes pour obtenir un **graphique en barres horizontales**. De plus, l'oeil humain perçoit plus distinctement les différences de longueurs horizontales que verticales. Donc, de ce point de vue, le graphe en barres horizontal est considéré comme meilleur que le graphe en barres verticales. 

```{r, fig.cap="Dénombrement des classes du jeu de données zooplankton."}
chart(data = zooplankton, ~ class) +
  geom_bar() +
  coord_flip()
```


#### Pour en savoir plus 

- [Graphes en barres à l'aide de ggplot2](http://www.sthda.com/french/wiki/ggplot2-barplots-guide-de-demarrage-rapide-logiciel-r-et-visualisation-de-donnees). Un tutoriel en français utilisant la fonction `ggplot()`. L'annotation des barres est également présentée.

- [Page d'aide de la fonction `geom_bar()`](http://ggplot2.tidyverse.org/reference/geom_bar.html) en anglais.

- [Autres exemples de graphes en barres](http://ggplot.yhathq.com/docs/geom_bar.html) à l'aide de ``ggplot()`.


### Valeurs moyennes à l'aide d'un graphe en barres

Le graphique en barres peut être employé pour résumer des données numériques via la moyenne. Il ne s'agit plus de dénombrer les occurrences d'une variable facteur mais de résumer des données numériques en fonction d'une variable facteur. On peut exprimer cette relation dans R sous la forme de

$$y \sim x$$

que l'on peut lire :

$$y \ en \ fonction \ de \ x$$

Avec _y_ une variable numérique et _x_ une variable facteur. Considérez l'échantillon suivant :

```
1, 71, 55, 68, 78, 60, 83, 120, 82 ,53, 26
```

Calculez la moyenne sur base de la formule de la moyenne

$$\overline{y} = \sum_{i = 1}^n \frac{y_i}{n}$$


```{r}
# Création du vecteur
x <- c(1, 71, 55, 68, 78, 60, 83, 120, 82, 53, 26)
# Calcul  de la moyenne
mean(x)
```

Les instructions pour produire ce graphe en barres à l'aide de `chart()` sont :

```{r, fig.cap="Graphique en barres représentant les moyennes par groupe."}
# Réalisation du graphique
chart(data = copepoda, size ~ class) +
  stat_summary(geom = "col", fun.y = "mean")
```

Ici, nous faisons appel à une autre famille de fonctions : celles qui effectuent des calculs sur les données avant de les représenter graphiquement.

```{block2, type='warning'}
Le graphe en barres pour représenter les moyennes est très répandu dans le domaine scientifique malgré le grand nombre d'arguments en sa défaveur et que vous pouvez lire dans la section **pour en savoir plus** ci-dessous. L'un des arguments le plus important est la faible information qu'il véhicule puisque l'ensemble des données n'est plus représentée que par une valeur (la moyenne) pour chaque niveau de la variable facteur. Pour un petit nombre d'observations, il vaut mieux toutes les représenter à l'aide d'un nuage de points. Si le nombre d'observation devient très grand (dizianes ou plus), le graphique en boites de dispersion est plus indiqué (voir plus loin dans ce module).
```


#### Pour en savoir plus 

- [Beware of dynamite](http://biostat.mc.vanderbilt.edu/wiki/pub/Main/TatsukiRcode/Poster3.pdf). Démonstration de l'impact d'un graphe en barres pour représenter la moyenne (et l'écart type) = graphique en "dynamite".

- [Dynamite plots : unmitigated evil?](http://emdbolker.wikidot.com/blog%3Adynamite) Une autre comparaison du graphe en dynamite avec des représentations alternatives qui montre que le premier peut avoir quand même quelques avantages dans des situations particulières.


## Graphique en camembert

Le graphique en camembert va vous permettre de visualiser un dénombrement d'observations par facteur, tout comme le graphique en barres. 

```{r, fig.cap="Exemple de graphique en camembert montrant le dénombrement des niveaux d'une variable facteur."}
chart(data = copepoda, ~ factor(0) %fill=% class) +
  geom_bar(width = 1) + 
  coord_polar("y", start = 0) +
  theme_void() +
  scale_fill_viridis_d()
```

Ce graphique est plus difficile à réaliser à l'aide de `chart()` ou `ggplot()`. En fait, il faut ruser ici, et l'auteur du package **ggplot2** n'avait tout simplement pas l'intention d'ajouter ce type de graphique dans la panoplie proposée. En effet, il faut savoir que l'oeil humain est nettement moins bon pour repérer des angles que pour comparer des longueurs. **Donc, le diagramme en barres est souvent meilleur pour comparer des dénombrements par classes.** Mais d'une part, le graphique en camembert est (malheureusement) un graphique très répandu et il faut savoir l'interpréter, et d'autre part, il peut s'avérer quand même utile dans certaines situations. Notez l'utilisation de la fonction `theme_void()` qui crée un graphique sans axes.


### Pièges et astuces

Partons d'un exemple fictif pour vous convaincre qu'un graphique en barres est souvent plus lisible qu'un graphique en camembert. Combien d'observations comptez-vous pour la lettre **h** ? 

```{r, echo=FALSE}
error <- data_frame(
  index = 1:347,
  fact  = as.factor(c(rep("a", times = 10), 
            rep("b", times = 1),
            rep("c", times = 1),
            rep("d", times = 50),
            rep("e", times = 2),
            rep("f", times = 78),
            rep("g", times = 101),
            rep("h", times = 24) ,
            rep("i", times = 31),
            rep("j", times = 49)
          ))
  )
```


```{r, echo=FALSE, fig.cap="Arrivez-vous à lire facilement des valeurs sur un graphique en camenbert (une échelle y est ajoutée de manière exceptionnelle pour vous y aider)."}
chart(data = error, ~ factor(0) %fill=% fact) +
  geom_bar(width = 1) + 
  coord_polar("y", start = 0) +
  labs( x = "", y = "") +
  scale_fill_viridis_d()
```

Maintenant, effectuez le même exercice sur base d'un graphique en barres, combien d'observations pour la lettre **h** ?

```{r, echo=FALSE, fig.cap="Dénombrement des niveaux d'une variable facteur sur un graphique en barres."}
chart(data = error, ~ fact %fill=% fact) +
  geom_bar(width = 1) +
  scale_fill_viridis_d()
```

Dans ce dernier cas, c'est bien plus facile : il y a effectivement 24 observations relatives à la lettre **h**.


### Pour en savoir plus 


- [Graphique en camembert à l'aide de la fonction `ggplot()`](http://www.sthda.com/french/wiki/ggplot2-graphique-en-camembert-guide-de-demarrage-rapide-logiciel-r-et-visualisation-de-donnees). Explications en français des différentes étapes pour passer d'un graphique en barres à un graphique en camembert avec **ggplot2**.

- [Autre explication](https://dataparkblog.wordpress.com/2017/09/24/diagramme-en-camembert-avec-r-et-ggplot/) en français, également accompagnée d'informations sur les bonnes pratiques en matière de graphique en camembert.

- [Save the pies for dessert](http://www.perceptualedge.com/articles/08-21-07.pdf) est une démonstration détaillée des méfaits du graphique en camembert (le graphique en camembert, un graphique puant ? Pourrait-on peut-être titrer en français).

- [Les côtés positifs du graphe en camembert](https://www.displayr.com/why-pie-charts-are-better-than-bar-charts/) sont mis en évidence dans ce document (en anglais).


## Boite de dispersion

Vous souhaitez représenter graphiquement cette fois un résumé d'une variable numérique tout en gardant un maximum d'information. La boite de dispersion est l'un des outils pouvant vous apporter la solution. Cette dernière va représenter graphiquement 5 descripteurs appelés les 5 nombres.

Prenez les chiffres suivants :

```
1, 71, 55, 68, 78, 60, 83, 120, 82 ,53, 26
```
ordonnez les de manière croissante

```{r}
# création du vecteur
x <- c(1, 71, 55, 68, 78, 60, 83, 120, 82, 53, 26)
# ordonner le vecteur
sort(x)
```

Le premier descripteur des 5 nombres est la médiane qui se situe à la moitié des observations.

```{r}
median(x)
```

Le premier quartile sera la valeur au milieu des 50% des données inférieures à la médiane et le troisième quartile est la valeur centrale sur les 50% des données supérieures à la médiane. La valeur manimale étant la valeur la plus petite et la valeur maximale étant la valeur la plus élevée.

```{r}
fivenum(x)
```

Vous pouvez réprésenter ce vecteur via une boite de dispersion

```{r, fig.cap= "Nuage de points montrant la première étape de la construction d'une boite de dispersion.", echo = FALSE}
x <- as.data.frame(x)
chart(x , formula = x ~ 0)+
  geom_point() +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), axis.text.x.top = element_blank()) +
  labs( x = "", y ="")
```

La boite de dispersion représente donc les 5 nombres. Vous observez cependant que certaine valeur ne se situe pas dans la boite de dispersion, il s'agit de valeurs extrêmes. Elles sont considérées comme extrêmes car elles sont éloignées de plus 1.5 fois l'espace inter-quartile (Q3- Q1). La boite de dispersion s'arrête donc aux dernières valeurs présente dans cet espace inter-quartile (IQR).

```{r , fig.cap= "A) Nuage de points montrant la construction d'une boite de dispersion avec les 5 nombres représentés par des lignes noires. B) Boite de dispersion obtenue par rapport à la partie A.", echo = FALSE}

a <- chart(x , formula = x ~ 0)+
  geom_point() +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), axis.text.x.top = element_blank()) +
  labs( x = "", y ="") + 
  geom_hline(yintercept = median(x$x), size = 1.3) +
  geom_hline(yintercept = quantile(x$x)[2]) +
  geom_hline(yintercept = quantile(x$x)[4]) +
  geom_hline(yintercept = min(x$x)) +
  geom_hline(yintercept = max(x$x))

b <- chart(x , formula = x ~ 0)+
  geom_boxplot(outlier.colour = "#a80039", fill = "#029687") +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), axis.text.x.top = element_blank()) +
  labs( x = "", y ="")

ggpubr::ggarrange(a,b, labels = "auto")
```

```{r, echo = FALSE, message = FALSE, warning = FALSE}
# https://www.r-bloggers.com/exploring-ggplot2-boxplots-defining-limits-and-adjusting-style/
ggplot_box_legend <- function(family = "serif"){
  
  # Create data to use in the boxplot legend:
  set.seed(100)
  
  sample_df <- data.frame(parameter = "test",
                          values = sample(500))
  
  # Extend the top whisker a bit:
  sample_df$values[1:100] <- 701:800
  # Make sure there's only 1 lower outlier:
  sample_df$values[1] <- -350
  
  # Function to calculate important values:
  ggplot2_boxplot <- function(x){
    
    quartiles <- as.numeric(quantile(x, 
                                     probs = c(0.25, 0.5, 0.75)))
    
    names(quartiles) <- c("25ième percentile", 
                          "50ième percentile\n(médiane)",
                          "75ième percentile")
    
    IQR <- diff(quartiles[c(1,3)])
    
    upper_whisker <- max(x[x < (quartiles[3] + 1.5 * IQR)])
    lower_whisker <- min(x[x > (quartiles[1] - 1.5 * IQR)])
    
    upper_dots <- x[x > (quartiles[3] + 1.5*IQR)]
    lower_dots <- x[x < (quartiles[1] - 1.5*IQR)]
    
    return(list("quartiles" = quartiles,
                "25ième percentile" = as.numeric(quartiles[1]),
                "50ième percentile\n(médiane)" = as.numeric(quartiles[2]),
                "75ième percentile" = as.numeric(quartiles[3]),
                "IQR" = IQR,
                "upper_whisker" = upper_whisker,
                "lower_whisker" = lower_whisker,
                "upper_dots" = upper_dots,
                "lower_dots" = lower_dots))
  }
  
  # Get those values:
  ggplot_output <- ggplot2_boxplot(sample_df$values)
  
  # Lots of text in the legend, make it smaller and consistent font:
  update_geom_defaults("text", 
                       list(size = 3, 
                            hjust = 0,
                            family = family))
  # Labels don't inherit text:
  update_geom_defaults("label", 
                       list(size = 3, 
                            hjust = 0,
                            family = family))
  
  # Create the legend:
  # The main elements of the plot (the boxplot, error bars, and count)
  # are the easy part.
  # The text describing each of those takes a lot of fiddling to
  # get the location and style just right:
  explain_plot <- ggplot() +
    stat_boxplot(data = sample_df,
                 aes(x = parameter, y=values),
                 geom = 'errorbar', width = 0.3) +
    geom_boxplot(data = sample_df,
                 aes(x = parameter, y=values), 
                 width = 0.3, fill = "#029687") +
    theme_minimal(base_size = 5, base_family = family) +
    geom_segment(aes(x = 2.3, xend = 2.3, 
                     y = ggplot_output[["25ième percentile"]], 
                     yend = ggplot_output[["75ième percentile"]])) +
    geom_segment(aes(x = 1.2, xend = 2.3, 
                     y = ggplot_output[["25ième percentile"]], 
                     yend = ggplot_output[["25ième percentile"]])) +
    geom_segment(aes(x = 1.2, xend = 2.3, 
                     y = ggplot_output[["75ième percentile"]], 
                     yend = ggplot_output[["75ième percentile"]])) +
    geom_text(aes(x = 2.4, y = ggplot_output[["50ième percentile\n(médiane)"]]), 
              label = "Espace \n inter-quartile", fontface = "bold",
              vjust = 0.4) +
    geom_text(aes(x = c(1.17,1.17), 
                  y = c(ggplot_output[["upper_whisker"]],
                        ggplot_output[["lower_whisker"]]), 
                  label = c("Plus grande valeurs comprise dans 1.5 fois \n l'espace inter-quartile\n en dessus du 75ième percentile.",
                            "Plus petite valeurs comprise dans 1.5 fois \n l'espace inter-quartile\n en dessous du 25ième percentile.")),
              fontface = "bold", vjust = 0.9) +
    geom_text(aes(x = c(1.17), 
                  y =  ggplot_output[["lower_dots"]], 
                  label = "Valeurs extrêmes"), 
              vjust = 0.5, fontface = "bold") +
    geom_text(aes(x = c(1.95), 
                  y =  ggplot_output[["lower_dots"]], 
                  label = " valeur > 1.5 fois \n l'espace inter-quartile"), 
              vjust = 0.5) +
    geom_label(aes(x = 1.17, y = ggplot_output[["quartiles"]], 
                   label = names(ggplot_output[["quartiles"]])),
               vjust = c(0.4,0.85,0.4), 
               fill = "white", label.size = 0) +
    ylab("") + xlab("") +
    theme(axis.text = element_blank(),
          axis.ticks = element_blank(),
          panel.grid = element_blank(),
          aspect.ratio = 4/3,
          plot.title = element_text(hjust = 0.5, size = 10)) +
    coord_cartesian(xlim = c(1.4,3.1), ylim = c(-600, 900)) +
    labs(title = "Description")
  
  return(explain_plot) 
  
}
```

La boite de dispersion ainsi que sa description sont proposée sur le graphique ci-dessous.

```{r, fig.cap= "Points essentiels d'une boite de dispersion et sa description." , echo = FALSE}
a <- chart(x , formula = x ~ 0)+
    stat_boxplot(geom = 'errorbar', width = 0.3) +
  geom_boxplot( fill = "#029687", width = 0.3) +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), 
        axis.text.x.top = element_blank()) +
  labs( x = "Label de l'axe x [unité]", y = "Label de l'axe y [unité]")
b <- ggplot_box_legend()

ggarrange(a,b)
```

Les instructions de base afin de produire une boite de dispersion sont :

```{r, fig.cap="Instructions pour obtenir une boite de dispersion."}
# Réalisation du graphique 
chart(copepoda, formula = size ~ class) +
  geom_boxplot()
```


La fonction `chart()` requiert comme argument le jeu de données (dataframe, copepoda), ainsi que la formule à employer YNUM (size) ~ XFACTOR (class). Pour réaliser une boite de dispersion vous devez ajouter la seconde fonction `geom_boxplot()`.

### Pièges et Astuces

#### Nombre d'observations par boite de disperion

Lors de la réalisation de boites de dispersion, vous devez être vigilant au nombre d'observation qui se cache sous chaque boite de dispersion. En effet, une boite de dispersion ne comportant que 5 valeurs ou moins n'a que peu d'intérêt d'être avec cet outils graphique. 

```{r , fig.cap= "Piège des boites de dispersion.", echo= FALSE}
error <- data_frame(fac = c(rep(x = "a", times = 4), 
                            rep(x = "b", times = 11), 
                            rep(x = "c", times = 8)), 
                    value = c(55, 83, 120, 26,
                              1, 71, 55, 68, 78, 60, 83, 120, 82, 53, 26,
                              1, 71, 78, 60, 83, 120, 53, 26))

chart(error, formula = value ~ fac) +
  geom_boxplot() +
  geom_point(color = "red") 
```

La boite de dispersion "a" ne contient que 4 observations ce qui peut être totalement masqué par l'utilisation de boites de dispersion.

Une des solutions permettant de connaitre graphiquement la nombre d'observations par boite est de l'ajouter au-dessus de chaque boite avec la fonction `give_n()`.

```{r, fig.cap= " Boite de dispersion portant sur la croissance de dents de cochon d'Inde en fonction de la supplémentation administrée."}
give_n <- function(x){
  return(c(y = max(x)*1.20, label = length(x))) 
}

chart(copepoda, formula = size ~ class) +
  geom_boxplot() + 
  stat_summary(fun.data = give_n, geom = "text", hjust = 0.5)
```

```{r, fig.cap= " Boite de dispersion portant sur la croissance de dents de cochon d'Inde en fonction de la supplémentation et la dose administrée."}

#Importation du jeu de données ToothGrowth
(toothgrowth <- read("ToothGrowth", package = "datasets", lang  = "fr"))
# réalisation graphique
chart(toothgrowth, formula = len ~ supp %fill=% as.ordered(dose)) +
  geom_boxplot() +
  stat_summary(fun.data = give_n, geom = "text", hjust = 0.5, 
               position = position_dodge(0.75))
```

### Pour en savoir plus ! 

- http://www.sthda.com/french/wiki/ggplot2-box-plot-guide-de-demarrage-rapide-logiciel-r-et-visualisation-de-donnees

- https://plot.ly/ggplot2/box-plots/

- http://www.r-graph-gallery.com/265-grouped-boxplot-with-ggplot2/

- https://chemicalstatistician.wordpress.com/2013/08/12/exploratory-data-analysis-the-5-number-summary-two-different-methods-in-r-2/


## Multi-graphiques

Lorsque vous souhaitez représenter plusieurs graphiques sur une seule fenêtre graphique plusieurs fonctions sont à votre disposition. Il faut tout d'abord distinguer deux types de multi-graphiques. Soit il s'agit d'un seul graphique que vous souhaitez subdiviser par rapport à une ou des variables facteurs. Soit il s'agit de graphiques indépendants que vous souhaitez représenter sur la même fenêtre graphique. Dans le premier cas, la fonction `facet_grid()` du package `ggplot2` peut être employé. Dans le second cas, la fonction `plot_grid()` du package `cowplot` est l'une des alternatives possibles.

### Facets

L'une des règles les plus importantes que vous devez impérativement garder à l'esprit lors de la réalisation de vos graphiques est *la simplicité*. Plus votre graphique va contenir d'information au plus il sera compliqué à décoder par un collaborateur. 

```{r, fig.cap= "Nuage de point montrant la variation de la masse de poulets au cours du temps."}
# Importation des données
(ChickWeight <- read(file = "ChickWeight", package = "datasets", lang = "fr"))
# Réalisation du graphique
chart(ChickWeight, formula = weight ~ Time) +
  geom_point(alpha = 0.3)
```

Le graphique ci-dessus peut par exemple être simplifié avec les facets. L'information que l'on souhaite partager est la même mais les choix graphiques rendent sa lecture plus aisée. De plus, la fenêtre graphique a la même taille par défaut que pour un seul graphique. De ce fait, réaliser de multiples graphiques peut rendre sa lecture impossible par une taille trop faible.

```{r, fig.cap= "Nuage de point montrant la variation de la masse de poulets au cours du temps en fonction de la supplémention (1-4)."}
chart(ChickWeight, formula = weight ~ Time | Diet ) +
  geom_point(alpha = 0.3)
```

Vous observez que les échelles en abscisse et en ordonnée sont similaires. Cela permet une meilleure comparaison.

### `ggarrange()`

La fonction `ggarrange()` permet de combiner plusieurs graphiques.

```{r , fig.cap= "A) Nuage de point montrant la variation de la masse d'oursins en fonction de la taille  et de leur origine. B) Nuage de point montrant la variation de la masse d'oursins en fonction de la masse des parties solides et de leur origine."}
# Importation des données
ub <- read("urchin_bio", package = "data.io")
# Réalisation des graphiques
a <- chart(urchin, formula = weight ~ height %col=% origin) +
  geom_point()

b <- chart(urchin, formula = weight ~ solid_parts %col=% origin) +
  geom_point()
# Combinaison des graphiques
ggarrange(a, b, common.legend = TRUE)
```

Il existe d'autres fonctions permettant de combiner plusieurs graphiquescomme [`plot_grid()`](https://cran.r-project.org/web/packages/cowplot/vignettes/plot_grid.html) du package`cowplot`.

#### Pour en savoir plus ! 

- http://www.sthda.com/french/wiki/ggplot2-facet-diviser-un-graphique-en-plusieurs-panneaux-logiciel-r-et-visualisation-de-donnees

- http://www.cookbook-r.com/Graphs/Multiple_graphs_on_one_page_(ggplot2)/

- http://lightonphiri.org/blog/ggplot2-multiple-plots-in-one-graph-using-gridextra

- https://cran.r-project.org/web/packages/cowplot/vignettes/plot_grid.html

- http://www.sthda.com/english/rpkgs/ggpubr/reference/ggarrange.html 


## Différents systèmes graphiques

Depuis le début, l'ensemble des graphiques que nous vous avons proposé utilise la fonction `chart()` du package `chart`. Cependant, il ne s'agit pas du seul outil permettant de réaliser des graphiques dans R. 

```{r, fig.cap= "Nuage de point montrant la variation de la taille en fonction du poids d'oursins et de leur origine avec le système graphique chart()."}
# Importation des données
(urchin <- read("urchin_bio", package = "data.io"))
# Réalisation du graphique
chart(urchin,formula = height ~ weight %col=% origin) + 
  geom_point() 
```

Voici d'autres alternatives que sont 

- R de base

```{r, fig.cap= "Nuage de point montrant la variation de la taille en fonction du poids d'oursins et de leur origine avec le système graphique  r de base."}
plot(urchin$weight, urchin$height, col = urchin$origin, ylab = "Taille [mm]", xlab = "Poids immergé [g]")
legend(x = 80, y = 10, legend = c("Farm", "Fishery"), col = c("Black", "Red"), pch = 1)
```

- lattice

```{r, fig.cap= "Nuage de point montrant la variation de la taille en fonction du poids d'oursins et de leur origine avec le système graphique lattice."}
theme_sciviews_lattice()
xyplot( height ~ weight, data = urchin, groups = origin, 
        ylab = "Taille [mm]", xlab = "Poids immergé [g]", auto.key = TRUE)
```

- ggplot2

```{r, fig.cap= "Nuage de point montrant la variation de la taille en fonction du poids d'oursins et de leur origine avec le système graphique ggplot2."}
ggplot(data = urchin) +
  geom_point(mapping = aes(x = weight, y = height, color = origin)) +
  labs( x = "Poids immergé [g]", y = "Taille [mm]")
```

Vous observez rapidement certaines similitudes entre `chart`, `ggplot2` et `lattice`. En effet, la package `chart` a pour but premier de combiner les meilleures outils présents dans chacun des modes graphiques présentés ci-dessus. 

### Pour en savoir plus

- http://r4ds.had.co.nz/data-visualisation.html 

- https://flowingdata.com/2016/03/22/comparing-ggplot2-and-r-base-graphics/

- https://learnr.wordpress.com/2009/08/26/ggplot2-version-of-figures-in-lattice-multivariate-data-visualization-with-r-final-part/

- https://www.statmethods.net/advgraphs/trellis.html

- https://www.r-bloggers.com/conditioning-and-grouping-with-lattice-graphics/

- http://bl.ocks.org/patilv/raw/7360425/

- http://www.sthda.com/english/wiki/scatter-plots-r-base-graphs



## A vous de jouer !

Proposez 5 graphiques inédits (qui n'ont pas été vu dans le module 2, 3 et 4) dans vos différents projets 

Employez par exemple les liens suivants pour vous inspirer

- <https://www.r-graph-gallery.com>

- <http://r-statistics.co/Top50-Ggplot2-Visualizations-MasterList-R-Code.html>


Terminez ce module en vérifiant que vous avez acquis l'ensemble des notions de ce module.

```{block2, type='bdd'}

Ouvrez RStudio dans votre SciViews Box, puis exécutez l'instruction suivante dans la fenêtre console :

    BioDataScience::run("....")

```


