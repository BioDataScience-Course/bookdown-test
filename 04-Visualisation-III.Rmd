# Visualisation III {#visu3}

```{r setup, include=FALSE, echo=FALSE, message=FALSE, results='hide'}
SciViews::R
```


##### Objectifs {-}

- Savoir réaliser différents graphiques pour représenter des variables facteurs comme le graphique en barres, ou le graphique en camembert dans R avec la fonction `chart()`

- Comprendre et utiliser la boîte de dispersion pour _synthétiser_ la distribution de données numériques 

- Arranger différents graphiques dans une figure unique

- Découvrir différents systèmes graphiques (graphiques de base, lattice, ggplot2) et les comparer entre eux


##### Prérequis {-}

Assurez-vous de bien maîtriser les bases relatives à la représentation graphiques vues dans le module \@ref(visu1) et que vous êtes à l'aise dans l'utilisation de vos outils logiciels (SciViews Box, RStudio, R Markdown).


## Graphique en barres

Le graphique en barres (on dit aussi graphique en bâtons) compare les effectifs pour différents niveaux (ou modalités) d'une variable qualitative ou facteur. La différence avec l'histogramme est donc subtile et tient au fait que, pour l'histogramme, nous partons d'une variable quantitative qui est découpée en classes.


### Effectifs par facteur

La question du nombre et/ou de l'intervalle des classes ne se pose pas dans le cas du graphique en barres. Par défaut, les barres seront séparées les unes des autres par un petit espace vide pour bien indiquer visuellement qu'il n'y a pas continuité entre les classes (dans l'histogramme, les barres sont accolées les unes aux autres pour matérialiser justement cette continuité).

La formule que vous utiliserez, ici encore, ne fait appel qu'à une seule variable et s'écrira donc :

$$\sim variable \ facteur$$

```{r barres-facteur, fig.cap= "Exemple d'un graphique en barres montrant le dénombrement des niveaux d'une variable facteur, avec les éléments importants du graphique mis en évidence en couleurs.", echo=FALSE, message=FALSE}
zooplankton <- read("zooplankton", package = "data.io", lang = "FR")
copepoda <- filter(zooplankton,
  class %in% c("Calanoïde", "Cyclopoïde",  "Harpacticoïde", "Poecilostomatoïde"))

chart(data = copepoda, ~ class) +
  geom_bar() +
  labs(x = "Label de l'axe x  + [Unité éventuelle]", 
       y = "Effectifs") +
  theme(axis.text.x = element_text(colour = "#a80039", size = 14), 
        axis.title.x = element_text(colour = "#029687", size = 14), 
        axis.text.y = element_text(colour = "#a80039", size = 14), 
        axis.title.y = element_text(colour = "#029687", size = 14),
        axis.line.x = element_line(colour = "#a80039"),
        axis.line.y = element_line(colour = "#a80039"))
```

Outre les barres elles-mêmes, prêtez toujours attention aux éléments suivants du graphique (ici mis en évidence en couleurs) :

- les axes avec les graduations (en rouge)
- les niveaux de la variable facteur (en rouge également)
- le label des axes (en bleu)

Les instructions dans R pour produire un graphique en barres à l'aide de la fonction `chart()` sont :

```{r barres-facteur2, fig.cap="Abondances de quatres types de copépodes dans un échantillon de zooplancton."}
# Importation du jeu de données
(zooplankton <- read("zooplankton", package = "data.io", lang = "FR"))
# Réduction du jeu de données 
(copepoda <- filter(zooplankton,
  class %in% c("Calanoïde", "Cyclopoïde",  "Harpacticoïde",  "Poecilostomatoïde")))
# Réalisation du graphique
chart(data = copepoda, ~ class) +
  geom_bar() +
  ylab("Effectifs")
```

La fonction `geom_bar()` se charge d'ajouter les barres verticales dans le graphique. La hauteur de ces barres correspond au nombre d'observations rencontrées dans le jeu de données pour chaque niveau (ou classe, ou groupe) de la variable facteur représentée.


### Effectifs par 2 facteurs

```{r}
# Importation des données biometry
(biometry <- read("biometry", package = "BioDataScience", lang = "FR"))
# Conversion de la variable year_measure de numérique à facteur
biometry$year_measure <- as.factor(biometry$year_measure)
label(biometry$year_measure) <- "Année de la mesure"
```

Différentes représentations sont possibles pour observer des dénombrements tenant compte de plusieurs variables facteurs. Par défaut, l'argument `position =` a pour valeur `stack` (donc, lorsque cet argument n'est pas précisé dans `geom_bar()`).

```{r barres-2facteurs, fig.cap="Dénombrement des hommes (H) et des femmes (F) dans l'étude sur l'obésité en Hainaut en tenant compte des années de mesure pour (B).", echo=TRUE}
a <- chart(data = biometry, ~ gender) +
  geom_bar() +
  ylab("Effectifs")

b <- chart(data = biometry, ~ gender %fill=% year_measure) +
  geom_bar() +
  ylab("Effectifs") +
  scale_fill_viridis_d()

combine_charts(list(a, b), common.legend = TRUE)
```

Il existe d'autres options possible en utilisant les valeurs `dodge` ou `fill` pour l'argument `position =`.

```{r barres-2facteurs2, fig.cap="Dénombrement des hommes (H) et des femmes (F) dans l'étude sur l'obésité en Hainaut en tenant compte des années de mesure (différentes présentations).", echo=TRUE}
a <- chart(data = biometry, ~ gender %fill=% year_measure) +
  geom_bar(position = "stack") +
  ylab("Effectifs") +
  scale_fill_viridis_d()

b <- chart(data = biometry, ~ gender %fill=% year_measure) +
  geom_bar(position = "dodge") +
  ylab("Effectifs") +
  scale_fill_viridis_d()

c <- chart(data = biometry, ~ gender %fill=% year_measure) +
  geom_bar(position = "fill") +
  ylab("Fractions") +
  scale_fill_viridis_d()

combine_charts(list(a, b, c), common.legend = TRUE)
```

Soyez vigilant à la différence entre l'argument `position = stack` et `position = fill` qui malgré un rendu semblable ont l'axe des ordonnées qui diffère (dans le cas de `fill`, il s'agit de la **fraction** par rapport au total qui est représentée, et non pas des **effectifs** absolus dénombrés).


##### Pièges et Astuces {-}

###### Réordonner la variable facteur par fréquence {-}

Vous pouvez avoir le souhait d'ordonner votre variable facteur afin d'améliorer le rendu visuel de votre graphique. Pour cela, vous pouvez employer la fonction `fct_infreq()`. 

```{r barres-facteur-ordonné, fig.cap="Dénombrement des classes de copépodes du jeu de données zooplankton."}
chart(data = copepoda, ~ fct_infreq(class)) +
  geom_bar() +
  labs(x = "Classe", y = "Effectifs")
```

###### Rotation des axes du graphique en barre {-}

Lorsque les niveaux dans la variable étudiée sont trop nombreux, les légendes en abscisse risquent de se chevaucher, comme dans la Fig. \@ref(fig:barchart1)

```{r barchart1, fig.cap="Dénombrement des classes du jeu de données zooplankton."}
chart(data = zooplankton, ~ class) +
  geom_bar() +
  ylab("Effectifs")
```

Avec la fonction `coord_flip()` ajoutée à votre graphique, vous pouvez effectuer une rotation des axes pour obtenir un **graphique en barres horizontales**. De plus, l’œil humain perçoit plus distinctement les différences de longueurs horizontales que verticales. Donc, de ce point de vue, le graphe en barres horizontales est considéré comme meilleur que le graphe en barres verticales.

```{r barres-rotation, fig.cap="Dénombrement des classes du jeu de données zooplankton (version avec barres horizontales)."}
chart(data = zooplankton, ~ class) +
  geom_bar() +
  ylab("Effectifs") +
  coord_flip()
```


##### Pour en savoir plus {-}

- [Graphes en barres à l'aide de ggplot2](http://www.sthda.com/french/wiki/ggplot2-barplots-guide-de-demarrage-rapide-logiciel-r-et-visualisation-de-donnees). Un tutoriel en français utilisant la fonction `ggplot()`. L'annotation des barres est également présentée.

- [Page d'aide de la fonction `geom_bar()`](http://ggplot2.tidyverse.org/reference/geom_bar.html) en anglais.

- [Autres exemples de graphes en barres](http://ggplot.yhathq.com/docs/geom_bar.html) à l'aide de ``ggplot()`.


### Valeurs moyennes  {#barres-mean}

Le graphique en barres peut être aussi employé pour résumer des données numériques via la moyenne. Il ne s'agit plus de dénombrer les effectifs d'une variable facteur mais de résumer des données numériques en fonction d'une variable facteur. On peut exprimer cette relation dans R sous la forme de

$$y \sim x$$

que l'on peut lire :

$$y \ en \ fonction \ de \ x$$

Avec _y_ une variable numérique et _x_ une variable facteur. Considérez l'échantillon suivant :

```
1, 71, 55, 68, 78, 60, 83, 120, 82 ,53, 26
```

Calculez la moyenne sur base de la formule de la moyenne

$$\overline{y} = \sum_{i = 1}^n \frac{y_i}{n}$$


```{r}
# Création du vecteur
x <- c(1, 71, 55, 68, 78, 60, 83, 120, 82, 53, 26)
# Calcul  de la moyenne
mean(x)
```

Les instructions pour produire ce graphe en barres à l'aide de `chart()` sont :

```{r barres-mean, fig.cap="Exemple de graphique en barres représentant les moyennes de tailles par groupe zooplanctonique."}
chart(data = copepoda, size ~ class) +
  stat_summary(geom = "col", fun.y = "mean")
```

Ici, nous faisons appel à une autre famille de fonctions : celles qui effectuent des calculs sur les données avant de les représenter graphiquement.

```{block2, type='warning'}
Le graphe en barres pour représenter les moyennes est très répandu dans le domaine scientifique malgré le grand nombre d'arguments en sa défaveur et que vous pouvez lire dans la section **pour en savoir plus** ci-dessous. L'un des arguments le plus important est la faible information qu'il véhicule puisque l'ensemble des données n'est plus représenté que par une valeur (la moyenne) pour chaque niveau de la variable facteur. Pour un petit nombre d'observations, il vaut mieux toutes les représenter à l'aide d'un nuage de points. Si le nombre d'observations devient très grand (dizaines ou plus), le graphique en boites de dispersion est plus indiqué (voir plus loin dans ce module).
```

##### A vous de jouer {-}

`r learnr("A04La_barres", title = "Graphique en barres", toc = "Réalisation de graphiques en barres dans R")`

##### Pour en savoir plus {-} 

- [Beware of dynamite](http://biostat.mc.vanderbilt.edu/wiki/pub/Main/TatsukiRcode/Poster3.pdf). Démonstration de l'impact d'un graphe en barres pour représenter la moyenne (et l'écart type) = graphique en "dynamite".

- [Dynamite plots : unmitigated evil?](http://emdbolker.wikidot.com/blog%3Adynamite) Une autre comparaison du graphe en dynamite avec des représentations alternatives qui montre que le premier peut avoir quand même quelques avantages dans des situations particulières.


## Graphique en camembert

Le graphique en camembert (ou en parts de tarte, ou encore appelé diagramme circulaire, *pie chart* en anglais) vous permettra de visualiser un dénombrement d'observations par facteur, tout comme le graphique en barres. 

```{r piechart, fig.cap="Exemple de graphique en camembert montrant les effectifs des niveaux d'une variable facteur."}
chart(data = copepoda, ~ factor(0) %fill=% class) +
  geom_bar(width = 1) + 
  coord_polar("y", start = 0) +
  theme_void() +
  scale_fill_viridis_d()
```

Ce graphique est plus difficile à réaliser à l'aide de `chart()` ou `ggplot()`. En fait, il faut ruser ici, et l'auteur du package **ggplot2** n'avait tout simplement pas l'intention d'ajouter ce type de graphique dans la panoplie proposée. En effet, il faut savoir que l’œil humain est nettement moins bon pour repérer des angles que pour comparer des longueurs. **Donc, le diagramme en barres est souvent meilleur pour comparer des effectifs par classes.** Mais d'une part, le graphique en camembert est (malheureusement) un graphique très répandu et il faut savoir l'interpréter, et d'autre part, il peut s'avérer quand même utile dans certaines situations. Notez l'utilisation de la fonction `theme_void()` qui crée un graphique sans axes.


##### Pièges et astuces {-}

Partons d'un exemple fictif pour vous convaincre qu'un graphique en barres est souvent plus lisible qu'un graphique en camembert. Combien d'observations comptez-vous pour la lettre **H** ? 

```{r, echo=FALSE}
df <- data_frame(
  Index    = 1:347,
  Facteur  = as.factor(rep(LETTERS[1:10],
    times = c(10, 1, 1, 50, 2, 78, 101, 24, 31, 49)
  ))
)
```


```{r piechart2, echo=FALSE, fig.cap="Arrivez-vous à lire facilement des valeurs sur un graphique en camenbert (une échelle y est ajoutée de manière exceptionnelle pour vous y aider)."}
chart(data = df, ~ factor(0) %fill=% Facteur) +
  geom_bar(width = 1) + 
  coord_polar("y", start = 0) +
  labs( x = "", y = "") +
  scale_fill_viridis_d()
```

Maintenant, effectuez le même exercice sur base d'un graphique en barres, combien d'observations pour la lettre **H** ?

```{r barchart2, echo=FALSE, fig.cap="Dénombrement des niveaux d'une variable facteur sur un graphique en barres."}
chart(data = df, ~ Facteur %fill=% Facteur) +
  geom_bar(width = 1) +
  ylab("Effectifs") +
  scale_fill_viridis_d()
```

Dans ce dernier cas, c'est bien plus facile : il y a effectivement 24 observations relatives à la lettre **H**.

##### A vous de jouer {-}

`r learnr("A04Lb_barres", title = "Graphique en camembert", toc = "Réalisation de graphiques en camembert dans R")`

##### Pour en savoir plus {-} 

- [Graphique en camembert à l'aide de la fonction `ggplot()`](http://www.sthda.com/french/wiki/ggplot2-graphique-en-camembert-guide-de-demarrage-rapide-logiciel-r-et-visualisation-de-donnees). Explications en français des différentes étapes pour passer d'un graphique en barres à un graphique en camembert avec **ggplot2**.

- [Autre explication](https://dataparkblog.wordpress.com/2017/09/24/diagramme-en-camembert-avec-r-et-ggplot/) en français, également accompagnée d'informations sur les bonnes pratiques en matière de graphique en camembert.

- [Save the pies for dessert](http://www.perceptualedge.com/articles/08-21-07.pdf) est une démonstration détaillée des méfaits du graphique en camembert (le graphique en camembert, un graphique puant ? Pourrait-on peut-être titrer en français).

- [Les côtés positifs du graphe en camembert](https://www.displayr.com/why-pie-charts-are-better-than-bar-charts/) sont mis en évidence dans ce document (en anglais).


## Boite de dispersion {#boxplot}

Vous souhaitez représenter graphiquement cette fois *un résumé* d'une variable numérique mesurée sur un nombre (relativement) important d'individus, soit depuis une dizaine jusqu'à plusieurs millions. Vous souhaitez également conserver de l'information sur la distribution des données, et voulez éventuellement comparer plusieurs distributions entre elles : soit différentes variables, soit différents niveaux d'une variable facteur. Nous avons déjà vu au module \@ref(visu2) les diagrammes en violon et en lignes de crêtes pour cet usage. Nous allons étudier ici les **boites de dispersion** (encore appelée boite à moustaches) comme option alternative intéressante. La boite de dispersion représentera graphiquement cinq descripteurs appelés les **cinq nombres**.

Considérez l'échantillon suivant :

```
1, 71, 55, 68, 78, 60, 83, 120, 82 ,53, 26
```
Ordonnez-le de la plus petite à la plus grande valeur :

```{r}
# Créer du vecteur
x <- c(1, 71, 55, 68, 78, 60, 83, 120, 82, 53, 26)
# Ordonner le vecteur par ordre croissant
sort(x)
```

Le premier descripteur des cinq nombres est la **médiane** qui est la valeur se situant à la moitié des observations, donc, avec autant d'observations plus petites et d'observations plus grande qu'elle. La médiane sépare l'échantillon en deux.

```{r}
median(x)
```

Les quartiles séparent l'échantillon en quatre. Le **premier quartile** (Q1) sera la valeur pour laquelle 25% des observations seront plus petites. Elle se situe donc entre la valeur minimale et la médiane. Cette médiane est égale au second quartile (50% des observations plus petites). Le **troisième quartile** (Q3) est la valeur pour laquelle 75% des observations de l'échantillon sont plus petites^[Notez que, lorsque la coupure tombe entre deux observations, une valeur intermédiaire est utilisée. Ici par exemple, le premier quartile est entre 53 et 55, donc, il vaut 54. Le troisième quartile se situe entre 78 et 82. Il vaut donc 80.]. Enfin, la valeur **minimale** et la valeur **maximale** observées dans l'échantillon complètent ces cinq nombres qui décrivent de manière synthétique la *position* et l'*étendue* des observations.

```{block2, type='note'}
Les **cinq nombres** sont : la **valeur minimale**, le **premier quartile**, la **médiane** (ou deuxième quartile), le **troisième quartile** et la **valeur maximale**.
```

Voici comment on les calcules facilement dans R :

```{r}
fivenum(x)
```

La boite de dispersion est une représentation graphique codifiée de ces cinq nombres. La représentation de `x` sous forme de nuage de points n'est ni très esthétique, ni très lisible, surtout si nous avons affaire à des milliers ou des millions d'observations qui se chevauchent sur le graphique^[Il est possible de modifier la transparence des points et/ou de les déplacer légèrement vers la gauche ou vers la droite de manière aléatoire pour résoudre le problème de chevauchement des points sur un graphique en nuage de points univarié.].

```{r nuage-de-points, fig.cap="Nuage de points univarié.", echo=FALSE}
df <- data_frame(x = x)
chart(data = df, x ~ 0) +
  geom_point() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.text.x.top = element_blank()) +
  labs(x = "", y = "")
```

La boite de dispersion va remplacer cette représentation peu lisible par un objet géométrique qui représente les cinq nombres.

```{r boxplot-construct, fig.cap="A) Nuage de points annoté avec les cinq nombres représentés par des traits horizontaux. B) Boite de dispersion obtenue pour les même données que A.", echo=FALSE}

a <- chart(data = df, x ~ 0) +
  geom_point() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.text.x.top = element_blank()) +
  labs(x = "", y = "") + 
  geom_hline(yintercept = fivenum(x)) +
  geom_hline(yintercept = median(x), size = 1.3)

b <- chart(df, x ~ 0) +
  geom_boxplot(outlier.colour = "#a80039", fill = "#029687") +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.text.x.top = element_blank()) +
  labs(x = "", y = "")

combine_charts(list(a, b))
```

Vous observez à la Fig. \@ref(fig:boxplot-construct) que certaines valeurs minimales et maximales ne sont pas reliées à la boite de dispersion, il s'agit de **valeurs extrêmes**.

```{block2, type='note'}
**Règle pour déterminer s'il y a des valeurs extrêmes avec une boite de dispersion\ :** une valeur est considérée comme extrême si son écart par rapport à la boite est supérieur à une fois et demi la hauteur de la boite (encore appelée **espace inter-quartile** IQR correspondant à Q3 - Q1). Les tiges (ou "moustaches") qui prolongent la boite de dispersion s'arrêtent donc aux dernières valeurs les plus petites et plus grandes, mais qui rentrent encore dans une fois et demi l'IQR. Les valeurs extrêmes sont ensuite représentées individuellement par un point au dessus et en dessous.
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# https://www.r-bloggers.com/exploring-ggplot2-boxplots-defining-limits-and-adjusting-style/
ggplot_box_legend <- function(family = "sans") {
  # Create data to use in the boxplot legend
  set.seed(100)
  sample_df <- data.frame(parameter = "test",
                          values    = sample(500))
  
  # Extend the top whisker a bit
  sample_df$values[1:100] <- 701:800
  # Make sure there's only 1 lower outlier
  sample_df$values[1] <- -350
  
  # Function to calculate important values
  ggplot2_boxplot <- function(x) {
    quartiles <- as.numeric(quantile(x, probs = c(0.25, 0.5, 0.75)))
    
    names(quartiles) <- c("1er quartile", 
                          "2ème quartile\n(médiane)",
                          "3ème quartile")
    
    IQR <- diff(quartiles[c(1, 3)])
    
    upper_whisker <- max(x[x < (quartiles[3] + 1.5 * IQR)])
    lower_whisker <- min(x[x > (quartiles[1] - 1.5 * IQR)])
    
    upper_dots <- x[x > (quartiles[3] + 1.5 * IQR)]
    lower_dots <- x[x < (quartiles[1] - 1.5 * IQR)]
    
    list("quartiles" = quartiles,
         "1er quartile" = as.numeric(quartiles[1]),
         "2ème quartile\n(médiane)" = as.numeric(quartiles[2]),
         "3ème quartile" = as.numeric(quartiles[3]),
         "IQR" = IQR,
         "moustache supérieure" = upper_whisker,
         "moustache inférieure" = lower_whisker,
         "extrêmes hauts" = upper_dots,
         "extrêmes bas" = lower_dots)
  }
  
  # Get those values
  ggplot_output <- ggplot2_boxplot(sample_df$values)
  
  # Lots of text in the legend, make it smaller and consistent font
  update_geom_defaults("text", list(size = 3, hjust = 0, family = family))
  # Labels don't inherit text
  update_geom_defaults("label", list(size = 3, hjust = 0, family = family))
  
  # Create the legend
  # The main elements of the plot (the boxplot, error bars, and count)
  # are the easy part.
  # The text describing each of those takes a lot of fiddling to
  # get the location and style just right:
  explain_plot <- ggplot() +
    stat_boxplot(data = sample_df,
                 aes(x = parameter, y = values),
                 geom = 'errorbar', width = 0.3) +
    geom_boxplot(data = sample_df,
                 aes(x = parameter, y = values), 
                 width = 0.3, fill = "#029687") +
    theme_minimal(base_size = 5, base_family = family) +
    geom_segment(aes(x = 2.3, xend = 2.3, 
                     y = ggplot_output[["1er quartile"]], 
                     yend = ggplot_output[["3ème quartile"]])) +
    geom_segment(aes(x = 1.2, xend = 2.3, 
                     y = ggplot_output[["1er quartile"]], 
                     yend = ggplot_output[["1er quartile"]])) +
    geom_segment(aes(x = 1.2, xend = 2.3, 
                     y = ggplot_output[["3ème quartile"]], 
                     yend = ggplot_output[["3ème quartile"]])) +
    geom_text(aes(x = 2.4, y = ggplot_output[["2ème quartile\n(médiane)"]]), 
              label = "Espace\ninter-quartile", fontface = "bold", vjust = 0.4) +
    geom_text(aes(x = c(1.17,1.17), 
                  y = c(ggplot_output[["moustache supérieure"]],
                        ggplot_output[["moustache inférieure"]]), 
                  label = c("Plus grande valeur comprise dans 1.5 fois\nl'espace inter-quartile\nau dessus du 3ème quartile",
                            "Plus petite valeur comprise dans 1.5 fois\nl'espace inter-quartile\nen dessous du 1er quartile")),
                  fontface = "bold", vjust = 0.9) +
    geom_text(aes(x = c(1.17), 
                  y =  ggplot_output[["extrêmes bas"]], 
                  label = "Valeur extrême"), 
                  vjust = 0.5, fontface = "bold") +
    #geom_text(aes(x = c(1.95), 
    #              y =  ggplot_output[["extrêmes bas"]], 
    #              label = " valeur < 1.5 fois\nl'espace inter-quartile"), 
    #              vjust = 0.5) +
    geom_label(aes(x = 1.17, y = ggplot_output[["quartiles"]], 
                   label = names(ggplot_output[["quartiles"]])),
                   vjust = c(0.4, 0.85, 0.4), fill = "white", label.size = 0) +
    ylab("") + xlab("") +
    theme(axis.text = element_blank(),
          axis.ticks = element_blank(),
          panel.grid = element_blank(),
          aspect.ratio = 4/3,
          plot.title = element_text(hjust = 0.5, size = 10)) +
    coord_cartesian(xlim = c(1.4,3.1), ylim = c(-600, 900)) +
    labs(title = "Description")
  
  explain_plot
}
```

La boite de dispersion finale ainsi que sa description sont représentées à la Fig. \@ref(fig:boxplot-desc) ci-dessous.

```{r boxplot-desc, fig.cap="A) Boite de dispersion pour `x` et B) description des différents éléments constitutifs.", echo=FALSE}
a <- chart(df, x ~ 0) +
  stat_boxplot(geom = 'errorbar', width = 0.3) +
  geom_boxplot(fill = "#029687", width = 0.3) +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(), 
        axis.text.x.top = element_blank()) +
  labs(x = "Label de l'axe x", y = "Label de l'axe y [unité]")
b <- ggplot_box_legend()

combine_charts(list(a, b))
```

Les instructions dans R pour produire un graphique en boites de dispersion parallèles (comparaison de la distribution d'une variable numérique pour différents niveaux d'une autre variable facteur) sont :

```{r boxplot, fig.cap="Distribution des tailles par groupes taxonomiques pour le zooplancton."}
chart(data = copepoda, size ~ class) +
  geom_boxplot()
```

La formule à employer est `YNUM (size) ~ XFACTOR (class)`. Ensuite, pour réaliser une boite de dispersion vous devez ajouter la fonction `geom_boxplot()`.


### Taille de l'échantillon

Lors de la réalisation de boites de dispersion, vous devez être vigilant au nombre d'observations qui se cachent sous chacune d'elles. En effet, réaliser une boite de dispersion à partir d'échantillons ne comportant que cinq valeurs ou moins n'a *aucun* sens ! 

```{r boxplot-points, fig.cap= "Piège des boites de dispersion : trop peu d'observations disponibles pour `a`.", echo= FALSE}
df <- data_frame(Facteur = rep(c("A", "B", "C"), times = c(4, 11, 8)), 
                 Valeur  = c(55, 83, 120, 26,
                             1, 71, 55, 68, 78, 60, 83, 120, 82, 53, 26,
                             1, 71, 78, 60, 83, 120, 53, 26))
chart(data = df, Valeur ~ Facteur) +
  geom_boxplot() +
  geom_point(color = "red") 
```

La boite de dispersion **`A`** est calculée à partir de seulement quatre observations. C'est trop peu. Comme les points représentant les observations ne sont habituellement pas superposés à la boite, cela peut passer inaperçu et tromper le lecteur ! Une bonne pratique consiste à ajouter *n*, le nombre d'observations au-dessus de chaque boite. Cela peut se faire facilement avec les fonctions `give_n()` et `stat_summary()` ci-dessous.

```{r boxplot2, fig.cap="Taille de copépodes pour différents groupes taxonomiques (le nombre d'observations est indiqué au dessus de chaque boite)."}
give_n <- function(x)
  c(y = max(x) * 1.1, label = length(x)) 

chart(data = copepoda, size ~ class) +
  geom_boxplot() + 
  stat_summary(fun.data = give_n, geom = "text", hjust = 0.5)
```


### En fonction de 2 facteurs

La Fig. \@ref(fig:boxplot-tooth) présente un graphique en boites de dispersion parallèles qui combine l'usage de *deux* variables facteurs différentes.

```{r boxplot-tooth, fig.cap=" Croissance de dents de cochons d'Inde en fonction de la supplémentation (OJ = jus d'orange, VC = vitamine C) et de la dose administrée (n indiqué au dessus de chaque boite)."}
# Importation du jeu de données ToothGrowth
(tooth_growth <- read("ToothGrowth", package = "datasets"))
# Remaniement et labelisation du jeu de données
tooth_growth$dose <- as.ordered(tooth_growth$dose)
tooth_growth <- labelise(tooth_growth, self = FALSE,
  label = list(
    len = "Longueur des dents",
    supp = "Supplémentation",
    dose = "Dose"
  ),
  units = list(
    len = "mm",
    supp = NA,
    dose = "mg/J"
  )
)
# Réalisation graphique
chart(data = tooth_growth, len ~ supp %fill=% dose) +
  geom_boxplot() +
  stat_summary(fun.data = give_n, geom = "text", hjust = 0.5,
    position = position_dodge(0.75))
```


##### A vous de jouer {-}

`r learnr("A04Lc_boxplot", title = "Boite de dispersion", toc = "Réalisation de boites de dispersion dans R")`

##### Pour en savoir plus {-} 

- [Un tutoriel boites de dispersion à l'aide de `ggplot()`](http://www.sthda.com/french/wiki/ggplot2-box-plot-guide-de-demarrage-rapide-logiciel-r-et-visualisation-de-donnees) présentant encore bien d'autres variantes possibles.

- [Box plots in `ggplot2`](https://plot.ly/ggplot2/box-plots/). Autre explication en anglais avec sortie utilisant **plotly**.

- [Grouped box plots](http://www.r-graph-gallery.com/265-grouped-boxplot-with-ggplot2/).

- [Explication plus détaillée sur les cinq nombres](https://chemicalstatistician.wordpress.com/2013/08/12/exploratory-data-analysis-the-5-number-summary-two-different-methods-in-r-2/), en anglais.


## Figures composées

Il arrive fréquemment de vouloir combiner plusieurs graphiques dans une même figure.
Plusieurs fonctions sont à votre disposition pour cela. Il faut tout d'abord distinguer deux types de figures multi-graphiques :

1. Soit il s'agit d'un seul graphique que vous souhaitez subdiviser par rapport à une ou des variables facteurs.
2. Soit il s'agit de graphiques indépendants que vous souhaitez assembler dans une même figure parce que les données ont un lien entre elles, ou parce que ces graphiques sont complémentaires pour comprendre les données.

Dans le premier cas, les fonctions `facet_XXX()` comme `facet_grid()` peuvent être employées. Dans le second cas, la fonction `combine_charts()` est l'une des alternatives possibles.


### Facettes

L'une des règles les plus importantes que vous devez impérativement garder à l'esprit lors de la réalisation de vos graphiques est *la simplicité*. Au plus votre graphique contiendra d'information au plus il sera compliqué à décoder par vos lecteurs. 

```{r chick1, fig.cap= "Croissance de poulets en utilisant quatre aliments différents."}
# Importation de données relative à la croissance de poulets
(chick_weight <- read("ChickWeight", package = "datasets"))
# Réalisation du graphique (points semi-transparents)
chart(data = chick_weight, weight ~ Time %col=% Diet) +
  geom_point(alpha = 0.5) +
  labs(x = "Age [j]", y = "Masse [g]")
```

Le graphique à la Fig. \@ref(fig:chick1) est mal adapté pour montrer les différences entre les quatre aliments : tous les points sont entremêlés. Il peut typiquement être simplifié en utilisant des facettes pour représenter les résultats relatifs aux différents régimes alimentaires sur des graphiques séparés. L'information est la même mais la lecture est beaucoup plus aisée.

```{r chick-facette, fig.cap= "Croissance de poulets en utilisant quatre aliments différents (1-4)."}
chart(data = chick_weight, weight ~ Time | Diet) +
  geom_point(alpha = 0.5) +
  labs(x = "Age [j]", y = "Masse [g]")
```

Vous observez que les échelles en abscisse et en ordonnée sont similaires sur tous les graphiques. Cela permet une meilleure comparaison. Notez toutefois que, plus le nombre de facettes augmente, plus chaque graphique individuel devient petit. Faites attention à ne pas finir avec des graphiques individuels tellement petits qu'ils en deviennent illisibles !


### Graphiques assemblés

La fonction `combine_charts()` permet de combiner plusieurs graphiques dans une figure unique. Nous l'avons déjà utilisée à plusieurs reprises. Cette fonction attend une liste de graphiques de type `chart()` à assembler.

```{r combine-charts, fig.cap= "A) Masse d'oursins en fonction de leur taille  et de leur origine. B) Masse totale en fonction de la masse des parties solides de ces mêmes oursins."}
# Importation des données
urchin <- read("urchin_bio", package = "data.io", lang = "FR")
# Réalisation des graphiques
a <- chart(data = urchin, weight ~ height %col=% origin) +
  geom_point()

b <- chart(data = urchin, weight ~ solid_parts %col=% origin) +
  geom_point()

# Combinaison des graphiques dans une même figure
combine_charts(list(a, b), common.legend = TRUE)
```

Il existe d'autres fonctions permettant de combiner plusieurs graphiques comme [`plot_grid()`](https://cran.r-project.org/web/packages/cowplot/vignettes/plot_grid.html) du package **cowplot**, mais avec `combine_charts()` vous pourrez déjà faire beaucoup. De plus, un libellé sous forme d'une lettre majuscule est automatiquement associé à chaque sous-région de la figure composée. Cela permet d'y faire plus facilement référence dans le texte et/ou dans la légende.

##### A vous de jouer {-}

`r learnr("A04Ld_fig_composees", title = "Graphiques composés", toc = "Réalisation de graphiques composés dans R")`

```{r, echo=FALSE, results='asis'}
assignation("A03Ga_graphe_avance", part = NULL,
  url = "https://github.com/BioDataScience-Course/A04Ga_graphe_avance",
  course.urls = c(
    'S-BIOG-006' = "https://classroom.github.com/a/...",
    'S-BIOG-921' = "https://classroom.github.com/a/3EMyegs8"),
  toc = "Réalisation de différents graphiques avancés.")
```
##### Pour en savoir plus {-} 

- [Partitionnement des graphiques en facettes](http://www.sthda.com/french/wiki/ggplot2-facet-diviser-un-graphique-en-plusieurs-panneaux-logiciel-r-et-visualisation-de-donnees). Différentes options sont présentées ici.

- [Figures composées à l'aide de `grid.arrange()`](http://lightonphiri.org/blog/ggplot2-multiple-plots-in-one-graph-using-gridextra). Une autre option, mais moins flexible et moins riche que `combine_charts()`. 

- [Figures composées à l'aide de `plot_grid()`](https://wilkelab.org/cowplot/reference/plot_grid.html) avec les différentes options, aussi disponibles avec `combine_charts()`.

- [Troisième possibilité pour des figures composées à l'aide de `ggarrange()`](http://www.sthda.com/english/rpkgs/ggpubr/reference/ggarrange.html). `combine_charts()` fait la même chose, mais avec des valeurs par défaut légèrement différentes (`labels = "auto"` par défaut pour ce dernier, mais `labels = NULL` pour `ggarrange()`). 


## Différents moteurs graphiques

<center>

![Prolifération des standards d'après [xkcd](https://xkcd.com/927/).](https://imgs.xkcd.com/comics/standards.png)

</center>


Depuis le début, l'ensemble des graphiques que nous vous avons proposés utilise la fonction `chart()` du package **chart**. Cependant, il ne s'agit pas de la seule fonction permettant de réaliser des graphiques dans R, loin de là. En fait, **chart** est tout récent et a été développé pour homogénéiser autant que possible les graphiques issus de trois moteurs graphiques différents : **ggplot2**, **lattice** et les graphiques **base**. La fonction `chart()` a d'autres avantages également :

- Un thème par défaut qui est le plus proche possible d'un rendu typique d'une publication scientifique.
- La possibilité d'utiliser l'interface formule avec **ggplot2**.
- La cohérence des objets graphiques obtenus qui peuvent tous êtres combinés en une figure composée, même si ils sont produits avec des moteurs graphiques différents.
- Un libellé automatique des axes et autres éléments du graphique en fonction des attributs `label` et `units` des variables (pour l'instant, seulement les graphiques de type **ggplot2**).

```{r chart-example, fig.cap= "Graphique typique obtenu avec `chart()` : rendu par défaut publiable tel quel, et libellé automatique des axes avec les unités."}
# Importation des données
(urchin <- read("urchin_bio", package = "data.io", lang = "FR"))
# Réalisation du graphique
chart(data = urchin, height ~ weight %col=% origin) + 
  geom_point() 
```


### ggplot2

Le moteur graphique **[ggplot2](https://ggplot2.tidyverse.org)** est écrit pas Hadley Wickham, un personnage emblématique de la "révolution [tidyverse](https://www.tidyverse.org)" qui propose une surcouche moderne au dessus de R. **ggplot2** implémente une "grammaire graphique" particulièrement puissante et flexible, proposée et popularisée par le statisticien Leland Wilkinson. Par défaut, `chart()` crée en réalité un graphique **ggplot2** adapté. Voici la version **ggplot2** standard du même graphique représenté à la Fig. \@ref(fig:chart-example) :

```{r ggplot2-example, fig.cap= "Graphique typique obtenu avec `ggplot()` (moteur graphique **ggplot2**)."}
ggplot(data = urchin, mapping = aes(x = weight, y = height, col = origin)) + 
  geom_point() 
```

En comparant les Figs. \@ref(fig:chart-example) et \@ref(fig:ggplot2-example) (en faisant abstraction des instructions R utilisées pour l'instant), plusieurs points sautent immédiatement aux yeux:

- Le thème par défaut de **ggplot2** est très reconnaissable avec un quadrillage blanc sur fond gris clair. On aime ou on n'aime pas, mais il est clair que (1) ce n'est pas une présentation "standard" d'un graphique scientifique, et (2) le thème tord un peu le cou à une règle importante pour réaliser un graphique de qualité : **minimiser la quantité d'"encre" nécessaire pour représenter un graphique**, autrement dit, plus le graphique est simple et sobre, mieux c'est. Le thème par défaut de `chart()` respecte mieux tout ceci^[Notez que plusieurs thèmes existent dans **ggplot2**. Il est facile d'en changer et de les personnaliser... mais c'est toujours appréciable d'avoir un rendu impeccable dès le premier essai.].

- La taille des caractères est légèrement plus grande dans la Fig. \@ref(fig:chart-example) réalisée avec `chart()`. Le manque de lisibilité des parties textuelles dans un graphique est un défaut fréquent, dépendant de la résolution et de la taille de reproduction du graphique dans le document final. Le choix de `chart()` recule un peu ce risque.

- `chart()` est capable d'aller lire les métadonnées (libellés en français et unités des variables) et les utilisent automatiquement pour proposer des libellés corrects et complets des axes par défaut. `ggplot()` ne peut pas le faire, et il faut utiliser la fonction `labs()` pour l'indiquer manuellement.

```{block2, type='info'}
De manière générale, par rapport à `ggplot()`, `chart()` a été conçu pour produire le graphique le plus proche d'un rendu final impeccable avec tous les paramètres par défaut.
```

Quelques règles simples vous permettent de passer des **instructions** `ggplot()` à `chart()` et _vice versa_^[Etant donné l'abondante littérature écrite sur **ggplot2**, il est utile de pouvoir convertir des exemples **ggplot2** en graphiques `chart()`, si vous êtes convaincu par cette nouvelle interface.] :

1. On peut toujours remplacer `ggplot()` par `chart()` dans les instructions R (à condition que le package **chart** soit chargé bien sûr, par exemple via `SciViews::R`). Dans ce cas, le thème par défaut diffère, et le libellé automatique des axes (non disponible avec `ggplot()`) est activé.

2. Avec `chart()` on peut utiliser `aes()` pour spécifier les "esthétiques" (éléments à visualiser sur le graphique) comme pour `ggplot()`, mais on peut _aussi_ utiliser une interface formule plus compacte. Cette interface formule rapproche la version `chart()` des graphiques **ggplot2** d'un autre moteur de graphique dans R : **lattice**.

3. Outre les esthétiques classiques `x` et `y`, l'interface formule de `chart()` permet d'en inclure d'autres directement dans la formule à l'aide d'opérateurs spécifiques `%<esth>%=`. Par exemple, `aes(x = weight, y = height, col = origin)` dans la Fig. \@ref(fig:ggplot2-example) se traduit en la formule plus concise `height ~ weight %col=% origin` avec `chart()` (notez la position _inversée_ de `x` et `y ` dans la formule puisqu'on a `y ~ x`). **Tous** les esthétiques de **ggplot2** sont supportés de cette manière.

4. Partout où `aes()` est utilisé pour les instructions **ggplot2**, on peut utiliser à la place `f_aes()` et y spécifier plutôt une formule de type `chart()`.

5. Avec `ggplot()` les facettes doivent être spécifiées à l'aide de `facet_XXX()`. A condition d'utiliser `chart()`, il est possible d'inclure les spécifications des facettes les plus utilisées directement dans la formule en utilisant l'opérateur `|`. Cette façon de procéder est, encore une fois, identique à ce qui se fait dans **lattice** (voir plus loin).

Le point (5) mérite une petite démonstration pour comparaison :

```{r chart-ggplot2-facets, fig.cap= "Graphique à facettes. A. version `chart()`, B. version `ggplot()`."}
a <- chart(data = urchin, height ~ weight | origin) + 
  geom_point() 

b <- ggplot(data = urchin, mapping = aes(x = weight, y = height)) + 
  geom_point() +
  facet_grid( ~ origin)

combine_charts(list(a, b))
```


### lattice

Autant **ggplot2** est complètement modulable en ajoutant littéralement à l'aide de l'opérateur `+` des couches successives sur le graphique, autant **lattice** vise à réaliser les graphiques **en une seule instruction**. **lattice** utilise également abondamment l'interface formule pour spécifier les variables à utiliser dans le graphique. La version **lattice** du graphique d'exemple est présentée à la Fig. \@ref(fig:lattice-example).

```{r lattice-example, fig.cap= "Graphique exemple réalisé avec **lattice**."}
xyplot(height ~ weight, data = urchin, groups = origin, auto.key = TRUE)
```

Et voici la version `chart()` utilisant le moteur **lattice**. Notez la façon d'appeler la fonction `xyplot()` de **lattice** via `chart$xyplot()` :

```{r chart-lattice-example, fig.cap= "Graphique exemple réalisé avec `chart()` A. avec le moteur **lattice**, B. avec le moteur **ggplot2**."}
theme_sciviews_lattice(n = 2)
a <- chart$xyplot(height ~ weight, data = urchin, groups = origin,
  auto.key = list(space = "right", title = "Origine", cex.title = 1, columns = 1),
  ylab = "Hauteur du test [mm]", xlab = "Masse totale [g]",
  par.settings = list(superpose.symbol = list(col = scales::hue_pal()(2))))

b <- chart(data = urchin, height ~ weight %col=% origin) + 
  geom_point() 

combine_charts(list(a, b))
```

La quantité d'instructions nécessaires pour rendre la version **lattice** proche de la version **ggplot2** devrait disparaître dans les prochaines versions de `chart()`. Un autre objectif est aussi de gommer le plus possible les différences entre les rendus des différents moteurs de graphiques R, et en particuliers entre **ggplot2** et **lattice**. Comparez la Fig. \@ref(fig:chart-lattice-example)A avec la Fig. \@ref(fig:lattice-example) pour apprécier le gain déjà obtenu en matière d'homogénéisation.

```{block2, type='info'}
Par rapport à **ggplot2**, les graphiques **lattice** sont moins flexibles du fait qu'ils doivent être spécifiés en une seule instruction. Cependant, ils sont beaucoup plus rapides à générer (appréciable quand il y a beaucoup de points à tracer) ! **lattice** offre également quelques types de graphiques non supportés par **ggplot2** comme les graphiques en 3D à facettes, par exemple.
```

Voici un graphique à facettes réalisé avec `chart()` et le moteur **lattice**. Notez que la formule utilisée est *identique* à celle employée pour la version **ggplot2** avec `chart()`.

```{r lattice-facets, fig.cap= "Graphique à facettes, avec `chart()` version **lattice**."}
chart$xyplot(data = urchin, height ~ weight | origin,
  scales = list(alternating = 1),
  xlab = "Masse totale [g]", ylab = "Hauteur du test [mm]")
```

Mise à part les instructions additionnelles encore nécessaires dans cette version de `chart()`, l'appel et le rendu sont très similaires par rapport à la version **ggplot2** du même graphique avec `chart()` :

```{r ggplot2-facets2, fig.cap= "Graphique à facettes, avec `chart()` version **ggplot2**."}
chart(data = urchin, height ~ weight | origin) + 
  geom_point()
```


### Graphiques de base

Comme son nom le suggère, le moteur graphique de base est celui qui est implémenté de manière natif dans R. Il est donc utilisé un peu partout. Il est vieillissant et est plus difficile à manipuler que **ggplot2** certainement, et même que **lattice**. Néanmoins, il est très flexible et rapide, ... mais son rendu par défaut n'est plus vraiment au goût du jour. Voici notre graphique d'exemple rendu avec le moteur graphique R de base :

```{r base-example, fig.cap="Graphique exemple réalisé avec le moteur graphique R de base."}
plot(urchin$weight, urchin$height,
  col = c("red", "darkgreen")[urchin$origin], pch = 1)
legend(x = 80, y = 10, legend = c("Culture", "Pêcherie"),
  col = c("red", "darkgreen"), pch = 1)
```

Vous rencontrerez très fréquemment la fonction `plot()`. C'est une fonction dite **générique** dont le comportement change en fonction de l'objet fourni en premier argument. Ainsi, elle réalise le graphique le plus pertinent à chaque fois en fonction du contexte. Notez tout de suite les instructions un peu confuses nécessaires pour spécifier la couleur souhaitée en fonction de l'origine des oursins. Le moteur graphique de base ne gère **pas** automatiquement des aspects plus complexes du graphique, telle que le positionnement d'une légende. Donc, à moins d'avoir prévu la place suffisante _avant_ de tracer le graphique, nous ne pouvons que l'inclure à l'intérieur du cadre du graphique dans un second temps à l'aide de la fonction `legend()`. Comme cette dernière ne comprend rien à ce qui a été réalisé jusqu'ici, il faut lui respécifier les couleurs, formes et tailles de points utilisés ! C'est un des aspects pénibles du moteur graphique R de base.

Voici maintenant une version `chart()` de ce graphique de base :

```{r, eval=FALSE}
chart$base({
  par(mar = c(5.1, 4.1, 4.1, 6.1))
  plot(urchin$weight, urchin$height,
    col = scales::hue_pal()(2)[urchin$origin], pch = 19, cex = 0.8,
    xlab = "Masse totale [g]", ylab = "Hauteur du test [mm]")
  legend(x = 105, y = 20, legend = c("Culture", "Pêcherie"), title = "Origine",
    col = scales::hue_pal()(2), pch = 19, bty = "n", cex = 0.8, y.intersp = 2)
})
```

```{r chart-base, fig.keep=2, fig.cap="Graphique exemple réalisé avec le moteur graphique de base et la fonction `chart()`."}
chart$base({
  par(mar = c(5.1, 4.1, 4.1, 6.1))
  plot(urchin$weight, urchin$height,
    col = scales::hue_pal()(2)[urchin$origin], pch = 19, cex = 0.8,
    xlab = "Masse totale [g]", ylab = "Hauteur du test [mm]")
  legend(x = 105, y = 20, legend = c("Culture", "Pêcherie"), title = "Origine",
    col = scales::hue_pal()(2), pch = 19, bty = "n", cex = 0.8, y.intersp = 2)
})
```

```{block2, type='note'}
Notez que le graphique est généré deux fois : une première fois dans un format propre aux graphiques R de base, et ensuite, il est traduit en une forme compatible avec les autres graphiques **ggplot2** et **lattice** (et au passage, il gagne la grille en traits grisés). Dans le chunck, nous devons spécifier `fig.keep = 2` pour éviter d'imprimer la première version dans le rapport lorsqu'on utilise `chart$base()`.
```

Pour l'instant, le seul avantage de `chart()` avec les graphiques de base est qu'il les convertit en une forme combinable avec les autres graphiques dans une figure composite (sinon, ce n'est pas possible). A part cela, il faut fournir à `chart$base()` tout le code nécessaire pour tracer et personnaliser le graphique. Comme on peut le voir sur cet exemple, cela demande une quantité considérable de code. C'est aussi un autre aspect pénible de ce moteur graphique : il est très flexible, mais l'interface n'est pas optimale. Pour finir, les graphiques de base ont plus de mal avec les facettes, mais il peuvent quand même générer les versions les plus simples, par exemple à l'aide de la fonction `coplot()` qui accepte une formule très similaire à ce qui s'utilise avec **lattice** :

```{r coplot-example, fig.cap="Graphique à facettes avec le moteur graphique de base."}
coplot(data = urchin, height ~ weight | origin)
```

A l'issue de cette comparaison, vous pourrez décider du moteur graphique que vous préférerez utiliser. Dans le cadre de ce cours, nous n'utiliserons en tous cas que quasi-exclusivement des graphiques **ggplot2** créés à l'aide la fonction `chart()`.


##### A vous de jouer {-}

Proposez cinq graphiques inédits (qui n'ont pas été vu jusqu'ici) dans vos différents projets. Employez par exemple les liens suivants pour vous inspirer :

- <https://www.r-graph-gallery.com>

- <http://r-statistics.co/Top50-Ggplot2-Visualizations-MasterList-R-Code.html>


Terminez ce module en vérifiant que vous avez acquis l'ensemble des notions abordées.

`r learnr("A04La_graphs_adv", title = "Graphiques avancés", toc = "Réalisation de différents graphiques avancés")`

##### Pour en savoir plus {-}

- Chapitre [Data visualisation](http://r4ds.had.co.nz/data-visualisation.html) de R for Data Science qui utilise `ggplot()`. 

- Site rassemblant des [extensions pour ggplot2](http://www.ggplot2-exts.org/gallery/)

- [Introduction rapide à lattice](https://www.statmethods.net/advgraphs/trellis.html)

- [Variantes de graphiques avec lattice](https://www.r-bloggers.com/conditioning-and-grouping-with-lattice-graphics/)

- [Comparaison de lattice et ggplot2](https://learnr.wordpress.com/2009/08/26/ggplot2-version-of-figures-in-lattice-multivariate-data-visualization-with-r-final-part/). Cette page fait aussi référence à un ensemble de graphiques différents générés en **lattice** et en **ggplot2** pour comparaison (en anglais).

- [Divers exemples de graphiques réalisés avec le moteur de base](http://bl.ocks.org/patilv/raw/7360425/)

- [Autres exemples de graphiques R de base](http://www.sthda.com/english/wiki/scatter-plots-r-base-graphs)

- [ggplot2 comparé aux graphiques R de base](https://flowingdata.com/2016/03/22/comparing-ggplot2-and-r-base-graphics/). Un point de vue différent d'un utilisateur habitué aux graphiques R de base (en anglais).


## Récapitulatif des exercices

Ce module 4 vous a permis de réaliser de découvrir de nouveau graphiques. Vous savez maintenant réaliser des graphiques en barres, des graphiques en camembert et des boites de dispersion. Vous êtes aussi capable de réaliser des graphiques composés. Pour évaluer votre compréhension de cette matière vous aviez les exercices suivants à réaliser\ :

`r show_ex_toc()`
